{"meta":{"title":"Xiao's blog","subtitle":"欢迎加我微信交流技术：17683251478","description":"","author":"Chen Xiao","url":"https://chenxiao0629.github.io","root":"/"},"pages":[],"posts":[{"title":"11、docker完整笔记","slug":"docker-V7-20201012","date":"2022-05-13T06:04:11.000Z","updated":"2022-05-14T04:19:37.663Z","comments":true,"path":"2022/05/13/docker-V7-20201012/","link":"","permalink":"https://chenxiao0629.github.io/2022/05/13/docker-V7-20201012/","excerpt":"","text":"第1章 Docker容器介绍1.docker是什么123Docker是Docker.Inc公司开源的一个基于LXC技术之上构建的Container容器引擎,源代码托管在 GitHub 上,基于Go语言并遵从Apache2.0协议开源。Docker是通过内核虚拟化技术（namespaces及cgroups等）来提供容器的资源隔离与安全保障等。由于Docker通过操作系统层的虚拟化实现隔离，所以Docker容器在运行时，不需要类似虚拟机（VM）额外的操作系统开销，提高资源利用率。 2.容器与虚拟机对比传统虚拟化和Docker分层对比: VM虚拟化和Docker特性对比 3.docker的三个重要概念Image(镜像): 1那么镜像到底是什么呢？Docker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 Container(容器): 1容器(Container)的定义和镜像(Image)几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 Repository(仓库): 123镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 Latest 作为默认标签。 镜像和容器图解: 4.docker的组成部分12345Docker是传统的CS架构分为docker client和docker serverDocker客户端是 Docker 用户与 Docker 交互的主要方式。当您使用 Docker 命令行运行命令时，Docker 客户端将这些命令发送给服务器端，服务端将执行这些命令。Docker 命令使用 Docker API 。Docker 客户端可以与多个服务端进行通信。 第2章 Docker安装部署1.国内源安装docker-ce这里我们使用清华源： 1https://mirrors.tuna.tsinghua.edu.cn/help/docker-ce/ 操作步骤： 1234567yum remove docker docker-common docker-selinux docker-engineyum install -y yum-utils device-mapper-persistent-data lvm2wget -O /etc/yum.repos.d/docker-ce.repo https://download.docker.com/linux/centos/docker-ce.reposed -i &#x27;s+download.docker.com+mirrors.tuna.tsinghua.edu.cn/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repoyum makecache fastyum install docker-cesystemctl start docker 2.国内远镜像加速配置12345678mkdir -p /etc/dockertee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://ig2l319y.mirror.aliyuncs.com&quot;]&#125;EOFsystemctl daemon-reloadsystemctl restart docker 3.运行第一个容器运行一个Hello world 1docker run alpine /bin/echo &quot;Hello world&quot; 第3章 Docker镜像和容器管理1.镜像相关命令1.1 搜索镜像选择镜像建议： 121.优先选择官方的2.选择星星多的 搜索命令： 1docker search centos 使用curl命令获取镜像版本号： 12yum install jqcurl -s https://registry.hub.docker.com/v1/repositories/centos/tags|jq|grep name 1.2 获取镜像123docker pull centosdocker pull busyboxdocker pull busybox:1.29 1.3 查看镜像1docker images 1.4 删除镜像1docker rmi centos 1.5 导出镜像12docker save -o centos.tar centos:latestdocker save &gt; centos.tar centos:latest 1.6 导入镜像12docker load -i centos.tardocker load &lt; centos.tar 2.容器相关命令2.1 启动容器12docker run -d -p 80:80 nginx docker run --name mydocker -t -i centos /bin/bash 2.2 停止容器1docker stop 2.3 查看容器1234docker ps docker ps -a docker ps -qdocker ps -aq 2.4 进入容器1234docker exec会分配一个新的终端ttydocker exec -it 容器ID /bin/bash docker attach会使用同一个终端docker attach 容器ID 2.5 删除容器删除单个容器 1docker rm 容器ID 批量删除容器 12docker stop $(docker ps -q)docker rm $(docker ps -aq) 第4章 Docker网络管理1.随机映射端口1docker run -P 2.指定映射端口-p 宿主机端口:容器端口 12-p 80:80 -p 443:443-p 宿主机IP:宿主机端口:容器端口 如果想多个容器使用8080端口，可以通过添加多个IP地址实现 123ifconfig eth0:1 10.0.0.13 updocker run -d -p 10.0.0.11:8080:80 nginx:latestdocker run -d -p 10.0.0.13:8080:80 nginx:latest 进入容器里修改站点目录，然后访问测试 1234docker exec -it bdb2a4e7e24d /bin/bashecho &quot;web01&quot; &gt; /usr/share/nginx/html/index.htmldocker exec -it 31c1de138dda /bin/bashecho &quot;web02&quot; &gt; /usr/share/nginx/html/index.html 访问测试： 1234[root@docker01 ~]# curl 10.0.0.11:8080web02[root@docker01 ~]# curl 10.0.0.13:8080web01 第5章 Docker数据目录管理1.映射容器目录1-v 宿主机目录:容器内目录 1.1 创建游戏代码目录123mkdir /data/xiaoniao -pcd /data/unzip xiaoniaofeifei.zip -d xiaoniao / 1.2 创建容器并映射数据目录12docker run -d -p 80:80 -v /data/xiaoniao:/usr/share/nginx/html nginx:latestdocker ps 1.3 访问游戏页面110.0.0.11 2.实验-访问不同端口展示不同页面需求： 12访问8080端口，展示xiaoniao首页访问8090端口，展示shenjingmao的首页 2.1 准备nginx配置文件123456789101112131415161718[root@docker01 ~]# cat /data/game.conf server &#123; listen 8080; server_name localhost; location / &#123; root /opt/game/; index index.html index.htm; &#125;&#125;server &#123; listen 8090; server_name localhost; location / &#123; root /opt/xiaoniao/; index index.html index.htm; &#125;&#125; 2.2 上传代码目录1234567[root@docker01 /data]# ll 总用量 18896drwxr-xr-x 5 root root 73 9月 7 23:03 game-rw-r--r-- 1 root root 309 9月 7 22:57 game.conf-rw-r--r-- 1 root root 19248295 8月 28 09:48 html5.zipdrwxr-xr-x 3 root root 92 9月 7 22:15 xiaoniao-rw-r--r-- 1 root root 91014 9月 7 22:11 xiaoniaofeifei.zip 2.3 创建容器并挂载需要挂载的内容： 121.nginx配置文件2.游戏目录 创建容器命令: 1234567docker run -p 8080:8080 \\-p 8090:8090 \\-v /data/game:/opt/game \\-v /data/xiaoniao:/opt/xiaoniao \\-v /data/game.conf:/etc/nginx/conf.d/game.conf \\-d nginx:latest 2.4 访问测试1210.0.0.11:808010.0.0.11:8090 第6章 Docker镜像手动构建1.手动制作游戏镜像1下面我们基于centos容器制作一个新镜像，并安装nginx服务 1.1 启动一个容器并安装nginx1234567891011121314151617181920[root@docker01 ~]# docker run -it centos /bin/bash[root@0ede2760ba65 /]# yum install wget install openssh-clients -y [root@0ede2760ba65 /]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo[root@0ede2760ba65 /]# wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo[root@0ede2760ba65 /]# sed -i -e &#x27;/mirrors.cloud.aliyuncs.com/d&#x27; -e &#x27;/mirrors.aliyuncs.com/d&#x27; /etc/yum.repos.d/CentOS-Base.repo[root@0ede2760ba65 /]# cat /etc/yum.repos.d/nginx.repo [nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.key[root@0ede2760ba65 /]# yum makecache fast[root@0ede2760ba65 /]# yum install nginx -y 1.2 上传代码目录并配置nginx配置文件123456789[root@0ede2760ba65 /]# scp -r 10.0.0.11:/data/* /opt/[root@0ede2760ba65 /]# ll /opt/total 18896drwxr-xr-x 5 root root 73 Sep 7 16:02 game-rw-r--r-- 1 root root 303 Sep 7 16:02 game.conf-rw-r--r-- 1 root root 19248295 Sep 7 16:02 html5.zipdrwxr-xr-x 3 root root 92 Sep 7 16:02 xiaoniao-rw-r--r-- 1 root root 91014 Sep 7 16:02 xiaoniaofeifei.zip[root@0ede2760ba65 /]# cp /opt/game.conf /etc/nginx/conf.d/ 1.3 将容器提交为新的镜像1234[root@docker01 ~]# docker ps -aq0ede2760ba65[root@docker01 ~]# docker commit 0ede2760ba65 game:v1sha256:a61d28fbfe27ebe36d4b73825b55e5f94097083273ab56dccce0453ce2bd6d38 1.4 测试镜像功能是否可用12[root@docker01 ~]# docker run -d -p 8080:8080 -p 8090:8090 game:v1 nginx -g &#x27;daemon off;&#x27;f58f209d4761c4bdd9bb164c0050a94a3273b1ee0e57eafe29e48b1517c72950 1.5 将新镜像导出1docker save -o game_v1.tar game:v1 2.手动制作云盘镜像2.1 创建容器1docker run -d -p 80:80 --name clould game:v1 nginx -g &#x27;daemon off;&#x27; 2.2 进入容器安装php并求改运行用户1234567891011121314151617[root@d0c987bcefa2 /]# yum install php-fpm -y[root@d0c987bcefa2 /]# php-fpm -vPHP 5.4.16 (fpm-fcgi) (built: Oct 30 2018 19:32:20)Copyright (c) 1997-2013 The PHP GroupZend Engine v2.4.0, Copyright (c) 1998-2013 Zend Technologies[root@d0c987bcefa2 /]# sed -i &#x27;/^user/c user = nginx&#x27; /etc/php-fpm.d/www.conf[root@d0c987bcefa2 /]# sed -i &#x27;/^group/c group = nginx&#x27; /etc/php-fpm.d/www.conf[root@d0c987bcefa2 /]# sed -i &#x27;/daemonize/s#no#yes#g&#x27; /etc/php-fpm.conf [root@d0c987bcefa2 /]# php-fpm -c /etc/php.ini -y /etc/php-fpm.conf[root@d0c987bcefa2 /]# php-fpm -c /etc/php.ini -y /etc/php-fpm.conf [root@d0c987bcefa2 /]# ps -ef|grep phproot 77 0 0 21:43 ? 00:00:00 php-fpm: master process (/etc/php-fpm.conf)nginx 78 77 0 21:43 ? 00:00:00 php-fpm: pool wwwnginx 79 77 0 21:43 ? 00:00:00 php-fpm: pool wwwnginx 80 77 0 21:43 ? 00:00:00 php-fpm: pool wwwnginx 81 77 0 21:43 ? 00:00:00 php-fpm: pool wwwnginx 82 77 0 21:43 ? 00:00:00 php-fpm: pool www 2.3 配置nginx12345678910111213141516171819[root@d0c987bcefa2 /]# cat /etc/nginx/conf.d/cloud.conf server &#123; listen 80; server_name localhost; root /code; index index.php index.html; location ~ \\.php$ &#123; root /code; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125;[root@d0c987bcefa2 /]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful[root@d0c987bcefa2 /]# nginx -s reload 2.4 下载代码目录123456[root@d0c987bcefa2 /]# mkdir /code[root@d0c987bcefa2 /]# cd /code/[root@d0c987bcefa2 code]# scp -r 10.0.0.11:/data/kod/* /code/[root@d0c987bcefa2 code]# lsChangeLog.md README.MD app config data index.php plugins static[root@d0c987bcefa2 code]# chown -R nginx:nginx /code/ 2.5 测试12345678910111213141516171819[root@d0c987bcefa2 code]# curl -I 127.0.0.1HTTP/1.1 302 Moved TemporarilyServer: nginx/1.16.1Date: Sat, 07 Sep 2019 21:53:17 GMTContent-Type: text/html; charset=utf-8Connection: keep-aliveX-Powered-By: PHP/5.4.16Set-Cookie: KOD_SESSION_ID_9d6d9=ljq63o0tmcscon6eb3gdpqscf4; path=/Set-Cookie: KOD_SESSION_ID_9d6d9=ljq63o0tmcscon6eb3gdpqscf4; path=/Set-Cookie: KOD_SESSION_ID_9d6d9=ljq63o0tmcscon6eb3gdpqscf4; path=/Set-Cookie: KOD_SESSION_SSO=bboh1p0h1uc50tfibrg67dnra7; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheSet-Cookie: KOD_SESSION_ID_9d6d9=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/Set-Cookie: kod_name=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMTSet-Cookie: kodToken=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMTSet-Cookie: X-CSRF-TOKEN=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMTLocation: ./index.php?user/login 2.6 提交新的镜像12[root@docker01 ~]# docker commit d0c987bcefa2 kod:v1sha256:169df6e8db11bd044e3e05237f2947783f9cc7a65b643dc9206ecf05fdc4a3ea 2.7 编写启动脚本并提交新镜像12345678[root@docker01 ~]# docker exec -it c14835183fb5 /bin/bash[root@c14835183fb5 /]# cat init.sh #!/bin/bashphp-fpm -c /etc/php.ini -y /etc/php-fpm.confnginx -g &#x27;daemon off;&#x27;[root@c14835183fb5 /]# chmod +x init.sh [root@docker01 ~]# docker commit c14835183fb5 kod:v2sha256:c05ebdf400aa7f7a27aa857df0d9c75c42943db89abca66f79101771db8e9585 2.8 启动测试123456[root@docker01 ~]# docker stop $(docker ps -qa)[root@docker01 ~]# docker run -d -p 80:80 kod:v2 /bin/bash /init.shdccf4aea5471713872e4fefaca45f7fac3bffec8f5f602570863ed14231dea1a[root@docker01 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESdccf4aea5471 kod:v2 &quot;/bin/bash /init.sh&quot; 36 seconds ago Up 35 seconds 0.0.0.0:80-&gt;80/tcp magical_napier 2.9 添加GD库1234此时打开页面提示缺少GD库，进入容器内安装php支持插件[root@dccf4aea5471 /] yum install php-mbstring php-gd -y然后重启容器[root@docker01 ~]# docker restart dccf4aea5471 2.10 访问测试没问题后提交新镜像 12[root@docker01 ~]# docker commit dccf4aea5471 kod:v2sha256:23051ce545a2eb6bb50bb2307bd9cfbaf6139e52f205a4126fb1d8d974c417f4 第7章 Dockerfile自动构建Docker镜像1.Dockerfile操作命令说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Docker通过对于在Dockerfile中的一系列指令的顺序解析实现自动的image的构建 通过使用build命令，根据Dockerfiel的描述来构建镜像 通过源代码路径的方式 通过标准输入流的方式Dockerfile指令： 只支持Docker自己定义的一套指令，不支持自定义 大小写不敏感，但是建议全部使用大写 根据Dockerfile的内容顺序执行FROM： FROM &#123;base镜像&#125; 必须放在DOckerfile的第一行，表示从哪个baseimage开始构建MAINTAINER： 可选的，用来标识image作者的地方RUN： 每一个RUN指令都会是在一个新的container里面运行，并提交为一个image作为下一个RUN的base 一个Dockerfile中可以包含多个RUN，按定义顺序执行 RUN支持两种运行方式： RUN &lt;cmd&gt; 这个会当作/bin/sh -c “cmd” 运行 RUN [“executable”，“arg1”，。。]，Docker把他当作json的顺序来解析，因此必须使用双引号，而且executable需要是完整路径 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN command1 的执行仅仅是当前进程，一个内存上的变化而已，其结果不会造成任何文件。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。而如果需要将两条命令或者多条命令联合起来执行需要加上&amp;&amp;。如：cd /usr/local/src &amp;&amp; wget xxxxxxxCMD： CMD的作用是作为执行container时候的默认行为（容器默认的启动命令） 当运行container的时候声明了command，则不再用image中的CMD默认所定义的命令 一个Dockerfile中只能有一个有效的CMD，当定义多个CMD的时候，只有最后一个才会起作用 CMD定义的三种方式： CMD &lt;cmd&gt; 这个会当作/bin/sh -c &quot;cmd&quot;来执行 CMD [&quot;executable&quot;,&quot;arg1&quot;,....] CMD [&quot;arg1&quot;,&quot;arg2&quot;]，这个时候CMD作为ENTRYPOINT的参数 EXPOSE 声明端口 格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]。 EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。ENTRYPOINT： entrypoint的作用是，把整个container变成了一个可执行的文件，这样不能够通过替换CMD的方法来改变创建container的方式。但是可以通过参数传递的方法影响到container内部 每个Dockerfile只能够包含一个entrypoint，多个entrypoint只有最后一个有效 当定义了entrypoint以后，CMD只能够作为参数进行传递entrypoint定义方式： entrypoint [&quot;executable&quot;,&quot;arg1&quot;,&quot;arg2&quot;]，这种定义方式下，CMD可以通过json的方式来定义entrypoint的参数，可以通过在运行container的时候通过指定command的方式传递参数 entrypoint &lt;cmd&gt;，当作/bin/bash -c &quot;cmd&quot;运行命令ADD &amp; COPY： 当在源代码构建的方式下，可以通过ADD和COPY的方式，把host上的文件或者目录复制到image中 ADD和COPY的源必须在context路径下 当src为网络URL的情况下，ADD指令可以把它下载到dest的指定位置，这个在任何build的方式下都可以work ADD相对COPY还有一个多的功能，能够进行自动解压压缩包ENV： ENV key value 用来设置环境变量，后续的RUN可以使用它所创建的环境变量 当创建基于该镜像的container的时候，会自动拥有设置的环境变量 WORKDIR： 用来指定当前工作目录（或者称为当前目录） 当使用相对目录的情况下，采用上一个WORKDIR指定的目录作为基准 USER： 指定UID或者username，来决定运行RUN指令的用户 ONBUILD： ONBUILD作为一个trigger的标记，可以用来trigger任何Dockerfile中的指令 可以定义多个ONBUILD指令 当下一个镜像B使用镜像A作为base的时候，在FROM A指令前，会先按照顺序执行在构建A时候定义的ONBUILD指令 ONBUILD &lt;DOCKERFILE 指令&gt; &lt;content&gt;VOLUME： 用来创建一个在image之外的mount point，用来在多个container之间实现数据共享 运行使用json array的方式定义多个volume VOLUME [&quot;/var/data1&quot;,&quot;/var/data2&quot;] 或者plain text的情况下定义多个VOLUME指令 2.使用Dockerfile创建云盘镜像12345678910111213141516171819202122232425262728#基于什么镜像FROM centos:7#添加软件源COPY conf/epel.repo /etc/yum.repos.d/epel.repoCOPY soft/nginx-1.18.0-1.el7.ngx.x86_64.rpm /tmp/ADD code/kod.tar.gz /code/kod/RUN groupadd -g 1000 www &amp;&amp; \\ useradd -u 1000 -g 1000 www &amp;&amp; \\ chown -R www:www /code/kod &amp;&amp; \\ yum install openssl php-fpm php-mbstring php-gd supervisor -y &amp;&amp; \\ rpm -ivh /tmp/nginx-1.18.0-1.el7.ngx.x86_64.rpm &amp;&amp; \\ rm -rf /tmp/nginx-1.18.0-1.el7.ngx.x86_64.rpm &amp;&amp; \\ yum clean all#拷贝配置文件COPY conf/nginx.conf /etc/nginx/nginx.confCOPY conf/kod.conf /etc/nginx/conf.d/kod.confCOPY conf/www.conf /etc/php-fpm.d/www.confCOPY conf/supervisord.conf /etc/supervisord.confCOPY conf/nginx_php.ini /etc/supervisord.d/nginx_php.ini#暴露端口EXPOSE 80#启动服务CMD [&quot;/usr/bin/supervisord&quot;,&quot;-c&quot;,&quot;/etc/supervisord.conf&quot;] 3.使用Dockerfile创建wordpress博客镜像1 4.使用Dockerfile创建KVM图形化管理工具镜像1 第8章 企业级私有仓库Docker-harbor1.部署步骤12345第一步：安装docker和docker-compose第二步：下载harbor-offline-installer-v1.9.0-rc1.tgz第三步：上传到/opt,并解压第四步：修改harbor.yml配置文件 hostname = 10.0.0.11 harbor_admin_password = 123456第五步：执行install.sh 2.安装docker-compose1.安装docker-compose 1yum install -y docker-compose 2.检查 1docker-compose version 3.上传解压docker-harbor1234567[root@docker01 ~]# cd /opt/[root@docker01 /opt]# lsharbor-offline-installer-v1.9.0-rc1.tgz[root@docker01 /opt]# tar zxf harbor-offline-installer-v1.9.0-rc1.tgz [root@docker01 /opt]# lsharbor harbor-offline-installer-v1.9.0-rc1.tgz[root@docker01 /opt]# cd harbor/ 4.修改配置文件修改2个地方： 123[root@docker01 /opt/harbor]# egrep &quot;10.0.0.11|123456&quot; harbor.yml hostname: 10.0.0.11harbor_admin_password: 123456 5.安装1[root@docker01 /opt/harbor]# ./install.sh 6.修改docker信任仓库12345[root@docker01 /opt/harbor]# cat /etc/docker/daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;], &quot;insecure-registries&quot;: [&quot;http://10.0.0.11&quot;] &#125; 7.重启docker1systemctl restart docker 8.给镜像打标签并提交到harbordocker登陆harbor 12345678[root@docker01 /opt/harbor]# docker login 10.0.0.11 Username: zhangya Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded 运行一个容器： 12[root@docker01 ~]# docker run -d -p 8080:80 centos_kod:v1 78be80f7c2029b68e8943e38fa99131ec6709f798e63c94afb5a7fdfa4a8047c 查看容器ID: 12[root@docker01 ~]# docker ps|grep kod78be80f7c202 centos_kod:v1 &quot;/bin/bash /init.sh&quot; 15 seconds ago Up 13 seconds 0.0.0.0:8080-&gt;80/tcp tender_dirac 将容器提交为新镜像并且更改为harbor仓库的地址 12[root@docker01 ~]# docker commit 78be80f7c202 10.0.0.11/linux/centos_kod:v1sha256:6bf1e1eef1969bcd4c82472aed945d4dda74a923c0d7dae91e38539676f8c240 查看镜像 123[root@docker01 ~/dockerfile/kod]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZE10.0.0.11/linux/centos_kod v1 6bf1e1eef196 13 minutes ago 465MB 将新镜像推送到harbor上 1[root@docker01 /opt/harbor]# docker push 10.0.0.11/linux/centos_kod:v1 9.在docker-harbor上查看12310.0.0.11账号:admin密码:123456 10.其他主机上下载镜像配置docker信任仓库 123456[root@docker02 ~]# cat /etc/docker/daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;], &quot;insecure-registries&quot;: [&quot;http://10.0.0.11&quot;], &quot;insecure-registries&quot;: [&quot;https://10.0.0.11&quot;] &#125; 从Harbor仓库拉取镜像 1[root@docker02 ~]# docker pull 10.0.0.11/linux/centos_kod:v1 第9章 Docker容器编排工具1.docker-compose介绍123Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过Compose，您可以使用YML文件来配置应用程序需要的所有服务。写好yaml文件之后，只需要运行一条命令，就会按照资源清单里的配置运行相应的容器服务。 Compose 使用的三个步骤： 1231.使用 Dockerfile 定义应用程序的环境。2.使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。3.最后，执行 docker-compose up 命令来启动并运行整个应用程序。 2.安装docker-compose方法1:直接yum安装 1yum install docker-compose 方法2:使用官方脚本安装 1curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 3.docker-compose语法介绍12345678910111213141516171819202122232425262728293031323334353637version: &#x27;2.2&#x27;services: 服务名称: image: 容器镜像 container_name: 容器名称 environment: - 环境变量1=值1 - 环境变量2=值2 volumes: - 存储驱动1:容器内的数据目录路径 - 宿主机目录路径:容器内的数据目录路径 ports: - 宿主机端口:映射到容器内的端口 networks: - 自定义网络的名称 服务名称: image: 容器镜像 container_name: 容器名称 environment: - 环境变量1=值1 - 环境变量2=值2 volumes: - 存储驱动2:对应容器内的数据目录路径 ports: - 宿主机端口:映射到容器内的端口 networks: - 自定义网络的名称volumes: 存储驱动1: driver: local 存储驱动2: driver: localnetworks: 自定义网络名称: driver: bridge 4.使用docker-compose部署zabbixdocker-run命令 12345678910111213141516171819202122232425262728docker run --name mysql-server -t \\ -e MYSQL_DATABASE=&quot;zabbix&quot; \\ -e MYSQL_USER=&quot;zabbix&quot; \\ -e MYSQL_PASSWORD=&quot;zabbix&quot; \\ -e MYSQL_ROOT_PASSWORD=&quot;zabbix&quot; \\ -d mysql:5.7 \\ --character-set-server=utf8 --collation-server=utf8_bin docker run --name zabbix-server-mysql -t \\ -e DB_SERVER_HOST=&quot;mysql-server&quot; \\ -e MYSQL_DATABASE=&quot;zabbix&quot; \\ -e MYSQL_USER=&quot;zabbix&quot; \\ -e MYSQL_PASSWORD=&quot;zabbix&quot; \\ -e MYSQL_ROOT_PASSWORD=&quot;zabbix&quot; \\ --link mysql-server:mysql \\ -p 10051:10051 \\ -d zabbix/zabbix-server-mysql:latestdocker run --name zabbix-web-nginx-mysql -t \\ -e DB_SERVER_HOST=&quot;mysql-server&quot; \\ -e MYSQL_DATABASE=&quot;zabbix&quot; \\ -e MYSQL_USER=&quot;zabbix&quot; \\ -e MYSQL_PASSWORD=&quot;zabbix&quot; \\ -e MYSQL_ROOT_PASSWORD=&quot;zabbix&quot; \\ --link mysql-server:mysql \\ --link zabbix-server-mysql:zabbix-server \\ -p 80:8080 \\ -d zabbix/zabbix-web-nginx-mysql:latest docker-compose 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849version: &#x27;2.2&#x27;services: mysql: image: mysql:5.7 container_name: mysql-server user: 2000:2000 environment: MYSQL_DATABASE: zabbix MYSQL_USER: zabbix MYSQL_PASSWORD: zabbix MYSQL_ROOT_PASSWORD: zabbix volumes: - /data/mysql:/var/lib/mysql command: --character-set-server=utf8 --collation-server=utf8_bin zabbix-server-mysql: image: zabbix/zabbix-server-mysql:latest container_name: zabbix-server-mysql environment: DB_SERVER_HOST: mysql-server MYSQL_DATABASE: zabbix MYSQL_USER: zabbix MYSQL_PASSWORD: zabbix MYSQL_ROOT_PASSWORD: zabbix ports: - 10051:10051 links: - mysql depends_on: - mysql zabbix-server-web: image: zabbix/zabbix-web-nginx-mysql:latest container_name: zabbix-web-nginx-mysql environment: DB_SERVER_HOST: mysql-server MYSQL_DATABASE: zabbix MYSQL_USER: zabbix MYSQL_PASSWORD: zabbix MYSQL_ROOT_PASSWORD: zabbix ports: - 80:8080 links: - mysql - zabbix-server-mysql depends_on: - zabbix-server-mysql 5.使用docker-compose部署jenkins+gitlab1 第10章 Docker网络模式1.Docker网络的四种模式1234Host 容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。Bridge 此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。None 此模式关闭了容器的网络功能。Container 创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。 查看网络模式命令: 12345[root@node-51 ~]# docker network lsNETWORK ID NAME DRIVER SCOPE3791e4fc9c18 bridge bridge localb494337929ef host host locala153ac0003e3 none null local 查看网卡命令: 1234567891011121314151617[root@node-51 ~]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:11:6b:18 brd ff:ff:ff:ff:ff:ff inet 10.0.0.51/24 brd 10.0.0.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:fe11:6b18/64 scope link valid_lft forever preferred_lft forever3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:bb:96:63:c7 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 查看桥接网卡命令 12yum install bridge-utils -ybrctl show 2.Bridge模式介绍1231.当Docker Daemon第一次启动时会创建一个虚拟的网桥，默认名称是Docker02.创建完后会给这个网桥分配一个子网,默认是172.17.0.1/163.由Docker创建的每一个容器,都会创建一个Veth设备对,其中一端关联到网桥上,另一端放在容器里映射为eth0,然后从网桥的地址段内给容器内的eth0分配一个IP地址,这样容器之间就可以互通了。 流程图: 第11章 Docker容器夸主机通信1.Docker跨主机网络类型1234567自带:macvlan第三方:flannelConsulcalico 2.macvlan模式2.1 创建网络12345docker network create -d macvlan \\--subnet 10.0.0.0/24 \\--gateway 10.0.0.2 \\-o parent=eth0 macvlan_1 2.2 启动容器docker01启动容器 1docker run -it --network macvlan_1 --ip 10.0.0.100 alpine docker02启动容器 1docker run -it --network macvlan_1 --ip 10.0.0.200 alpine 启动后互相ping发现可以正常通讯 12ping 10.0.0.100ping 10.0.0.200 3.跨主机通信-Consul实现3.1 Consul介绍12Consul是一个服务网格（微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控）解决方案，它是一个分布式的，高度可用的系统，而且开发使用都很简便。它提供了一个功能齐全的控制平面，主要特点是：服务发现、健康检查、键值存储、安全服务通信、多数据中心。 3.2 二进制安装步骤123456wget https://releases.hashicorp.com/consul/1.4.4/consul_1.4.4_linux_amd64.zip unzip consul_1.4.4_linux_amd64.zip mv consul /usr/bin/chmod +x /usr/bin/consulnohup consul agent -server -bootstrap -ui -data-dir /var/lib/consul -client=10.0.0.11 -bind=10.0.0.11 &amp;&gt;/var/log/consul.log &amp;tail -f /var/log/consul.log 3.3 修改docker01启动文件123[root@docker01 ~]# vim /lib/systemd/system/docker.service#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store consul://10.0.0.11:8500 --cluster-advertise 10.0.0.11:2375 3.4 重启docker0112systemctl daemon-reload systemctl restart docker.service 3.5 同样方法修改docker02的配置123[root@docker02 ~]# vim /lib/systemd/system/docker.service#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store consul://10.0.0.11:8500 --cluster-advertise 10.0.0.12:2375 3.6 重启docker212systemctl daemon-reload systemctl restart docker.service 3.7 在docker主机上创建overlay网络在docker1上创建网络，然后会自动同步到docker2上 1docker network create -d overlay overlay_net 3.8 分别在两个节点上创建容器docker1上运行命令 1docker run -it --net=overlay_net --name busybox01 busybox:latest docker2上运行命令 1docker run -it --net=overlay_net --name busybox02 busybox:latest 3.9 测试联通性12docker run -it --net=overlay_net --name busybox01 busybox:latest#ping 10.0.0.3 4.跨主机通信-flannel实现4.1 flannel介绍1Flannel是一种基于overlay网络的跨主机容器网络解决方案，即将TCP数据包封装在另一种网络包里面进行路由转发和通信，Flannel是CoreOS开发,专门用于docker多机互联的一个工具,让集群中的不同节点主机创建的容器都具有全集群唯一的虚拟ip地址 4.2 flannel通信原理流程图解 ![img](file:&#x2F;&#x2F;&#x2F;C:\\Users\\24090\\Documents\\Tencent Files\\2409012320\\Image\\Group2\\T8\\7X\\T87XK6WSY211$6M5&#96;%T2Y~A.png) 文字说明 123451.数据从源容器中发出后，经由所在主机的docker0虚拟网卡转发到flannel0虚拟网卡。2.源主机的flanneld服务将原本的数据内容UDP封装后根据自己的路由表投递给目的节点的flanneld服务，数据到达目标主机后被解包，然后直接进入目的节点的flannel0虚拟网卡，然后被转发到目的主机的docker0虚拟网卡，最后就像本机容器通信一样由docker0路由到达目标容器。 3.使每个结点上的容器分配的地址不冲突。Flannel通过Etcd分配了每个节点可用的IP地址段后，再修改Docker的启动参数。“--bip=X.X.X.X/X”这个参数，它限制了所在节点容器获得的IP范围。 4.3 实验环境1210.0.0.11 etcd,flannel,docker10.0.0.12 flannel,docker 4.2 安装配置etcd安装etc: 1yum install etcd -y 编辑配置文件: 1234567891011cat &gt; /etc/etcd/etcd.conf &lt;&lt; &#x27;EOF&#x27;# [member]ETCD_NAME=defaultETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;ETCD_LISTEN_CLIENT_URLS=&quot;http://10.0.0.11:2379,http://127.0.0.1:2379&quot;# #[cluster]ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;ETCD_ADVERTISE_CLIENT_URLS=&quot;http://10.0.0.11:2379&quot;EOF 启动etcd 12systemctl start etcdsystemctl enable etcd 测试etcd功能 123etcdctl -C http://10.0.0.11:2379 cluster-healthetcdctl -C http://10.0.0.11:2379 set /testdir/testkey &quot;Hello world&quot; etcdctl -C http://10.0.0.11:2379 get /testdir/testkey 防火墙 12iptables -A INPUT -p tcp -m tcp --dport 2379 -m state --state NEW,ESTABLISHED -j ACCEPTiptables -A INPUT -p tcp -m tcp --dport 2380 -m state --state NEW,ESTABLISHED -j ACCEPT 4.3 安装配置Flannel-两台机器都操作安装Flannel 1yum install flannel -y 配置Flannel 1234567891011121314cp /etc/sysconfig/flanneld /opt/flanneld.bakcat &gt; /etc/sysconfig/flanneld &lt;&lt; &#x27;EOF&#x27;# Flanneld configuration options # etcd url location. Point this to the server where etcd runsFLANNEL_ETCD_ENDPOINTS=&quot;http://10.0.0.11:2379&quot;# etcd config key. This is the configuration key that flannel queries# For address range assignmentFLANNEL_ETCD_PREFIX=&quot;/atomic.io/network&quot;# Any additional options that you want to pass#FLANNEL_OPTIONS=&quot;&quot;EOF 配置etcd数据库 1etcdctl mk /atomic.io/network/config &#x27;&#123; &quot;Network&quot;: &quot;192.168.10.0/16&quot; &#125;&#x27; 启动docker 12systemctl start flanneld.servicesystemctl enable flanneld.service 检查端口 1netstat -lntup|grep flannel 4.4 配置Docker关联Flannel网络配置好flannel之后，我们只需要重启docker即可，然后查看网卡会发现docker0变成了我们配置的flannel网段。 1systemctl restart docker 4.5 创建容器测试docker01创建容器: 1docker run -it busybox /bin/sh 查看IP地址: 123456789/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever17: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:c0:a8:3a:03 brd ff:ff:ff:ff:ff:ff inet 192.168.58.3/24 brd 192.168.58.255 scope global eth0 valid_lft forever preferred_lft forever Docker02创建容器: 1docker run -it busybox /bin/sh 查看IP地址: 123456789/ # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever13: eth0@if14: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1472 qdisc noqueue link/ether 02:42:c0:a8:48:02 brd ff:ff:ff:ff:ff:ff inet 192.168.72.2/24 brd 192.168.72.255 scope global eth0 valid_lft forever preferred_lft forever 测试容器间可否通讯: 12ping 192.168.72.2ping 192.168.58.3 4.6 网卡地址没变的处理方法修改docker配置文件: 1234567vim /usr/lib/systemd/system/docker.service.................EnvironmentFile=/run/flannel/dockerExecStart=/usr/bin/dockerd -H fd:// $DOCKER_NETWORK_OPTIONS.................systemctl daemon-reload systemctl restart docker 4.7 容器间网络不通的解决方法12iptables -P INPUT ACCEPTiptables -P FORWARD ACCEPT 第12章 Docker监控1.docker自带的监控命令123docker container ps :查看正在运行的容器docker container top :知道某个容器运行了哪些进程docker container stats :显示每个容器各种资源使用情况 2.cAdvisor+ prometheus+ grafana组件介绍2.1 cAdvisor介绍12341.cAdvisor是google开发的容器监控工具，cAdvisor会显示当前host的资源使用情况，包括CPU，内存，网络，文件系统。2.不过cAdvisor提供的操作界面略显简陋，而且需要在不同页面之间跳转，并且只能监控一个host，这不免让人质疑他的实用性，但cAdvisor有一个亮点是可以将监控到的数据导出给第三方工具，有这些工具进一步加工处理。3.所以我们可以把cAdvisor定位为一个监控数据收集器，收集和导出数据是他的强项，而非展示数据。cAdvisor支持很多第三方工具，其中就包含prometheus 2.2 prometheus1234Prometheus是一个非常优秀的监控工具。提供了监控数据搜集，存储，处理，可视化和告警一系列完整的解决方案。包含组件:Node Exporter :负责收集host硬件和操作系统数据，以容器的形式运行在所有host上cAdvisor :负责收集容器数据，以容器的形式运行在所有host上 2.3 grafana1grafana是一款支持多种数据源的图形展示工具 3.使用docker-compose部署3.1 地址规划1210.0.0.11 cAdvisor+ Node Exporter +prometheus+ grafana10.0.0.12 cAdvisor+ Node Exporter 3.2 编写prometheus配置文件12345678910111213141516171819202122cat &gt; prometheus.yml &lt;&lt; &#x27;EOF&#x27;scrape_configs:- job_name: cadvisor scrape_interval: 5s static_configs: - targets: - 10.0.0.11:8080 - 10.0.0.53:8080- job_name: prometheus scrape_interval: 5s static_configs: - targets: - 10.0.0.11:9090- job_name: node_exporter scrape_interval: 5s static_configs: - targets: - 10.0.0.11:9100 - 10.0.0.53:9100EOF 3.2 编写docker-compose文件docker01配置 1234567891011121314151617181920212223242526272829303132333435363738cat &gt;docker-compose.yml&lt;&lt;EOFversion: &#x27;3.2&#x27;services: prometheus: image: prom/prometheus:latest container_name: prometheus ports: - 9090:9090 command: - --config.file=/etc/prometheus/prometheus.yml volumes: - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro depends_on: - cadvisor node-exporter: image: prom/node-exporter:latest container_name: node_exporter ports: - 9100:9100 cadvisor: image: google/cadvisor:latest container_name: cadvisor ports: - 8080:8080 volumes: - /:/rootfs:ro - /var/run:/var/run:rw - /sys:/sys:ro - /var/lib/docker/:/var/lib/docker:ro grafana: image: grafana/grafana:latest container_name: grafana ports: - 3000:3000EOF docker02配置： 1234567891011121314151617181920cat &gt;docker-compose.yml&lt;&lt;EOFversion: &#x27;3.2&#x27;services: node-exporter: image: prom/node-exporter:latest container_name: node_exporter ports: - 9100:9100 cadvisor: image: google/cadvisor:latest container_name: cadvisor ports: - 8080:8080 volumes: - /:/rootfs:ro - /var/run:/var/run:rw - /sys:/sys:ro - /var/lib/docker/:/var/lib/docker:roEOF 运行命令： 1docker-compose -f docker-compose.yml up -d 4.web页面操作访问地址: 1210.0.0.11:3000admin admin 添加数据源： 123DataSourcesName:PrometheusURL:http://10.0.0.11:9090 下载监控面板文件: 1https://grafana.com/api/dashboards/10619/revisions/1/download 查看执行效果: 1 第13章 Docker持续集成持续部署1.部署流程部署流程： 1234561.下载代码2.编译镜像3.推送镜像4.停止正在运行的容器5.启动新容器6.清理jenkins主机上的镜像 回滚流程： 1231.选择需要回滚的版本2.停止正在运行的容器3.启动新容器 2.pipeline脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475pipeline&#123; agent any parameters &#123; gitParameter name: &#x27;git_version&#x27;, branchFilter: &#x27;origin/(.*)&#x27;, type: &#x27;PT_TAG&#x27;, defaultValue: &#x27;v1.0&#x27;, description: &#x27;发布新版本&#x27; choice(name: &#x27;base_image&#x27;, choices: [&#x27;nginx:1.16&#x27;,&#x27;nginx:1.17&#x27;],description: &#x27;请选择基础镜像版本&#x27;) choice(name: &#x27;deploy_env&#x27;, choices: [&#x27;deploy&#x27;,&#x27;rollback&#x27;],description: &#x27;deploy: 发布版本\\nrollback: 回滚版本&#x27;) &#125; stages&#123; stage(&quot;下载代码&quot;)&#123; steps&#123; checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$git_version&#x27;]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: &#x27;RelativeTargetDirectory&#x27;, relativeTargetDir: &#x27;game&#x27;]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &#x27;b8c1f793-47ed-4903-995d-2273673d8f87&#x27;, url: &#x27;git@10.0.0.200:dev/docker-pipeline.git&#x27;]]]) &#125; &#125; stage(&quot;编译镜像&quot;)&#123; when &#123; environment name: &#x27;deploy_env&#x27;, value: &#x27;deploy&#x27; &#125; steps&#123; writeFile file: &quot;Dockerfile&quot;, text: &quot;&quot;&quot;FROM 10.0.0.205/base_image/$&#123;params.base_image&#125;\\nADD game /usr/share/nginx/html/&quot;&quot;&quot; sh &quot;docker build -t 10.0.0.205/image/game:$&#123;params.git_version&#125; . &amp;&amp; docker push 10.0.0.205/image/game:$&#123;params.git_version&#125;&quot; &#125; &#125; stage(&quot;推送镜像&quot;)&#123; when &#123; environment name: &#x27;deploy_env&#x27;, value: &#x27;deploy&#x27; &#125; steps&#123; sh &quot;docker build -t 10.0.0.205/image/game:$&#123;params.git_version&#125; . &amp;&amp; docker push 10.0.0.205/image/game:$&#123;params.git_version&#125;&quot; &#125; &#125; stage(&quot;部署容器&quot;)&#123; when &#123; environment name: &#x27;deploy_env&#x27;, value: &#x27;deploy&#x27; &#125; steps&#123; sh &#x27;ssh 10.0.0.204 &quot;docker stop game &amp;&amp; docker rm game &amp;&amp; docker run --name game -p 80:80 -d 10.0.0.205/image/game:$&#123;git_version&#125; &amp;&amp; docker ps&quot;&#x27; &#125; &#125; stage(&quot;清理构建镜像&quot;)&#123; when &#123; environment name: &#x27;deploy_env&#x27;, value: &#x27;deploy&#x27; &#125; steps&#123; sh &quot;docker rmi 10.0.0.205/image/game:$&#123;params.git_version&#125;&quot; &#125; &#125; stage(&quot;回滚镜像&quot;)&#123; when &#123; environment name: &#x27;deploy_env&#x27;, value: &#x27;rollback&#x27; &#125; steps&#123; sh &#x27;ssh 10.0.0.204 &quot;docker stop game &amp;&amp; docker rm game &amp;&amp; docker run --name game -p 80:80 -d 10.0.0.205/image/game:$&#123;git_version&#125; &amp;&amp; docker ps&quot;&#x27; &#125; &#125; &#125;&#125; 第14章 Docker图形化-1.安装命令1docker run -d --name portainerUI -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer 2.访问web界面110.0.0.11:9000","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"12、购买服务器和服务器配置、项目上线架构流程图、安装（musql、redis、python3.8、uwsgi、nginx）、配置虚拟环境、上线前端、上线后端（配置dev、导出依赖、提交远程git仓库、服务端clone、安装依赖（虚拟环境也要安uwsgi）、uwsgi和nginx配置、数据库创建用户、启动uwsgi、重启nginx、静态样式收集与动静分离）、补充docker-compose一键部署","slug":"luffy_day12","date":"2021-07-28T06:04:12.000Z","updated":"2022-05-14T05:50:58.371Z","comments":true,"path":"2021/07/28/luffy_day12/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day12/","excerpt":"","text":"1 购买服务器和服务器配置12345678910111213141516171819202122232425262728293031323334353637# 阿里，华为，腾讯云服务器---》按量付费---》用多少花多少钱# 保证阿里云内要大于100块才能买，先用后付费# 项目上线，需要一台服务器---》买的云服务器---》centos7.9# 创建ecs---》按量付费---》选上海---》选2核4g---》装系统---》centos 7.9---》选硬盘ssd 20g---》分配公网ip(外网，大家都可以访问到)--》按使用量付费--》自定义密码--》# 远程连接 ssh -软件：xshell mac上没有 -finalshell：http://www.hostbuf.com/t/988.html -git---》右键打开bash，用它也可以连接# 全是linux命令 -ls ：查看当前目录下的文件和文件夹 -pwd：查看你所在路径 -root 权限最高，linux所有配置都是文件，一切皆文件 -删除文件：rm -rf /* 文件系统--》从 / 开始有很多文件夹 系统都进不了 # 远程连接 -ssh root@ip地址 连接方式 -软件自带的连接 # 阿里云机器 -python 2.7 自带 ---》所有linux，mac都自带2.x --》系统服务 基于python写的 -python 3.6.8 自带--》阿里云带的 -自己再装一个python 3.7 # 执行一些命令yum update -y # 更新软件 yum 安装软件命令 update更新 -y：yesyum -y groupinstall &quot;Development tools&quot; # 批量把开发用的软件都装上 git ...yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel psmisc libffi-devel -y # 依赖 --》python可能装不上yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel psmisc libffi-devel zlib* libffi-devel -y 1.1 项目上线架构流程图 2 安装mysql1234567891011121314151617181920212223#1 下载mysql57wget http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm# 2 安装mysql57yum -y install mysql57-community-release-el7-10.noarch.rpmyum install mysql-community-server --nogpgcheck# 3 启动mysql57并查看启动状态 systemctl start mysqld.service # 启动mysql服务systemctl status mysqld.service # 查看服务# 4 查看默认密码并登录grep &quot;password&quot; /var/log/mysqld.log#lpqv1uv)hE*Omysql -uroot -p# 5 修改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Cx123456?&#x27;;# 远程连接链不上去，在服务器本地连接可以了 3 安装redis(源码安装)1234567891011121314151617181920212223242526272829303132333435363738394041# 下载redis-5.0.5wget http://download.redis.io/releases/redis-5.0.5.tar.gz# 解压安装包tar -xf redis-5.0.5.tar.gz# 进入目标文件cd redis-5.0.5# 编译环境 src路径下就有可执行文件---》redis-server，redis-cli等。。。make # 复制环境到指定路径完成安装cp -r ~/redis-5.0.5 /usr/local/redis# 配置redis可以后台启动：修改下方内容vim /usr/local/redis/redis.confdaemonize yes# 完成配置修改&gt;: esc&gt;: :wq# 建立软连接 redis-server和redis-cli 是在/usr/local/redis/src/这个路径下，它不在环境变量中， 在任意路径敲redis-cli ---》软连接到/usr/bin/，这个路径在环境变量---》以后再任意路径敲redis-server都有响应ln -s /usr/local/redis/src/redis-server /usr/bin/redis-serverln -s /usr/local/redis/src/redis-cli /usr/bin/redis-cli# 后台运行rediscd /usr/local/redisredis-server ./redis.conf &amp;ctrl + c# 查看服务是否启动ps aux |grep redis# 测试redis环境redis-clictrl + c# 关闭redis服务&gt;: pkill -f redis -9 4 安装python3.8（源码安装）12345678910111213141516171819202122232425262728293031323334# 源码编译安装---》源码# 前往用户根目录&gt;: cd ~# 下载 # 服务器终端wget https://www.python.org/ftp/python/3.8.8/Python-3.8.8.tar.xzwget https://registry.npmmirror.com/-/binary/python/3.8.6/Python-3.8.6.tgz# 解压安装包tar -xf Python-3.8.6.tgz# 进入目标文件cd Python-3.8.6# 配置安装路径：/usr/local/python3# 把python3.8.8 编译安装到/usr/local/python38路径下&gt;: ./configure --prefix=/usr/local/python38# 编译并安装,如果报错，说明缺依赖yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel psmisc libffi-devel zlib* libffi-devel -ymake &amp;&amp; make install# 建立软连接：/usr/local/python38路径不在环境变量，终端命令 python3，pip3ln -s /usr/local/python38/bin/python3 /usr/bin/python3.8ln -s /usr/local/python38/bin/pip3 /usr/bin/pip3.8python 2.x python3 3.6python3.8 3.8# 删除安装包与文件：&gt;: rm -rf Python-3.8.8&gt;: rm -rf Python-3.8.8.tar.xz 5 安装uwsgi1234567# 测试阶段使用wsgiref，性能低，上线使用uwsgi性能高，它用c写的# 安装pip3.8 install uwsgi # bin路径下就会有uwsgi这个可执行文件，但是这个路径不在环境变量，换到其他路径找不到2）建立软连接ln -s /usr/local/python38/bin/uwsgi /usr/bin/uwsgi 6 配置虚拟环境12345678910111213141516171819202122232425262728293031323334353637383940414243444546471）安装依赖python3.8 -m pip install --upgrade pippython3.8 -m pip install --upgrade setuptoolspip3.8 install pbr&gt;: pip3.8 install virtualenv&gt;: pip3.8 install -U virtualenvwrapper -i https://pypi.douban.com/simple/ # virtualenvwrapper 没有workon这个快捷命令# 不使用虚拟环境了# 不使用workon快捷指令了https://www.cnblogs.com/liuqingzheng/p/9508851.html 2）建立虚拟环境软连接&gt;: ln -s /usr/local/python38/bin/virtualenv /usr/bin/virtualenv3）配置虚拟环境：填入下方内容&gt;: vim ~/.bash_profileVIRTUALENVWRAPPER_PYTHON=/usr/bin/python3.8source /usr/local/python38/bin/virtualenvwrapper.sh4）退出编辑状态&gt;: esc5）保存修改并退出&gt;: :wq6）更新配置文件内容&gt;: source ~/.bash_profile7）虚拟环境默认根目录：~/.virtualenvs8 ）创建虚拟环境mkvirtualenv -p python3.8 luffy# 不使用virtualenvwrapper创建和使用虚拟环境用户家路径：mkdir virtualcd virtualln -s /usr/local/python38/bin/virtualenv /usr/bin/virtualenvvirtualenv luffy# 进入到虚拟环境source /root/virtual/luffy/bin/activate# 退出deactivate# 虚拟环境也要装uwsgi 7 安装nginx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 前往用户根目录&gt;: cd ~# 下载nginx1.13.7wget http://nginx.org/download/nginx-1.13.7.tar.gz# 解压安装包tar -xf nginx-1.13.7.tar.gz# 进入目标文件cd nginx-1.13.7# 配置安装路径：/usr/local/nginx./configure --prefix=/usr/local/nginx# 编译并安装make &amp;&amp; sudo make install# 建立软连接：终端命令 nginxln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx# 删除安装包与文件：&gt;: cd ~&gt;: rm -rf nginx-1.13.7&gt;: rm -rf nginx-1.13.7.tar.xz9）测试Nginx环境，服务器运行nginx，本地访问服务器ip&gt;: nginx&gt;: 服务器绑定的域名 或 ip:80 1）启动&gt;: nginx2）关闭nginx&gt;: nginx -s stop3）重启nginx&gt;: nginx -s reload4）查看端口，强行关闭&gt;: ps -aux|grep nginx&gt;: kill &lt;pid:进程编号&gt; # 注意：跑在80端口上可以访问，默认阿里云把80端口的安全组开放了，如果跑在8080上，需要开安全组 8 上线前端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 把vue项目编译成纯的 html css js# 修改后端地址base_url: &quot;http://101.132.238.3:8080/api/v1/&quot; # npm run build 在项目路径下建dist文件夹，下面放着纯静态文件(html,css,js)# 把dist文件夹压缩，传到服务器上去，使用ngixn搭理# 从远端想服务器传文件，需要在服务器安装软件yum install -y lrzsz# 服务端要解压zipyum install -y unzip# 移动到某个路径mkdir /home/htmlmv ~/dist /home/html# 修改nginx 的配置去向Nginx配置目录，备份配置，完全更新配置：填入下方内容&gt;: cd /usr/local/nginx/conf&gt;: mv nginx.conf nginx.conf.bak&gt;: vim nginx.conf&gt;: ievents &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; server &#123; listen 80; server_name 127.0.0.1; charset utf-8; location / &#123; root /home/html/dist; index index.html; try_files $uri $uri/ /index.html; # 解决单页面应用刷新404问题 &#125; &#125;&#125; 5）退出&gt;: esc&gt;: :wq6）重启nginx&gt;: nginx -s reload # 访问：http://101.132.238.3/ 9 上线后端9.1 上线前配置dev.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250import osimport sysBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# print(BASE_DIR) # /Users/liuqingzheng/luffy_api/luffy_api# 把apps的路径加入到环境变量了sys.path.append(os.path.join(BASE_DIR, &#x27;apps&#x27;))# 把 小luffy_api也就是BASE_DIR 也加入到环境变量sys.path.append(BASE_DIR)# print(sys.path)SECRET_KEY = &#x27;)xdu2e@a(^1p5ohypkgtft19v*5slt(-m_$gd_o637%^a3f^m(&#x27;DEBUG = False# 服务端地址 ，* 表示任意地址都可以ALLOWED_HOSTS = [&#x27;*&#x27;]INSTALLED_APPS = [ &#x27;simpleui&#x27;, &#x27;django.contrib.admin&#x27;, &#x27;django.contrib.auth&#x27;, &#x27;django.contrib.contenttypes&#x27;, &#x27;django.contrib.sessions&#x27;, &#x27;django.contrib.messages&#x27;, &#x27;django.contrib.staticfiles&#x27;, &#x27;rest_framework&#x27;, &#x27;corsheaders&#x27;, # &#x27;luffy_api.apps.user&#x27; # 太长，我们不喜欢 &#x27;user&#x27;, &#x27;home&#x27;, &#x27;course&#x27;, &#x27;django_filters&#x27;, &#x27;order&#x27;,]MIDDLEWARE = [ &#x27;django.middleware.security.SecurityMiddleware&#x27;, &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, &#x27;django.middleware.common.CommonMiddleware&#x27;, &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;, &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;, &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;, &#x27;corsheaders.middleware.CorsMiddleware&#x27;,]ROOT_URLCONF = &#x27;luffy_api.urls&#x27;TEMPLATES = [ &#123; &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;, &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)] , &#x27;APP_DIRS&#x27;: True, &#x27;OPTIONS&#x27;: &#123; &#x27;context_processors&#x27;: [ &#x27;django.template.context_processors.debug&#x27;, &#x27;django.template.context_processors.request&#x27;, &#x27;django.contrib.auth.context_processors.auth&#x27;, &#x27;django.contrib.messages.context_processors.messages&#x27;, ], &#125;, &#125;,]WSGI_APPLICATION = &#x27;luffy_api.wsgi.application&#x27;# Database# https://docs.djangoproject.com/en/2.2/ref/settings/#databases# 在这，用户名和密码都能看到---》万一你的代码泄露了---》数据库的用户名密码就泄露了--》不安全# django---》监控公司代码是否被传到github，gitee--》# B站的go源代码泄露----&gt;某个人传到了github# 拖库---》华住汉庭酒店---》20g开房数据泄露# 把密码不写死在源文件中，而从环境变量中取pwd = os.environ.get(&quot;PASSWORD&quot;, &quot;Luffy123?&quot;)# # 单独有接口，向接口发送请求，获取到密码---》自己做的# pwd=requests.get().json()[&#x27;password&#x27;]# # 配置中心 Apollo--公司自己搭建的DATABASES = &#123; # &#x27;default&#x27;: &#123; # &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;, # &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;), # &#125; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;luffy&#x27;, # 数据库名字 &#x27;USER&#x27;: &#x27;lqz&#x27;, # 用户名 &#x27;PASSWORD&#x27;: pwd, &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;, &#x27;PORT&#x27;: 3306 &#125;&#125;# 这两句话，只要执行即可，放在那里都行---》只要django执行，所有py文件中顶格写的代码都会执行# 作用是？猴子补丁，动态替换 ---&gt;python一切皆对象，可以动态替换对象# 如果该源码，后期只要使用django，都要改它的源码# 所以咱们换另一个操作mysql的模块，mysqlclient# import pymysql# pymysql.install_as_MySQLdb()AUTH_PASSWORD_VALIDATORS = [ &#123; &#x27;NAME&#x27;: &#x27;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&#x27;, &#125;, &#123; &#x27;NAME&#x27;: &#x27;django.contrib.auth.password_validation.MinimumLengthValidator&#x27;, &#125;, &#123; &#x27;NAME&#x27;: &#x27;django.contrib.auth.password_validation.CommonPasswordValidator&#x27;, &#125;, &#123; &#x27;NAME&#x27;: &#x27;django.contrib.auth.password_validation.NumericPasswordValidator&#x27;, &#125;,]# Internationalization# https://docs.djangoproject.com/en/2.2/topics/i18n/LANGUAGE_CODE = &#x27;zh-hans&#x27;TIME_ZONE = &#x27;Asia/Shanghai&#x27;USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/2.2/howto/static-files/STATIC_URL = &#x27;/static/&#x27;# # 日志相关LOGGING = &#123; &#x27;version&#x27;: 1, &#x27;disable_existing_loggers&#x27;: False, &#x27;formatters&#x27;: &#123; &#x27;verbose&#x27;: &#123; &#x27;format&#x27;: &#x27;%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s&#x27; &#125;, &#x27;simple&#x27;: &#123; &#x27;format&#x27;: &#x27;%(levelname)s %(module)s %(lineno)d %(message)s&#x27; &#125;, &#125;, &#x27;filters&#x27;: &#123; &#x27;require_debug_true&#x27;: &#123; &#x27;()&#x27;: &#x27;django.utils.log.RequireDebugTrue&#x27;, &#125;, &#125;, &#x27;handlers&#x27;: &#123; &#x27;console&#x27;: &#123; # 实际开发建议使用WARNING &#x27;level&#x27;: &#x27;DEBUG&#x27;, &#x27;filters&#x27;: [&#x27;require_debug_true&#x27;], &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;, &#x27;formatter&#x27;: &#x27;simple&#x27; &#125;, &#x27;file&#x27;: &#123; # 实际开发建议使用ERROR &#x27;level&#x27;: &#x27;INFO&#x27;, &#x27;class&#x27;: &#x27;logging.handlers.RotatingFileHandler&#x27;, # 日志位置,日志文件名,日志保存目录必须手动创建，注：这里的文件路径要注意BASE_DIR代表的是小luffyapi &#x27;filename&#x27;: os.path.join(os.path.dirname(BASE_DIR), &quot;logs&quot;, &quot;luffy.log&quot;), # 日志文件的最大值,这里我们设置300M &#x27;maxBytes&#x27;: 300 * 1024 * 1024, # 日志文件的数量,设置最大日志数量为10 &#x27;backupCount&#x27;: 10, # 日志格式:详细格式 &#x27;formatter&#x27;: &#x27;verbose&#x27;, # 文件内容编码 &#x27;encoding&#x27;: &#x27;utf-8&#x27; &#125;, &#125;, # 日志对象 &#x27;loggers&#x27;: &#123; &#x27;django&#x27;: &#123; &#x27;handlers&#x27;: [&#x27;console&#x27;, &#x27;file&#x27;], &#x27;propagate&#x27;: True, # 是否让日志信息继续冒泡给其他的日志处理系统 &#125;, &#125;&#125;REST_FRAMEWORK = &#123; &#x27;EXCEPTION_HANDLER&#x27;: &#x27;utils.exception.common_exception_handler&#x27; # 再出异常，会执行这个函数&#125;# 把扩写了auth的user表注册一下AUTH_USER_MODEL = &#x27;user.user&#x27;# 配置media文件夹MEDIA_URL = &#x27;/media/&#x27;MEDIA_ROOT = os.path.join(BASE_DIR, &#x27;media&#x27;)# 跨域问题处理# 允许简单请求，所有地址 相当于CORS_ORIGIN_ALLOW_ALL=&quot;*&quot;CORS_ALLOW_ALL_ORIGINS = True# 运行的请求CORS_ALLOW_METHODS = ( &#x27;DELETE&#x27;, &#x27;GET&#x27;, &#x27;OPTIONS&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;,)# 允许的请求头CORS_ALLOW_HEADERS = ( &#x27;accept-encoding&#x27;, &#x27;authorization&#x27;, # jwt &#x27;content-type&#x27;, # json &#x27;origin&#x27;, &#x27;user-agent&#x27;, &#x27;Pragma&#x27;,)# 导入用户自定义的配置from .user_settings import *import datetimeJWT_AUTH = &#123; # 过期时间1天 &#x27;JWT_EXPIRATION_DELTA&#x27;: datetime.timedelta(days=7),&#125;# redis的配置CACHES = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379&quot;, &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, &quot;CONNECTION_POOL_KWARGS&quot;: &#123;&quot;max_connections&quot;: 100&#125; # &quot;PASSWORD&quot;: &quot;123&quot;, &#125; &#125;, &quot;db1&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379&quot;, &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, &quot;CONNECTION_POOL_KWARGS&quot;: &#123;&quot;max_connections&quot;: 100&#125; # &quot;PASSWORD&quot;: &quot;123&quot;, &#125; &#125;&#125; user_settings.py 1234567891011121314# 用户自己的配置，单独放到另一个py文件中BANNER_COUNT=4# 用户自己别的配置# 上线后必须换成公网地址# 后台基URLBASE_URL = &#x27;http://101.132.238.3:8080&#x27;# 前台基URLLUFFY_URL = &#x27;http://101.132.238.3&#x27;# 支付宝同步异步回调接口配置# 后台post异步回调接口NOTIFY_URL = BASE_URL + &quot;/api/v1/order/success/&quot;# 前台同步回调接口，没有 / 结尾RETURN_URL = LUFFY_URL + &quot;/pay/success&quot; 复制一份manage_pro.py，配置文件改成luffy_api.setting.pro 9.2 导出项目环境1pip freeze &gt; requirements.txt 9.3 项目提交到远程git仓库123git add .git commit -m &#x27;v1版本发布了&#x27;git push origin master 9.4 服务端下载后端1234567# 创建存放后台项目的目录# mkdir /home/project# 进入后台项目管理目录同步git仓库中的项目&gt;: cd /home/project&gt;: git clone https://gitee.com/liuqingzheng/luffy_api.git 9.5 虚拟环境安装依赖123456789workon luffypip install -r requirements.txt # 很有可能模块装不上，相应的解决# 先把mysqlclient注释掉yum install mysql-develyum install python-develrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022pip install mysqlclient 9.6 uwsgi与nginx后台项目配置123456789101112131415161718192021222324252627282930313233343536373839# 编写uwsgi的配置文件，让uwsgi启动django# 创建luffyapi.xmlvim luffyapi.xml&lt;uwsgi&gt; &lt;socket&gt;127.0.0.1:8888&lt;/socket&gt; &lt;chdir&gt;/home/project/luffy_api1/&lt;/chdir&gt; &lt;module&gt;luffy_api1.wsgi&lt;/module&gt; &lt;processes&gt;4&lt;/processes&gt; &lt;daemonize&gt;uwsgi.log&lt;/daemonize&gt;&lt;/uwsgi&gt;[uwsgi]socket = 0.0.0.0:8888chdir = /home/project/luffy_api/wsgi-file = luffy_api/wsgi.pymodule = luffy_api.wsgiprocesses = 4daemonize = uwsgi.log# 配置nginx转发# 新增的server server &#123; listen 8080; server_name 127.0.0.1; charset utf-8; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8888; uwsgi_param UWSGI_SCRIPT luffy_api1.wsgi; uwsgi_param UWSGI_CHDIR /home/project/luffy_api1/; &#125; &#125; # 正常nginx 是转发http请求，但是咱们现在uwsgi启动是以socket启动的，所以uwsgi只能接收uwsgi协议的请求，不能接收http请求，所以nginx中这样配置，把本来http的请求通过nginx转成uwsgi_params---》转发给uwsgi # 重启nginxnginx -s reload 9.7 数据库创建用户12345678910111213# 进入数据库mysql -uroot -pLqz123456?# 创建数据库create database luffy default charset=utf8;# 设置权限账号密码：账号密码要与项目中配置的一致grant all privileges on luffy.* to &#x27;lqz&#x27;@&#x27;%&#x27; identified by &#x27;Luffy123?&#x27;;grant all privileges on luffy.* to &#x27;lqz&#x27;@&#x27;localhost&#x27; identified by &#x27;Luffy123?&#x27;;flush privileges;# 退出mysql&gt;: quit; 9.8 项目的数据库迁移12345678910# 只有库，没有表，迁移数据# 必须在luffy环境下# 数据库迁移cd /home/project/luffy_api/python manage_pro.py migrate# 导入测试数据---》正式库不这样做把原来本地的数据，导入到正式库中 9.9 启动uwsgi，重启nginx虚拟环境也要装uwsgi，正式环境也要装1234567891011#######虚拟环境也要装uwsgi，正式环境也要装# 启动uwsgiuwsgi -x ./luffyapi.xml# pkill -9 uwsgi# 重启nginx&gt;: nginx -s reload # 还要启动celery的beat和work 9.10静态样式收集动静分离123456789101112131415161718192021222324# 项目目录下没有 static 文件夹需要新建mkdir /home/project/luffy_api/luffy_api/static# 配置文件修改# 修改static配置，新增STATIC_ROOT、STATICFILES_DIRSSTATIC_URL = &#x27;/static/&#x27;STATIC_ROOT = &#x27;/home/project/luffy_api/luffy_api/static&#x27; STATICFILES_DIRS = (os.path.join(BASE_DIR, &quot;static&quot;),)# 完成静态文件迁移python /home/project/luffy_api/manage_pro.py collectstatic# nginx 做动静分离# 新增的配置静态文件location /static &#123; alias /home/project/luffy_api/luffy_api/static; &#125;location /media &#123; alias /home/project/luffy_api/luffy_api/media; &#125;# 重启nginx 补充 docker-compose一键部署123456789# mysql，redis，python，ngixn，部署前端，部署后端# 每次都要这么做# 只要配置完以后，以后换了任何机器都可以直接运行# python版本，第三方模块问题# 统一环境：本地啥样，到服务器就啥样---》docker--》容器技术# docker：统一环境，资源隔离# docker-compose：单机容器编排# docker-compose up -前端已经编译完成---》老的项目在我这编译不了---》node版本很高---》视频播放器报错--》最新代码试---》 1# 笔记：https://gitee.com/liuqingzheng/luffy","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"11、课程详情页前端（vue-core-video-player的使用）、课程详情接口、课程章节接口、搜索功能接口、搜索功能前端、支付宝支付（介绍、二次封装）、视频托管（七牛云文件上传）、支付接口、支付前端、支付成功回调接口、内网穿透","slug":"luffy_day11","date":"2021-07-28T06:04:11.000Z","updated":"2022-05-14T05:33:28.609Z","comments":true,"path":"2021/07/28/luffy_day11/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day11/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031323334# 课程列表页前端 -router 下的 index.js中 &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: HomeView &#125; -前端路由跳转 -js this.$router.push(&#x27;/地址&#x27;) -html: &lt;router-link to=&#x27;/地址&#x27;&gt;&lt;/router-link&gt; # 课程相关表分析 -课程分类 -课程表(实战课，免费课，轻课) -章节表 -课时表 -老师表# 课程分类接口 -继承GenericViewSet, ListModelMixin，写两个类属性 -自动生成路由 # 所有课程接口 -继承GenericViewSet, ListModelMixin，写两个类属性 -自动生成路由 -排序 -分页 -按课程分类过滤 ?course_category=1 不能使用内置的，要使用 django-filter -重点：序列化类 -表自己的字段 -choice的字段要显示中文，在表模型中加方法 返回中文 -老师：子序列化 -最多四个课时：表模型中写的逻辑 1 课程详情页前端1234# 课程详情页前端---》播放视频---》vue-video-player(很久没更新了)---》node版本高--》可能用不了# vue-video-player封装了video.js库# vue-core-video-player-基于vue.js的视频播放器组件---》非常简单易用 1.1 vue-core-video-player的使用123456789101112131415161718# 第一步：安装 npm install --save vue-core-video-player # 第二步：main.js 引入import VueCoreVideoPlayer from &#x27;vue-core-video-player&#x27;Vue.use(VueCoreVideoPlayer) # 默认是英文的# 第二步(补充)国际化Vue.use(VueCoreVideoPlayer, &#123; lang: &#x27;zh-CN&#x27;&#125;)# 第三步：在组件的html中使用&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;player-container&quot;&gt; &lt;vue-core-video-player src=&quot;http://img.ksbbs.com/asset/Mon_1703/05cacb4e02f9d9e.mp4&quot;&gt;&lt;/vue-core-video-player&gt; &lt;/div&gt;&lt;/div&gt;# https://www.cnblogs.com/liuqingzheng/p/16204851.html# https://github.com/core-player/vue-core-video-player-examples 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580&lt;template&gt; &lt;div class=&quot;detail&quot;&gt; &lt;Header/&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;course-info&quot;&gt; &lt;div class=&quot;wrap-left&quot;&gt; &lt;vue-core-video-player :src=&quot;mp4_url&quot; controls=&quot;auto&quot; autoplay :muted=&quot;true&quot; title=&quot;致命诱惑&quot; @play=&quot;playFunc&quot; @pause=&quot;pauseFunc&quot; &gt;&lt;/vue-core-video-player&gt; &lt;/div&gt; &lt;div class=&quot;wrap-right&quot;&gt; &lt;h3 class=&quot;course-name&quot;&gt;&#123;&#123;course_info.name&#125;&#125;&lt;/h3&gt; &lt;p class=&quot;data&quot;&gt;&#123;&#123;course_info.students&#125;&#125;人在学&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;课程总时长：&#123;&#123;course_info.sections&#125;&#125;课时/&#123;&#123;course_info.pub_sections&#125;&#125;小时&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;难度：&#123;&#123;course_info.level_name&#125;&#125;&lt;/p&gt; &lt;div class=&quot;sale-time&quot;&gt; &lt;p class=&quot;sale-type&quot;&gt;价格 &lt;span class=&quot;original_price&quot;&gt;¥&#123;&#123;course_info.price&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;expire&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;buy&quot;&gt; &lt;div class=&quot;buy-btn&quot;&gt; &lt;button class=&quot;buy-now&quot;&gt;立即购买&lt;/button&gt; &lt;button class=&quot;free&quot;&gt;免费试学&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;add-cart&quot; @click=&quot;add_cart(course_info.id)&quot;&gt; &lt;img src=&quot;@/assets/img/cart-yellow.svg&quot; alt=&quot;&quot;&gt;加入购物车 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;course-tab&quot;&gt; &lt;ul class=&quot;tab-list&quot;&gt; &lt;li :class=&quot;tabIndex==1?&#x27;active&#x27;:&#x27;&#x27;&quot; @click=&quot;tabIndex=1&quot;&gt;详情介绍&lt;/li&gt; &lt;li :class=&quot;tabIndex==2?&#x27;active&#x27;:&#x27;&#x27;&quot; @click=&quot;tabIndex=2&quot;&gt;课程章节 &lt;span :class=&quot;tabIndex!=2?&#x27;free&#x27;:&#x27;&#x27;&quot;&gt;(试学)&lt;/span&gt; &lt;/li&gt; &lt;li :class=&quot;tabIndex==3?&#x27;active&#x27;:&#x27;&#x27;&quot; @click=&quot;tabIndex=3&quot;&gt;用户评论&lt;/li&gt; &lt;li :class=&quot;tabIndex==4?&#x27;active&#x27;:&#x27;&#x27;&quot; @click=&quot;tabIndex=4&quot;&gt;常见问题&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;course-content&quot;&gt; &lt;div class=&quot;course-tab-list&quot;&gt; &lt;div class=&quot;tab-item&quot; v-if=&quot;tabIndex==1&quot;&gt; &lt;div class=&quot;course-brief&quot; v-html=&quot;course_info.brief&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tab-item&quot; v-if=&quot;tabIndex==2&quot;&gt; &lt;div class=&quot;tab-item-title&quot;&gt; &lt;p class=&quot;chapter&quot;&gt;课程章节&lt;/p&gt; &lt;p class=&quot;chapter-length&quot;&gt;共&#123;&#123;course_chapters.length&#125;&#125;章 &#123;&#123;course_info.sections&#125;&#125;个课时&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;chapter-item&quot; v-for=&quot;chapter in course_chapters&quot; :key=&quot;chapter.name&quot;&gt; &lt;p class=&quot;chapter-title&quot;&gt;&lt;img src=&quot;@/assets/img/enum.svg&quot; alt=&quot;&quot;&gt;第&#123;&#123;chapter.chapter&#125;&#125;章·&#123;&#123;chapter.name&#125;&#125; &lt;/p&gt; &lt;ul class=&quot;section-list&quot;&gt; &lt;li class=&quot;section-item&quot; v-for=&quot;section in chapter.coursesections&quot; :key=&quot;section.name&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;span class=&quot;index&quot;&gt;&#123;&#123;chapter.chapter&#125;&#125;-&#123;&#123;section.orders&#125;&#125;&lt;/span&gt; &#123;&#123;section.name&#125;&#125;&lt;span class=&quot;free&quot; v-if=&quot;section.free_trail&quot;&gt;免费&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;time&quot;&gt;&#123;&#123;section.duration&#125;&#125; &lt;img src=&quot;@/assets/img/chapter-player.svg&quot;&gt;&lt;/p&gt; &lt;button class=&quot;try&quot; v-if=&quot;section.free_trail&quot;&gt;立即试学&lt;/button&gt; &lt;button class=&quot;try&quot; v-else&gt;立即购买&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;tab-item&quot; v-if=&quot;tabIndex==3&quot;&gt; 用户评论 &lt;/div&gt; &lt;div class=&quot;tab-item&quot; v-if=&quot;tabIndex==4&quot;&gt; 常见问题 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;course-side&quot;&gt; &lt;div class=&quot;teacher-info&quot;&gt; &lt;h4 class=&quot;side-title&quot;&gt;&lt;span&gt;授课老师&lt;/span&gt;&lt;/h4&gt; &lt;div class=&quot;teacher-content&quot;&gt; &lt;div class=&quot;cont1&quot;&gt; &lt;img :src=&quot;course_info.teacher.image&quot;&gt; &lt;div class=&quot;name&quot;&gt; &lt;p class=&quot;teacher-name&quot;&gt;&#123;&#123;course_info.teacher.name&#125;&#125; &#123;&#123;course_info.teacher.title&#125;&#125;&lt;/p&gt; &lt;p class=&quot;teacher-title&quot;&gt;&#123;&#123;course_info.teacher.signature&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;p class=&quot;narrative&quot;&gt;&#123;&#123;course_info.teacher.brief&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;Footer/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Header from &quot;@/components/Header&quot; import Footer from &quot;@/components/Footer&quot; export default &#123; name: &quot;Detail&quot;, data() &#123; return &#123; tabIndex: 2, // 当前选项卡显示的下标 course_id: 0, // 当前课程信息的ID course_info: &#123; teacher: &#123;&#125;, &#125;, // 课程信息 course_chapters: [], // 课程的章节课时列表 // mp4_url:&#x27;http://img.ksbbs.com/asset/Mon_1703/05cacb4e02f9d9e.mp4&#x27;, mp4_url: [ &#123; src: &#x27;http://rb1x3v1fm.sabkt.gdipper.com/%E8%87%B4%E5%91%BD%E8%AF%B1%E6%83%91320p.mp4&#x27;, resolution: 360, &#125;, &#123; src: &#x27;http://rb1x3v1fm.sabkt.gdipper.com/%E8%87%B4%E5%91%BD%E8%AF%B1%E6%83%91720p.mp4&#x27;, resolution: 720, &#125;, &#123; src: &#x27;http://rb1x3v1fm.sabkt.gdipper.com/%E8%87%B4%E5%91%BD%E8%AF%B1%E6%83%914k.mp4&#x27;, resolution: &#x27;4k&#x27;, &#125;], &#125; &#125;, created() &#123; this.get_course_id(); this.get_course_data(); this.get_chapter(); &#125;, methods: &#123; playFunc()&#123; console.log(&#x27;开始了&#x27;) &#125;, pauseFunc()&#123; console.log(&#x27;暂停了&#x27;) &#125;, get_course_id() &#123; // 获取地址栏上面的课程ID this.course_id = this.$route.params.pk if (this.course_id &lt; 1) &#123; let _this = this; _this.$alert(&quot;对不起，当前视频不存在！&quot;, &quot;警告&quot;, &#123; callback() &#123; _this.$router.go(-1); &#125; &#125;); &#125; &#125;, get_course_data() &#123; // ajax请求课程信息 this.$axios.get(`$&#123;this.$settings.base_url&#125;course/actual/$&#123;this.course_id&#125;/`).then(response =&gt; &#123; // window.console.log(response.data); this.course_info = response.data; console.log(this.course_info) &#125;).catch(() =&gt; &#123; this.$message(&#123; message: &quot;对不起，访问页面出错！请联系客服工作人员！&quot; &#125;); &#125;) &#125;, get_chapter() &#123; // 获取当前课程对应的章节课时信息 // http://127.0.0.1:8000/course/chapters/?course=(pk) this.$axios.get(`$&#123;this.$settings.base_url&#125;course/chapter/`, &#123; params: &#123; &quot;course_id&quot;: this.course_id, &#125; &#125;).then(response =&gt; &#123; this.course_chapters = response.data; &#125;).catch(error =&gt; &#123; window.console.log(error.response); &#125;) &#125;, &#125;, components: &#123; Header, Footer, &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .main &#123; background: #fff; padding-top: 30px; &#125; .course-info &#123; width: 1200px; margin: 0 auto; overflow: hidden; &#125; .wrap-left &#123; float: left; width: 690px; height: 388px; background-color: #000; &#125; .wrap-right &#123; float: left; position: relative; height: 388px; &#125; .course-name &#123; font-size: 20px; color: #333; padding: 10px 23px; letter-spacing: .45px; &#125; .data &#123; padding-left: 23px; padding-right: 23px; padding-bottom: 16px; font-size: 14px; color: #9b9b9b; &#125; .sale-time &#123; width: 464px; background: #fa6240; font-size: 14px; color: #4a4a4a; padding: 10px 23px; overflow: hidden; &#125; .sale-type &#123; font-size: 16px; color: #fff; letter-spacing: .36px; float: left; &#125; .sale-time .expire &#123; font-size: 14px; color: #fff; float: right; &#125; .sale-time .expire .second &#123; width: 24px; display: inline-block; background: #fafafa; color: #5e5e5e; padding: 6px 0; text-align: center; &#125; .course-price &#123; background: #fff; font-size: 14px; color: #4a4a4a; padding: 5px 23px; &#125; .discount &#123; font-size: 26px; color: #fa6240; margin-left: 10px; display: inline-block; margin-bottom: -5px; &#125; .original &#123; font-size: 14px; color: #9b9b9b; margin-left: 10px; text-decoration: line-through; &#125; .buy &#123; width: 464px; padding: 0px 23px; position: absolute; left: 0; bottom: 20px; overflow: hidden; &#125; .buy .buy-btn &#123; float: left; &#125; .buy .buy-now &#123; width: 125px; height: 40px; border: 0; background: #ffc210; border-radius: 4px; color: #fff; cursor: pointer; margin-right: 15px; outline: none; &#125; .buy .free &#123; width: 125px; height: 40px; border-radius: 4px; cursor: pointer; margin-right: 15px; background: #fff; color: #ffc210; border: 1px solid #ffc210; &#125; .add-cart &#123; float: right; font-size: 14px; color: #ffc210; text-align: center; cursor: pointer; margin-top: 10px; &#125; .add-cart img &#123; width: 20px; height: 18px; margin-right: 7px; vertical-align: middle; &#125; .course-tab &#123; width: 100%; background: #fff; margin-bottom: 30px; box-shadow: 0 2px 4px 0 #f0f0f0; &#125; .course-tab .tab-list &#123; width: 1200px; margin: auto; color: #4a4a4a; overflow: hidden; &#125; .tab-list li &#123; float: left; margin-right: 15px; padding: 26px 20px 16px; font-size: 17px; cursor: pointer; &#125; .tab-list .active &#123; color: #ffc210; border-bottom: 2px solid #ffc210; &#125; .tab-list .free &#123; color: #fb7c55; &#125; .course-content &#123; width: 1200px; margin: 0 auto; background: #FAFAFA; overflow: hidden; padding-bottom: 40px; &#125; .course-tab-list &#123; width: 880px; height: auto; padding: 20px; background: #fff; float: left; box-sizing: border-box; overflow: hidden; position: relative; box-shadow: 0 2px 4px 0 #f0f0f0; &#125; .tab-item &#123; width: 880px; background: #fff; padding-bottom: 20px; box-shadow: 0 2px 4px 0 #f0f0f0; &#125; .tab-item-title &#123; justify-content: space-between; padding: 25px 20px 11px; border-radius: 4px; margin-bottom: 20px; border-bottom: 1px solid #333; border-bottom-color: rgba(51, 51, 51, .05); overflow: hidden; &#125; .chapter &#123; font-size: 17px; color: #4a4a4a; float: left; &#125; .chapter-length &#123; float: right; font-size: 14px; color: #9b9b9b; letter-spacing: .19px; &#125; .chapter-title &#123; font-size: 16px; color: #4a4a4a; letter-spacing: .26px; padding: 12px; background: #eee; border-radius: 2px; display: -ms-flexbox; display: flex; -ms-flex-align: center; align-items: center; &#125; .chapter-title img &#123; width: 18px; height: 18px; margin-right: 7px; vertical-align: middle; &#125; .section-list &#123; padding: 0 20px; &#125; .section-list .section-item &#123; padding: 15px 20px 15px 36px; cursor: pointer; justify-content: space-between; position: relative; overflow: hidden; &#125; .section-item .name &#123; font-size: 14px; color: #666; float: left; &#125; .section-item .index &#123; margin-right: 5px; &#125; .section-item .free &#123; font-size: 12px; color: #fff; letter-spacing: .19px; background: #ffc210; border-radius: 100px; padding: 1px 9px; margin-left: 10px; &#125; .section-item .time &#123; font-size: 14px; color: #666; letter-spacing: .23px; opacity: 1; transition: all .15s ease-in-out; float: right; &#125; .section-item .time img &#123; width: 18px; height: 18px; margin-left: 15px; vertical-align: text-bottom; &#125; .section-item .try &#123; width: 86px; height: 28px; background: #ffc210; border-radius: 4px; font-size: 14px; color: #fff; position: absolute; right: 20px; top: 10px; opacity: 0; transition: all .2s ease-in-out; cursor: pointer; outline: none; border: none; &#125; .section-item:hover &#123; background: #fcf7ef; box-shadow: 0 0 0 0 #f3f3f3; &#125; .section-item:hover .name &#123; color: #333; &#125; .section-item:hover .try &#123; opacity: 1; &#125; .course-side &#123; width: 300px; height: auto; margin-left: 20px; float: right; &#125; .teacher-info &#123; background: #fff; margin-bottom: 20px; box-shadow: 0 2px 4px 0 #f0f0f0; &#125; .side-title &#123; font-weight: normal; font-size: 17px; color: #4a4a4a; padding: 18px 14px; border-bottom: 1px solid #333; border-bottom-color: rgba(51, 51, 51, .05); &#125; .side-title span &#123; display: inline-block; border-left: 2px solid #ffc210; padding-left: 12px; &#125; .teacher-content &#123; padding: 30px 20px; box-sizing: border-box; &#125; .teacher-content .cont1 &#123; margin-bottom: 12px; overflow: hidden; &#125; .teacher-content .cont1 img &#123; width: 54px; height: 54px; margin-right: 12px; float: left; &#125; .teacher-content .cont1 .name &#123; float: right; &#125; .teacher-content .cont1 .teacher-name &#123; width: 188px; font-size: 16px; color: #4a4a4a; padding-bottom: 4px; &#125; .teacher-content .cont1 .teacher-title &#123; width: 188px; font-size: 13px; color: #9b9b9b; white-space: nowrap; &#125; .teacher-content .narrative &#123; font-size: 14px; color: #666; line-height: 24px; &#125;&lt;/style&gt; 2 课程详情接口12345# 课程列表(所有课程:分页，排序。。。)，再加一个课程详情# 基于原来的课程列表接口，只需要再加入继承一个类：RetrieveModelMixinclass CourseView(GenericViewSet, ListModelMixin,RetrieveModelMixin): queryset = Course.objects.all().filter(is_delete=False, is_show=True).order_by(&#x27;orders&#x27;) serializer_class = CourseSerializer 3 课程章节接口123# 查询所有章节---》章节跟课程有关联，根据课程id号，过滤章节# 比如：查询课程id为1的所有章节# 本质就是查询所有章节，带过滤功能 3.1 路由1router.register(&#x27;chapter&#x27;, CourseChapterView, &#x27;chapter&#x27;) 3.2 视图类123456class CourseChapterView(GenericViewSet, ListModelMixin): queryset = CourseChapter.objects.all().filter(is_show=True,is_delete=False).order_by(&#x27;orders&#x27;) serializer_class =CourseChapterSerializer filter_backends = [DjangoFilterBackend] # 加入过滤---》按照课程id过滤--》第三方django-filter filter_fields = [&#x27;course_id&#x27;] 3.3 序列化类1234567891011121314class CourseSectionSerializer(serializers.ModelSerializer): class Meta: model = CourseSection fields = [&#x27;name&#x27;, &#x27;orders&#x27;, &#x27;section_link&#x27;, &#x27;duration&#x27;, &#x27;free_trail&#x27;]class CourseChapterSerializer(serializers.ModelSerializer): # 使用子序列化 coursesections = CourseSectionSerializer(many=True) class Meta: model = CourseChapter # CourseChapter表中隐藏了一个coursesections字段，对象.coursesections fields = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;chapter&#x27;, &#x27;summary&#x27;, &#x27;coursesections&#x27;] # 返回该章节下的课时 4 搜索功能接口1234567891011121314151617# 搜索功能--》配合搜索接口# 类比：淘宝，京东，抖音，微博，百度---》这个接口本应该是最复杂，最有技术含量的接口 -不同的人搜出来的结果都不一样，因为有个性化推荐 -淘宝搜 [连体衣]---&gt;【电饭煲】 199以下# 咱们是最简单的实现，后期学完es：分布式全文检索引擎，基于es，写个百度# 正常来讲：搜索可以搜索所有类型课程---》免费课，实战课，轻课--》咱们只写了实战课，只能搜出实战课# 咱么如果只有实战课，实际上可以和查询所有实战课课程接口放一起---》为了方便后期的扩展，我们要单独写# 咱么你的可以按照课程名字模糊匹配# 速度慢的问题---》总共课程就不多--》mysql完全顶得住# 课程名字和id 在redis中缓存# 只要用搜索，对数量比较大，就上专业的搜索引擎---》es ---》倒排索引# http://127.0.0.1:8000/api/v1/course/search/?search=%E5%85%A5%E9%97%A8 4.2 视图类1234567891011121314151617# 只针对于实战课的搜索接口class CourseSearchView(GenericViewSet, ListModelMixin): queryset = Course.objects.all().filter(is_delete=False, is_show=True).order_by(&#x27;orders&#x27;) serializer_class = CourseSerializer filter_backends = [SearchFilter] search_fields = [&#x27;name&#x27;,] # 方便后期扩展 # def list(self, request, *args, **kwargs): # # 这个查的是实战课 # res=super().list(request, *args, **kwargs) # # res2=查询免费课 # # res3=查询轻课 # # # 上面全是取数据库查询 # # 后期改成取es中查询， # return APIResponse(result=&#123;&#x27;free_course&#x27;:&#x27;字典&#x27;,&#x27;actual_course&#x27;:res.data&#125;) 5 搜索功能前端123# 头部组件中的搜索框# 搜索结果展示页面 5.1 搜索form123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# Header.vu# html&lt;form class=&quot;search&quot;&gt; &lt;div class=&quot;tips&quot; v-if=&quot;is_search_tip&quot;&gt; &lt;span @click=&quot;search_action(&#x27;Python&#x27;)&quot;&gt;Python&lt;/span&gt; &lt;span @click=&quot;search_action(&#x27;Linux&#x27;)&quot;&gt;Linux&lt;/span&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; :placeholder=&quot;search_placeholder&quot; @focus=&quot;on_search&quot; @blur=&quot;off_search&quot; v-model=&quot;search_word&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;glyphicon glyphicon-search&quot; @click=&quot;search_action(search_word)&quot;&gt;&lt;/button&gt;&lt;/form&gt;# js search_action(search_word) &#123; if (!search_word) &#123; this.$message(&#x27;请输入要搜索的内容&#x27;); return &#125; // this.$route当前路径，query ?name=lqz --&gt;this.$route.query.name 拿到lqz if (search_word !== this.$route.query.word) &#123; this.$router.push(`/course/search?word=$&#123;search_word&#125;`); &#125; this.search_word = &#x27;&#x27;; &#125;, on_search() &#123; this.search_placeholder = &#x27;请输入想搜索的课程&#x27;; this.is_search_tip = false; &#125;, off_search() &#123; this.search_placeholder = &#x27;&#x27;; this.is_search_tip = true; &#125;, # css内容 .search &#123; float: right; position: relative; margin-top: 22px; margin-right: 10px; &#125; .search input, .search button &#123; border: none; outline: none; background-color: white; &#125; .search input &#123; border-bottom: 1px solid #eeeeee; &#125; .search input:focus &#123; border-bottom-color: orange; &#125; .search input:focus + button &#123; color: orange; &#125; .search .tips &#123; position: absolute; bottom: 3px; left: 0; &#125; .search .tips span &#123; border-radius: 11px; background-color: #eee; line-height: 22px; display: inline-block; padding: 0 7px; margin-right: 3px; cursor: pointer; color: #aaa; font-size: 14px; &#125; .search .tips span:hover &#123; color: orange; &#125; 5.2 搜索结果展示页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446&lt;template&gt; &lt;div class=&quot;search-course course&quot;&gt; &lt;Header/&gt; &lt;!-- 课程列表 --&gt; &lt;div class=&quot;main&quot;&gt; &lt;div v-if=&quot;course_list.length &gt; 0&quot; class=&quot;course-list&quot;&gt; &lt;div class=&quot;course-item&quot; v-for=&quot;course in course_list&quot; :key=&quot;course.name&quot;&gt; &lt;div class=&quot;course-image&quot;&gt; &lt;img :src=&quot;course.course_img&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;course-info&quot;&gt; &lt;h3&gt; &lt;router-link :to=&quot;&#x27;/free/detail/&#x27;+course.id&quot;&gt;&#123;&#123;course.name&#125;&#125;&lt;/router-link&gt; &lt;span&gt;&lt;img src=&quot;@/assets/img/avatar1.svg&quot; alt=&quot;&quot;&gt;&#123;&#123;course.students&#125;&#125;人已加入学习&lt;/span&gt;&lt;/h3&gt; &lt;p class=&quot;teather-info&quot;&gt; &#123;&#123;course.teacher.name&#125;&#125; &#123;&#123;course.teacher.title&#125;&#125; &#123;&#123;course.teacher.signature&#125;&#125; &lt;span v-if=&quot;course.sections&gt;course.pub_sections&quot;&gt;共&#123;&#123;course.sections&#125;&#125;课时/已更新&#123;&#123;course.pub_sections&#125;&#125;课时&lt;/span&gt; &lt;span v-else&gt;共&#123;&#123;course.sections&#125;&#125;课时/更新完成&lt;/span&gt; &lt;/p&gt; &lt;ul class=&quot;section-list&quot;&gt; &lt;li v-for=&quot;(section, key) in course.section_list&quot; :key=&quot;section.name&quot;&gt;&lt;span class=&quot;section-title&quot;&gt;0&#123;&#123;key+1&#125;&#125; | &#123;&#123;section.name&#125;&#125;&lt;/span&gt; &lt;span class=&quot;free&quot; v-if=&quot;section.free_trail&quot;&gt;免费&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;pay-box&quot;&gt; &lt;div v-if=&quot;course.discount_type&quot;&gt; &lt;span class=&quot;discount-type&quot;&gt;&#123;&#123;course.discount_type&#125;&#125;&lt;/span&gt; &lt;span class=&quot;discount-price&quot;&gt;￥&#123;&#123;course.real_price&#125;&#125;元&lt;/span&gt; &lt;span class=&quot;original-price&quot;&gt;原价：&#123;&#123;course.price&#125;&#125;元&lt;/span&gt; &lt;/div&gt; &lt;span v-else class=&quot;discount-price&quot;&gt;￥&#123;&#123;course.price&#125;&#125;元&lt;/span&gt; &lt;span class=&quot;buy-now&quot;&gt;立即购买&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div v-else style=&quot;text-align: center; line-height: 60px&quot;&gt; 没有搜索结果 &lt;/div&gt; &lt;div class=&quot;course_pagination block&quot;&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page.sync=&quot;filter.page&quot; :page-sizes=&quot;[2, 3, 5, 10]&quot; :page-size=&quot;filter.page_size&quot; layout=&quot;sizes, prev, pager, next&quot; :total=&quot;course_total&quot;&gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Header from &#x27;../components/Header&#x27; export default &#123; name: &quot;SearchCourse&quot;, components: &#123; Header, &#125;, data() &#123; return &#123; course_list: [], course_total: 0, filter: &#123; page_size: 10, page: 1, search: &#x27;&#x27;, &#125; &#125; &#125;, created() &#123; this.get_course() &#125;, watch: &#123; &#x27;$route.query&#x27; () &#123; this.get_course() &#125; &#125;, methods: &#123; handleSizeChange(val) &#123; // 每页数据量发生变化时执行的方法 this.filter.page = 1; this.filter.page_size = val; &#125;, handleCurrentChange(val) &#123; // 页码发生变化时执行的方法 this.filter.page = val; &#125;, get_course() &#123; // 获取搜索的关键字 this.filter.search = this.$route.query.word; // 获取课程列表信息 this.$axios.get(`$&#123;this.$settings.base_url&#125;course/search/`, &#123; params: this.filter &#125;).then(response =&gt; &#123; // 如果后台不分页，数据在response.data中；如果后台分页，数据在response.data.results中 this.course_list = response.data.results; this.course_total = response.data.count; &#125;).catch(() =&gt; &#123; this.$message(&#123; message: &quot;获取课程信息有误，请联系客服工作人员&quot; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .course &#123; background: #f6f6f6; &#125; .course .main &#123; width: 1100px; margin: 35px auto 0; &#125; .course .condition &#123; margin-bottom: 35px; padding: 25px 30px 25px 20px; background: #fff; border-radius: 4px; box-shadow: 0 2px 4px 0 #f0f0f0; &#125; .course .cate-list &#123; border-bottom: 1px solid #333; border-bottom-color: rgba(51, 51, 51, .05); padding-bottom: 18px; margin-bottom: 17px; &#125; .course .cate-list::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course .cate-list li &#123; float: left; font-size: 16px; padding: 6px 15px; line-height: 16px; margin-left: 14px; position: relative; transition: all .3s ease; cursor: pointer; color: #4a4a4a; border: 1px solid transparent; /* transparent 透明 */ &#125; .course .cate-list .title &#123; color: #888; margin-left: 0; letter-spacing: .36px; padding: 0; line-height: 28px; &#125; .course .cate-list .this &#123; color: #ffc210; border: 1px solid #ffc210 !important; border-radius: 30px; &#125; .course .ordering::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course .ordering ul &#123; float: left; &#125; .course .ordering ul::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course .ordering .condition-result &#123; float: right; font-size: 14px; color: #9b9b9b; line-height: 28px; &#125; .course .ordering ul li &#123; float: left; padding: 6px 15px; line-height: 16px; margin-left: 14px; position: relative; transition: all .3s ease; cursor: pointer; color: #4a4a4a; &#125; .course .ordering .title &#123; font-size: 16px; color: #888; letter-spacing: .36px; margin-left: 0; padding: 0; line-height: 28px; &#125; .course .ordering .this &#123; color: #ffc210; &#125; .course .ordering .price &#123; position: relative; &#125; .course .ordering .price::before, .course .ordering .price::after &#123; cursor: pointer; content: &quot;&quot;; display: block; width: 0px; height: 0px; border: 5px solid transparent; position: absolute; right: 0; &#125; .course .ordering .price::before &#123; border-bottom: 5px solid #aaa; margin-bottom: 2px; top: 2px; &#125; .course .ordering .price::after &#123; border-top: 5px solid #aaa; bottom: 2px; &#125; .course .ordering .price_up::before &#123; border-bottom-color: #ffc210; &#125; .course .ordering .price_down::after &#123; border-top-color: #ffc210; &#125; .course .course-item:hover &#123; box-shadow: 4px 6px 16px rgba(0, 0, 0, .5); &#125; .course .course-item &#123; width: 1100px; background: #fff; padding: 20px 30px 20px 20px; margin-bottom: 35px; border-radius: 2px; cursor: pointer; box-shadow: 2px 3px 16px rgba(0, 0, 0, .1); /* css3.0 过渡动画 hover 事件操作 */ transition: all .2s ease; &#125; .course .course-item::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; /* 顶级元素 父级元素 当前元素&#123;&#125; */ .course .course-item .course-image &#123; float: left; width: 423px; height: 210px; margin-right: 30px; &#125; .course .course-item .course-image img &#123; max-width: 100%; max-height: 210px; &#125; .course .course-item .course-info &#123; float: left; width: 596px; &#125; .course-item .course-info h3 a &#123; font-size: 26px; color: #333; font-weight: normal; margin-bottom: 8px; &#125; .course-item .course-info h3 span &#123; font-size: 14px; color: #9b9b9b; float: right; margin-top: 14px; &#125; .course-item .course-info h3 span img &#123; width: 11px; height: auto; margin-right: 7px; &#125; .course-item .course-info .teather-info &#123; font-size: 14px; color: #9b9b9b; margin-bottom: 14px; padding-bottom: 14px; border-bottom: 1px solid #333; border-bottom-color: rgba(51, 51, 51, .05); &#125; .course-item .course-info .teather-info span &#123; float: right; &#125; .course-item .section-list::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course-item .section-list li &#123; float: left; width: 44%; font-size: 14px; color: #666; padding-left: 22px; /* background: url(&quot;路径&quot;) 是否平铺 x轴位置 y轴位置 */ background: url(&quot;/src/assets/img/play-icon-gray.svg&quot;) no-repeat left 4px; margin-bottom: 15px; &#125; .course-item .section-list li .section-title &#123; /* 以下3句，文本内容过多，会自动隐藏，并显示省略符号 */ text-overflow: ellipsis; overflow: hidden; white-space: nowrap; display: inline-block; max-width: 200px; &#125; .course-item .section-list li:hover &#123; background-image: url(&quot;/src/assets/img/play-icon-yellow.svg&quot;); color: #ffc210; &#125; .course-item .section-list li .free &#123; width: 34px; height: 20px; color: #fd7b4d; vertical-align: super; margin-left: 10px; border: 1px solid #fd7b4d; border-radius: 2px; text-align: center; font-size: 13px; white-space: nowrap; &#125; .course-item .section-list li:hover .free &#123; color: #ffc210; border-color: #ffc210; &#125; .course-item &#123; position: relative; &#125; .course-item .pay-box &#123; position: absolute; bottom: 20px; width: 600px; &#125; .course-item .pay-box::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course-item .pay-box .discount-type &#123; padding: 6px 10px; font-size: 16px; color: #fff; text-align: center; margin-right: 8px; background: #fa6240; border: 1px solid #fa6240; border-radius: 10px 0 10px 0; float: left; &#125; .course-item .pay-box .discount-price &#123; font-size: 24px; color: #fa6240; float: left; &#125; .course-item .pay-box .original-price &#123; text-decoration: line-through; font-size: 14px; color: #9b9b9b; margin-left: 10px; float: left; margin-top: 10px; &#125; .course-item .pay-box .buy-now &#123; width: 120px; height: 38px; background: transparent; color: #fa6240; font-size: 16px; border: 1px solid #fd7b4d; border-radius: 3px; transition: all .2s ease-in-out; float: right; text-align: center; line-height: 38px; position: absolute; right: 0; bottom: 5px; &#125; .course-item .pay-box .buy-now:hover &#123; color: #fff; background: #ffc210; border: 1px solid #ffc210; &#125; .course .course_pagination &#123; margin-bottom: 60px; text-align: center; &#125;&lt;/style&gt; 6 支付宝支付介绍123456789101112131415161718# 目前线上付款方式有多种：支付宝，微信，银联# 以支付宝为例# 官方提供了API接口，原来没有提供python的sdk，使用第三方# 现在官方提供了python的sdk可以尝试使用官方sdk# 使用支付宝支付，需要是企业，要有营业执照才能申请，支付宝商家# 测试环境，沙箱环境，即便咱们不是商家，也可以测试，以后换成真正的appid，公钥私钥--》付款就到真正的地址# 沙箱环境：https://openhome.alipay.com/platform/appDaily.htm?tab=info# 沙箱版支付宝客户端：一个app，连得环境是测试环境，里面的钱可以一直冲，支付付到测试环境里# 支付宝支付的场景 -https://opendocs.alipay.com/open/270/105898# 流程 -我们自己网站有个立即购买按钮---》用户点击---》向咱们后端发送一个请求---》咱们后端生成一个没有支付的订单和支付连接(支付宝的)---&gt;返回给前端---》前端放在支付连接的地址---》显示出支付宝支付页面---》app扫码支付，账号密码支付---》支付成功---》支付宝收到了支付---》支付宝会回调回咱们项目支付成功的页面---》页面展示用户购买成功---》支付宝还有一个post回调---》咱们项目利用post回调，修改订单状态 7 支付宝支付二次封装123456789# 原来官方没有sdk，需要基于api去写# 第三方有人封装了python版的sdk# 第一步：下载：pip install python-alipay-sdk --upgrade# 第二步：生成公钥私钥 ---》非对称加密 -对称加密 ：加密和解密使用同一个秘钥 -非对称加密：加密用公钥，解密用私钥 -补充：支付宝为了更安全，需要使用咱们的公钥配置在网站上，生成一个支付宝公钥 -https://opendocs.alipay.com/common/02kipl -下载软件，在软件中生成 结构12345678libs ├── iPay # aliapy二次封装包 │ ├── __init__.py # 包文件 │ ├── pem # 公钥私钥文件夹 │ │ ├── alipay_public_key.pem # 支付宝公钥文件 │ │ ├── app_private_key.pem # 应用私钥文件 │ ├── pay.py # 支付文件 └── └── settings.py # 应用配置 alipay_public_key.pem123-----BEGIN PUBLIC KEY-----拿应用公钥跟支付宝换来的支付宝公钥-----END PUBLIC KEY----- app_private_key.pem123-----BEGIN RSA PRIVATE KEY-----通过支付宝公钥私钥签发软件签发的应用私钥-----END RSA PRIVATE KEY----- setting.py123456789101112131415161718import os# 应用私钥APP_PRIVATE_KEY_STRING = open(os.path.join(os.path.dirname(os.path.abspath(__file__)), &#x27;pem&#x27;, &#x27;app_private_key.pem&#x27;)).read()# 支付宝公钥ALIPAY_PUBLIC_KEY_STRING = open(os.path.join(os.path.dirname(os.path.abspath(__file__)), &#x27;pem&#x27;, &#x27;alipay_public_key.pem&#x27;)).read()# 应用IDAPP_ID = &#x27;2016093000631831&#x27;# 加密方式SIGN = &#x27;RSA2&#x27;# 是否是支付宝测试环境(沙箱环境)，如果采用真是支付宝环境，配置FalseDEBUG = True# 支付网关GATEWAY = &#x27;https://openapi.alipaydev.com/gateway.do&#x27; if DEBUG else &#x27;https://openapi.alipay.com/gateway.do&#x27; pay.py123456789101112131415from alipay import AliPayfrom . import settings# 支付对象alipay = AliPay( appid=settings.APP_ID, app_notify_url=None, app_private_key_string=settings.APP_PRIVATE_KEY_STRING, alipay_public_key_string=settings.ALIPAY_PUBLIC_KEY_STRING, sign_type=settings.SIGN, debug=settings.DEBUG)# 支付网关gateway = settings.GATEWAY *init*.py12# 包对外提供的变量from .pay import gateway, alipay 8 视频托管123456789101112131415161718192021222324252627# 图片，视频，一般不放在自己项目中---&gt;只要访问一次图片，就向后端发一次请求--》消耗服务器资源# 静态类型文件，托管到第三方平台---》花钱---》使用第三方平台的服务器资源和带宽# 视频托管到云平台了 -阿里 oss -七牛云存储。。。# 公司里多种方案---》托管到其他平台 -云平台---》花钱---》七牛云 -公司自己搭建文件服务器 -fastdfs：搭建笔记，python上传：https://zhuanlan.zhihu.com/p/372286804 -Minio：自己搭建Minio，阿里云上--》搭建笔记--》上传下载比较简单 -图形化界面后台，登陆上看到文件 -ceph 。。。 -放到项目中 # 七牛云---》国内go语言推崇者--》项目基本都是go开发的---》许式伟 -go的国内镜像：goproxy.cn 就是七牛云的 -豆瓣python---》python写的# 七牛云上传 -手动上传---》手动配置视频地址--（不采取） -前端上传，返回连接地址，提交到咱们自己的后端，存到数据库 -前端把视频传到咱们后端，咱们后端通过python传到七牛云，生成连接，存到数据库 8.1 七牛文件上传12345678910111213from qiniu import Auth, put_file, etagq = Auth(&#x27;--&#x27;, &#x27;-&#x27;)#要上传的空间bucket_name = &#x27;lqz&#x27;#上传后保存的文件名key = &#x27;致命诱惑.png&#x27;#生成上传 Token，可以指定过期时间等token = q.upload_token(bucket_name, key, 3600)#要上传文件的本地路径localfile = &#x27;./default.png&#x27;ret, info = put_file(token, key, localfile, version=&#x27;v2&#x27;)print(info) 9 支付接口1234# 登陆后才能访问， 前端支付按钮---&gt;点击支付按钮，向后端发送post请求&#123;courses:[1,2,3],total_amount:99&#125;--&gt;生成订单(订单表)--》生成支付连接--》返回给前端---&gt;前端打开# 扩写auth的user表，使用drf-jwt，提供的认证(认证类，权限类) 9.1 订单相关表设计1234567891011# 订单表 # 订单详情表&quot;&quot;&quot;class Order(models.Model): # 主键、总金额、订单名、订单号、订单状态、创建时间、支付时间、流水号、支付方式、支付人(外键) - 优惠劵(外键，可为空) passclass OrderDetail(models.Model): # 订单号(外键)、商品(外键)、实价、成交价 - 商品数量 pass&quot;&quot;&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from django.db import modelsfrom user.models import Userfrom course.models import Courseclass Order(models.Model): &quot;&quot;&quot;订单模型&quot;&quot;&quot; status_choices = ( (0, &#x27;未支付&#x27;), (1, &#x27;已支付&#x27;), (2, &#x27;已取消&#x27;), (3, &#x27;超时取消&#x27;), ) pay_choices = ( (1, &#x27;支付宝&#x27;), (2, &#x27;微信支付&#x27;), ) # 订单标题 subject = models.CharField(max_length=150, verbose_name=&quot;订单标题&quot;) # 总价格 total_amount = models.DecimalField(max_digits=10, decimal_places=2, verbose_name=&quot;订单总价&quot;, default=0) # 订单号--使用uuid生成 out_trade_no = models.CharField(max_length=64, verbose_name=&quot;订单号&quot;, unique=True) # 流水号支付宝返回的 trade_no = models.CharField(max_length=64, null=True, verbose_name=&quot;流水号&quot;) # 订单状态 待支付，已支付。。。 order_status = models.SmallIntegerField(choices=status_choices, default=0, verbose_name=&quot;订单状态&quot;) # 微信，支付宝 pay_type = models.SmallIntegerField(choices=pay_choices, default=1, verbose_name=&quot;支付方式&quot;) # 支付时间--》支付宝回调回来会有 pay_time = models.DateTimeField(null=True, verbose_name=&quot;支付时间&quot;) # 用户表关联 user = models.ForeignKey(User, related_name=&#x27;order_user&#x27;, on_delete=models.DO_NOTHING, db_constraint=False, verbose_name=&quot;下单用户&quot;) # 订单创建时间 auto_now_add:新增这个时间可以不传，用当前时间 auto_now：修改时间不传，自动存入当前时间 created_time = models.DateTimeField(auto_now_add=True, verbose_name=&#x27;创建时间&#x27;) class Meta: db_table = &quot;luffy_order&quot; verbose_name = &quot;订单记录&quot; verbose_name_plural = &quot;订单记录&quot; def __str__(self): return &quot;%s - ￥%s&quot; % (self.subject, self.total_amount) @property def courses(self): data_list = [] for item in self.order_courses.all(): data_list.append(&#123; &quot;id&quot;: item.id, &quot;course_name&quot;: item.course.name, &quot;real_price&quot;: item.real_price, &#125;) return data_listclass OrderDetail(models.Model): &quot;&quot;&quot;订单详情&quot;&quot;&quot; # 跟订单一对多 order = models.ForeignKey(Order, related_name=&#x27;order_courses&#x27;, on_delete=models.CASCADE, db_constraint=False, verbose_name=&quot;订单&quot;) # 跟课程一对多 course = models.ForeignKey(Course, related_name=&#x27;course_orders&#x27;, on_delete=models.CASCADE, db_constraint=False, verbose_name=&quot;课程&quot;) # 价格 price = models.DecimalField(max_digits=6, decimal_places=2, verbose_name=&quot;课程原价&quot;) # 真实价格 real_price = models.DecimalField(max_digits=6, decimal_places=2, verbose_name=&quot;课程实价&quot;) class Meta: db_table = &quot;luffy_order_detail&quot; verbose_name = &quot;订单详情&quot; verbose_name_plural = &quot;订单详情&quot; def __str__(self): try: return &quot;%s的订单：%s&quot; % (self.course.name, self.order.out_trade_no) except: return super().__str__() 9.2 支付接口路由 1router.register(&#x27;pay&#x27;, OrderView, &#x27;pay&#x27;) 视图类 12345678910111213class OrderView(GenericViewSet, CreateModelMixin): # 登陆后才能访问 authentication_classes = [JSONWebTokenAuthentication,] permission_classes = [IsAuthenticated] queryset = Order.objects.all() serializer_class = OrderSerializer def create(self, request, *args, **kwargs): serializer = self.get_serializer(data=request.data,context=&#123;&#x27;request&#x27;:request&#125;) serializer.is_valid(raise_exception=True) pay_url = serializer.context.get(&#x27;pay_url&#x27;) self.perform_create(serializer) return APIResponse(pay_url=pay_url) 序列化类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 只用来做反序列化---&gt;数据校验--&gt;重写create方法--》存两个表class OrderSerializer(serializers.ModelSerializer): # 前端传入的是课程列表[1,2,3,]---》转成[课程对象1，课程对象2，课程对象三] courses = serializers.PrimaryKeyRelatedField(queryset=Course.objects.all(), many=True) # 前端传入的是课程列表[1,2,3,] # courses = serializers.ListField() class Meta: model = Order # 订单标题，总价格，支付方式，courses所有购买的课程id号列表 fields = (&#x27;subject&#x27;, &#x27;total_amount&#x27;, &#x27;pay_type&#x27;, &#x27;courses&#x27;) def _check_total_amount(self, attrs): courses = attrs.get(&#x27;courses&#x27;) # 列表[课程1，课程2，课程3] total_amount = attrs.get(&#x27;total_amount&#x27;) # 前端传入的总价格 total_price = 0 for course in courses: total_price += course.price if total_price != total_amount: # 计算完的价格不等于传入的价格，抛异常 raise ValidationError(&#x27;total_amount error&#x27;) return total_amount def _get_out_trade_no(self): import uuid code = str(uuid.uuid4()) # 分布式id的生成方案：订单号全局唯一，如何生成全局唯一的订单号：uuid，使用当前时间时间戳(重复概率)，雪花算法 return code.replace(&#x27;-&#x27;, &#x27;&#x27;) # 获取支付人 def _get_user(self): return self.context.get(&#x27;request&#x27;).user # 获取支付链接 def _get_pay_url(self, out_trade_no, total_amount, subject): from libs import iPay from django.conf import settings order_string = iPay.alipay.api_alipay_trade_page_pay( out_trade_no=out_trade_no, total_amount=float(total_amount), # 只有生成支付宝链接时，不能用Decimal subject=subject, return_url=settings.RETURN_URL, # get回调地址，前台地址 notify_url=settings.NOTIFY_URL, # post回调地址,后台地址 ) pay_url = iPay.gateway + &#x27;?&#x27; + order_string # 将支付链接存入，传递给views self.context[&#x27;pay_url&#x27;] = pay_url # 入库(两个表)的信息准备 def _before_create(self, attrs, user, out_trade_no): attrs[&#x27;user&#x27;] = user attrs[&#x27;out_trade_no&#x27;] = out_trade_no def validate(self, attrs): # 1）订单总价校验-- total_amount = self._check_total_amount(attrs) # 2）生成订单号--》唯一的 out_trade_no = self._get_out_trade_no() # 3）支付用户：request.user user = self._get_user() # 4）支付链接生成 self._get_pay_url(out_trade_no, total_amount, attrs.get(&#x27;subject&#x27;)) # 5）入库(两个表)的信息准备 self._before_create(attrs, user, out_trade_no) # 代表该校验方法通过，进入入库操作 return attrs def create(self, validated_data): courses = validated_data.pop(&#x27;courses&#x27;) # 订单表入库，不需要courses, 订单号，订单标题，订单价格，购买人，支付方式 order = Order.objects.create(**validated_data) # 订单详情表入库：只需要订单对象，课程对象(courses要拆成一个个course) for course in courses: OrderDetail.objects.create(order=order, course=course, price=course.price, real_price=course.price) return order 10 支付前端12345678910111213141516171819202122232425262728293031go_pay(course_info) &#123; // 1 去cookie中取token，如果没有说明没登陆，不允许购买 let token = this.$cookies.get(&quot;token&quot;) if (token) &#123; this.$axios.post(this.$settings.base_url + &#x27;order/pay/&#x27;, &#123; &quot;subject&quot;: course_info.name, &quot;total_amount&quot;: course_info.price, &quot;pay_type&quot;: 1, &quot;courses&quot;: [course_info.id] &#125;, &#123; headers: &#123; authorization: &#x27;jwt &#x27; + token, &#125; &#125;).then(res =&gt; &#123; if (res.data.status = 100) &#123; let pay_url = res.data.pay_url // 跳转,在当前窗口打开这个链接 open(pay_url, &#x27;_self&#x27;); &#125; else &#123; this.$message(&#123; message: &quot;下单失败，请联系统管理员&quot; &#125;); &#125; &#125;) &#125; else &#123; this.$message(&#123; message: &quot;对不起，您没有登录，请登陆后购买！&quot; &#125;); &#125; &#125;, 11 支付成功回调接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from utils.log import logger# from rest_framework.viewsets import ViewSetfrom rest_framework.views import APIViewfrom rest_framework.response import Response# 支付回调接口class SuccessViewSet(APIView): # 认证取消 authentication_classes = () permission_classes = () # 支付宝同步回调给前台，在同步通知给后台处理 # 写不写都行---》给咱们前端做二次验证的 def get(self, request, *args, **kwargs): # return Response(&#x27;后台已知晓，Over！！！&#x27;) # 不能在该接口完成订单修改操作 # 但是可以在该接口中校验订单状态(已经收到支付宝post异步通知，订单已修改)，告诉前台 # print(type(request.query_params)) # django.http.request.QueryDict # print(type(request.query_params.dict())) # dict out_trade_no = request.query_params.get(&#x27;out_trade_no&#x27;) try: Order.objects.get(out_trade_no=out_trade_no, order_status=1) return APIResponse(status=100,msg=&#x27;订单支付成功&#x27;) except: return APIResponse(status=101,msg=&#x27;订单还未支付&#x27;) # 支付宝异步回调处理 def post(self, request, *args, **kwargs): try: # request.data前端(支付宝)post传给咱们的数据--》request.data--》 QueyDic对象，不允许pop，把它转成字典 result_data = request.data.dict() # 支付宝给我的订单号---》数据库有个订单号 out_trade_no = result_data.get(&#x27;out_trade_no&#x27;) # 前面--&gt;验证签名才信任支付宝，防止伪造 signature = result_data.pop(&#x27;sign&#x27;) from libs import iPay result = iPay.alipay.verify(result_data, signature) if result and result_data[&quot;trade_status&quot;] in (&quot;TRADE_SUCCESS&quot;, &quot;TRADE_FINISHED&quot;): # 完成订单修改：订单状态、流水号、支付时间 # 已支付 Order.objects.filter(out_trade_no=out_trade_no).update(order_status=1) # 完成日志记录 logger.warning(&#x27;%s订单支付成功&#x27; % out_trade_no) return Response(&#x27;success&#x27;) else: logger.error(&#x27;%s订单支付失败&#x27; % out_trade_no) except: pass return Response(&#x27;failed&#x27;) 11.1 支付成功前端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;template&gt; &lt;div class=&quot;pay-success&quot;&gt; &lt;!--如果是单独的页面，就没必要展示导航栏(带有登录的用户)--&gt; &lt;Header/&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;success-tips&quot;&gt; &lt;p class=&quot;tips&quot;&gt;您已成功购买 1 门课程！&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;order-info&quot;&gt; &lt;p class=&quot;info&quot;&gt;&lt;b&gt;订单号：&lt;/b&gt;&lt;span&gt;&#123;&#123; result.out_trade_no &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;info&quot;&gt;&lt;b&gt;交易号：&lt;/b&gt;&lt;span&gt;&#123;&#123; result.trade_no &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;info&quot;&gt;&lt;b&gt;付款时间：&lt;/b&gt;&lt;span&gt;&lt;span&gt;&#123;&#123; result.timestamp &#125;&#125;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;study&quot;&gt; &lt;span&gt;立即学习&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Header from &quot;@/components/Header&quot; export default &#123; name: &quot;Success&quot;, data() &#123; return &#123; result: &#123;&#125;, &#125;; &#125;, created() &#123; // url后拼接的参数：?及后面的所有参数 =&gt; ?a=1&amp;b=2 // console.log(location.search); // 解析支付宝回调的url参数 let params = location.search.substring(1); // 去除? =&gt; a=1&amp;b=2 let items = params.length ? params.split(&#x27;&amp;&#x27;) : []; // [&#x27;a=1&#x27;, &#x27;b=2&#x27;] //逐个将每一项添加到args对象中 for (let i = 0; i &lt; items.length; i++) &#123; // 第一次循环a=1，第二次b=2 let k_v = items[i].split(&#x27;=&#x27;); // [&#x27;a&#x27;, &#x27;1&#x27;] //解码操作，因为查询字符串经过编码的 if (k_v.length &gt;= 2) &#123; // url编码反解 let k = decodeURIComponent(k_v[0]); this.result[k] = decodeURIComponent(k_v[1]); // 没有url编码反解 // this.result[k_v[0]] = k_v[1]; &#125; &#125; // 解析后的结果 // console.log(this.result); // 把地址栏上面的支付结果，再get请求转发给后端 this.$axios(&#123; url: this.$settings.base_url + &#x27;order/success/&#x27; + location.search, method: &#x27;get&#x27;, &#125;).then(response =&gt; &#123; console.log(response.data) if(response.data.status!=100)&#123; alert(&#x27;暂时还没收到您的支付，请稍后刷新再试&#x27;) &#125; &#125;).catch(() =&gt; &#123; console.log(&#x27;支付结果同步失败&#x27;); &#125;) &#125;, components: &#123; Header, &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .main &#123; padding: 60px 0; margin: 0 auto; width: 1200px; background: #fff; &#125; .main .title &#123; display: flex; -ms-flex-align: center; align-items: center; padding: 25px 40px; border-bottom: 1px solid #f2f2f2; &#125; .main .title .success-tips &#123; box-sizing: border-box; &#125; .title img &#123; vertical-align: middle; width: 60px; height: 60px; margin-right: 40px; &#125; .title .success-tips &#123; box-sizing: border-box; &#125; .title .tips &#123; font-size: 26px; color: #000; &#125; .info span &#123; color: #ec6730; &#125; .order-info &#123; padding: 25px 48px; padding-bottom: 15px; border-bottom: 1px solid #f2f2f2; &#125; .order-info p &#123; display: -ms-flexbox; display: flex; margin-bottom: 10px; font-size: 16px; &#125; .order-info p b &#123; font-weight: 400; color: #9d9d9d; white-space: nowrap; &#125; .study &#123; padding: 25px 40px; &#125; .study span &#123; display: block; width: 140px; height: 42px; text-align: center; line-height: 42px; cursor: pointer; background: #ffc210; border-radius: 6px; font-size: 16px; color: #fff; &#125;&lt;/style&gt; 12 内网穿透123# 内网穿透基本都要花钱：花生壳，frp。。。# 一般都要收费---》买个公网服务器上线后才能正常回调# https://zhuanlan.zhihu.com/p/370483324","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"10、课程页面、课程主页表分析、课程页面数据录入、课程分类接口、课程列表接口、课程页面前后端调通、课程详情接口、课程详情页面","slug":"luffy_day10","date":"2021-07-28T06:04:10.000Z","updated":"2022-05-14T05:30:48.599Z","comments":true,"path":"2021/07/28/luffy_day10/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day10/","excerpt":"","text":"复习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# celery 分布式异步任务框架# 本质原理---》其他项目提交一些任务(任务属于celery)，到任务中间件(redis)---》celery启动worker(进程)---》worker负责从任务中间件中取任务，执行---》执行完把结果放到结果存储(redis)---》通过id号查询结果是否成功# 能够做的事： 1 异步执行 ---》同步和异步的区别 ajax--》异步的xml--》发送ajax---》 2 延迟任务 3 定时 # 架构组成 -消息中间件----》redis -任务执行单元---》worker---》worker的性能---》开100个 -结果存储---》redis # 包结构# 如何启动workercelery -A celery_task worker -l info# 如何执行异步，延迟，定时 -任务.delay(参数，参数2) 异步任务，异步的执行 -任务.apply_async(args=[],eta=时间对象) 延迟任务，到时间就执行 -celery.py 中写 # 集成到django中 -加两句话，celery是独立的，跟django没有必然联系，任务中要使用django的东西，在脚本中调用django程序 # 接口缓存 -redis 叫缓存数据库 -从数据查出来的数据---&gt;序列化后----&gt;存到redis中 -下次再来请求---》优先从redis中取---》能取到直接返回，不需要查询mysql---》如果取不到，再去查数据库 # 缓存不一致问题：redis和mysql数据不一致----》双写一致性 -定时更新缓存----》celery的定时任务---》 -缓存过期技术 -更新mysql删除缓存 -更新mysql更新缓存 -删除缓存更新mysql -更新缓存更新mysql # 首页轮播图定时更新# 为什么不写：更新mysql删除缓存---》插入轮播图---&gt;后台admin插入的---》插入代码不是你写的# 使用django信号完成（没有讲）# https://www.cnblogs.com/liuqingzheng/p/11012099.html# https://www.cnblogs.com/liuqingzheng/p/11080501.html# https://www.cnblogs.com/liuqingzheng/p/11080680.html 1 课程页面复制1234567891011121314151617181920212223242526# 前端路由跳转: -js:this.$router.push(&#x27;/free-course&#x27;) -html:&lt;router-link to=&#x27;/free-course&#x27;&gt;&lt;/router-link&gt; # 在前端 router 的index.js中加入三条路由 &#123; path: &#x27;/actual-course&#x27;, name: &#x27;ActualCourse&#x27;, component: ActualCourse &#125;, &#123; path: &#x27;/free-course&#x27;, name: &#x27;FreeCourse&#x27;, component: FreeCourse &#125;, &#123; path: &#x27;/light-course&#x27;, name: &#x27;LightCourse&#x27;, component: LightCourse &#125;, # 前端新建三个vue页面：ActualCourse，FreeCourse，LightCourse# 把前端代码复制到ActualCourse中即可 2 课程主页表分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 三类课程---》表用同一个还是分开 -由于三种课程字段不一样，我们把每个课程简历一个表 # 以实战课为例来写 -课程分类表 -实战课表 ---》跟课程分类是一对多 ---》Python7天入门---》第一章：环境搭建 5个视频 第二章：面向对象 15个视频 -课程章节---》跟实战课表是一对多的关系 -课时表---》跟章节表一对多 -老师表--》一对多---》一个老师讲多门课程 -评论表(没写) # 建立5张表# ForeignKey 属性on_delete可以选择如下： -CASCADE 级联删除，比如删除老师，老师关联的所有课程都删除---》危险系数太高 作者和作者详情，就可以使用级联删除 -DO_NOTHING 什么都不做 -SET_DEFAULT 删了老师，课程这个字段设置成默认，配合default -SET_NULL 删了老师，课程中老师这个字段设置为空 null=True -SET(值/函数) 删除老师，执行函数，课程中老师这个字段设置为SET的值或函数的执行结果 # ForeignKey 属性 db_constraint -ForeignKey是外键---》实际上在数据库会有外键关系 -实际上外键关系有好处---》做约束---》插入数据时，脏数据插入不进去 -坏处--》插入速度慢---》插入的时候要校验约束 -实际编码中，公司里，基本不用外键约束----》这些操作统统由程序员和程序约束--》提高速度 -db_constraint 不建外键约束---》可以基于对象的跨表查询--》基于双下划线的连表查---》一点不受影响 # ForeignKey 属性 related_name反向操作时，使用的字段名，用于代替原反向查询时的’表名_set’反向操作：通过课程查询所有章节：course.表名小写_set.all()如果写了related_name---》course.coursechapters.all()# ForeignKey 属性 related_query_name反向查询操作时，使用的连接前缀，用于替换表名。原来 __链表查询，使用表名小写，写了它后，直接使用这个字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172from django.db import modelsfrom utils.model import BaseModel# 课程分类表class CourseCategory(BaseModel): &quot;&quot;&quot;分类&quot;&quot;&quot; name = models.CharField(max_length=64, unique=True, verbose_name=&quot;分类名称&quot;) class Meta: db_table = &quot;luffy_course_category&quot; verbose_name = &quot;分类&quot; verbose_name_plural = verbose_name def __str__(self): return &quot;%s&quot; % self.name# 实战课表class Course(BaseModel): # choice course_type = ( (0, &#x27;付费&#x27;), (1, &#x27;超级VIP专享&#x27;), ) level_choices = ( (0, &#x27;初级&#x27;), (1, &#x27;中级&#x27;), (2, &#x27;高级&#x27;), (3, &#x27;特高级&#x27;), (4, &#x27;超神&#x27;), ) status_choices = ( (0, &#x27;上线&#x27;), (1, &#x27;下线&#x27;), (2, &#x27;预上线&#x27;), ) # 课程名 name = models.CharField(max_length=128, verbose_name=&quot;课程名称&quot;) # 课程图片 null：数据库可以为空，blank:后台管理录入的时候可以不填， course_img = models.ImageField(upload_to=&quot;courses&quot;, max_length=255, verbose_name=&quot;封面图片&quot;, blank=True, null=True) # 付费类型 course_type = models.SmallIntegerField(choices=course_type, default=0, verbose_name=&quot;付费类型&quot;) # 详情介绍--》课程详情页面---》TextField---》bbs项目的文章详情，html内容 brief = models.TextField(max_length=2048, verbose_name=&quot;详情介绍&quot;, null=True, blank=True) # 难度等级 level = models.SmallIntegerField(choices=level_choices, default=0, verbose_name=&quot;难度等级&quot;) # 发布日期 课程录入一个时间---》没有发布---》发布是在网站上可以看到了 pub_date = models.DateField(verbose_name=&quot;发布日期&quot;, auto_now_add=True) # 建议学习周期 period = models.IntegerField(verbose_name=&quot;建议学习周期(day)&quot;, default=7) # 课件路径--》课程有课件 ppt，png，md---》压缩成zip attachment_path = models.FileField(upload_to=&quot;attachment&quot;, max_length=128, verbose_name=&quot;课件路径&quot;, blank=True, null=True) # 课程状态 status = models.SmallIntegerField(choices=status_choices, default=0, verbose_name=&quot;课程状态&quot;) # 学习人数 ---》优化字段，正常课程跟用户是有关系的，不需要关联查询统计用户个数了 students = models.IntegerField(verbose_name=&quot;学习人数&quot;, default=0) # 总课时数量---3个章节20课时的内容 sections = models.IntegerField(verbose_name=&quot;总课时数量&quot;, default=0) # 课时更新数量 ---》3个章节20课时的内容现在只更新了10个 pub_sections = models.IntegerField(verbose_name=&quot;课时更新数量&quot;, default=0) # 课程原价 price = models.DecimalField(max_digits=6, decimal_places=2, verbose_name=&quot;课程原价&quot;, default=0) ### 关联字段---》老师---》一个老师有多门课程，关联字段写在多的一方，写在课程中 teacher = models.ForeignKey(&quot;Teacher&quot;, on_delete=models.DO_NOTHING, null=True, blank=True, verbose_name=&quot;授课老师&quot;) ### 关联字段---》课程分类---&gt;一个分类下有多个课程，关联字段写在多的一方 course_category = models.ForeignKey(&quot;CourseCategory&quot;, on_delete=models.SET_NULL, db_constraint=False, null=True, blank=True, verbose_name=&quot;课程分类&quot;) class Meta: db_table = &quot;luffy_course&quot; verbose_name = &quot;课程&quot; verbose_name_plural = &quot;课程&quot; def __str__(self): return &quot;%s&quot; % self.name# 课程章节class CourseChapter(BaseModel): # 一对多，写在多的一方 course = models.ForeignKey(&quot;Course&quot;, related_name=&#x27;coursechapters&#x27;, on_delete=models.CASCADE, verbose_name=&quot;课程名称&quot;) # 章节数字---&gt;第几章 chapter = models.SmallIntegerField(verbose_name=&quot;第几章&quot;, default=1) # 章节标题 name = models.CharField(max_length=128, verbose_name=&quot;章节标题&quot;) # 章节介绍 summary = models.TextField(verbose_name=&quot;章节介绍&quot;, blank=True, null=True) # 发布日期 pub_date = models.DateField(verbose_name=&quot;发布日期&quot;, auto_now_add=True) class Meta: db_table = &quot;luffy_course_chapter&quot; verbose_name = &quot;章节&quot; verbose_name_plural = verbose_name def __str__(self): return &quot;%s:(第%s章)%s&quot; % (self.course, self.chapter, self.name)# 课时表class CourseSection(BaseModel): &quot;&quot;&quot;课时&quot;&quot;&quot; section_type_choices = ( (0, &#x27;文档&#x27;), (1, &#x27;练习&#x27;), (2, &#x27;视频&#x27;) ) # 跟章节一对多，关联字段写在多的一方 chapter = models.ForeignKey(&quot;CourseChapter&quot;, related_name=&#x27;coursesections&#x27;, on_delete=models.CASCADE, verbose_name=&quot;课程章节&quot;) # 课时名 name = models.CharField(max_length=128, verbose_name=&quot;课时标题&quot;) # 重写字段 orders = models.PositiveSmallIntegerField(verbose_name=&quot;课时排序&quot;) # 课时种类：视频，文档，练习 section_type = models.SmallIntegerField(default=2, choices=section_type_choices, verbose_name=&quot;课时种类&quot;) # 课时链接：视频地址，文档地址 section_link = models.CharField(max_length=255, blank=True, null=True, verbose_name=&quot;课时链接&quot;, help_text=&quot;若是video，填vid,若是文档，填link&quot;) # 视频时长 ，仅在前端展示使用 duration = models.CharField(verbose_name=&quot;视频时长&quot;, blank=True, null=True, max_length=32) # 发布时间 pub_date = models.DateTimeField(verbose_name=&quot;发布时间&quot;, auto_now_add=True) # 是否可试看 允许免费看几个视频 free_trail = models.BooleanField(verbose_name=&quot;是否可试看&quot;, default=False) class Meta: db_table = &quot;luffy_course_section&quot; verbose_name = &quot;课时&quot; verbose_name_plural = verbose_name def __str__(self): return &quot;%s-%s&quot; % (self.chapter, self.name)# 老师表class Teacher(BaseModel): &quot;&quot;&quot;导师&quot;&quot;&quot; role_choices = ( (0, &#x27;讲师&#x27;), (1, &#x27;导师&#x27;), (2, &#x27;班主任&#x27;), ) # 老师名 name = models.CharField(max_length=32, verbose_name=&quot;导师名&quot;) # 老师身份---》讲师，导师，班主任 role = models.SmallIntegerField(choices=role_choices, default=0, verbose_name=&quot;导师身份&quot;) # 职位、职称 title = models.CharField(max_length=64, verbose_name=&quot;职位、职称&quot;) # 导师签名 signature = models.CharField(max_length=255, verbose_name=&quot;导师签名&quot;, help_text=&quot;导师签名&quot;, blank=True, null=True) # 老师图片 image = models.ImageField(upload_to=&quot;teacher&quot;, null=True, verbose_name=&quot;导师封面&quot;) # 导师描述--&gt;很详细--&gt;html brief = models.TextField(max_length=1024, verbose_name=&quot;导师描述&quot;) class Meta: db_table = &quot;luffy_teacher&quot; verbose_name = &quot;导师&quot; verbose_name_plural = verbose_name def __str__(self): return &quot;%s&quot; % self.name 123456789101112# 注册app# 迁移数据python manage.py makemigrationspython manage.py migrate # admin中注册from .models import *admin.site.register(Teacher)admin.site.register(CourseCategory)admin.site.register(Course)admin.site.register(CourseChapter)admin.site.register(CourseSection) 3 课程页面数据录入3.1 老师表数据12345INSERT INTO luffy_teacher(id, orders, is_show, is_delete, created_time, updated_time, name, role, title, signature, image, brief) VALUES (1, 1, 1, 0, &#x27;2019-07-14 13:44:19.661327&#x27;, &#x27;2019-07-14 13:46:54.246271&#x27;, &#x27;Alex&#x27;, 1, &#x27;老男孩Python教学总监&#x27;, &#x27;金角大王&#x27;, &#x27;teacher/alex_icon.png&#x27;, &#x27;老男孩教育CTO &amp; CO-FOUNDER 国内知名PYTHON语言推广者 51CTO学院2016\\2017年度最受学员喜爱10大讲师之一 多款开源软件作者 曾任职公安部、飞信、中金公司、NOKIA中国研究院、华尔街英语、ADVENT、汽车之家等公司&#x27;);INSERT INTO luffy_teacher(id, orders, is_show, is_delete, created_time, updated_time, name, role, title, signature, image, brief) VALUES (2, 2, 1, 0, &#x27;2019-07-14 13:45:25.092902&#x27;, &#x27;2019-07-14 13:45:25.092936&#x27;, &#x27;Mjj&#x27;, 0, &#x27;前美团前端项目组架构师&#x27;, NULL, &#x27;teacher/mjj_icon.png&#x27;, &#x27;是马JJ老师, 一个集美貌与才华于一身的男人，搞过几年IOS，又转了前端开发几年，曾就职于美团网任高级前端开发，后来因为不同意王兴(美团老板)的战略布局而出家做老师去了，有丰富的教学经验，开起车来也毫不含糊。一直专注在前端的前沿技术领域。同时，爱好抽烟、喝酒、烫头(锡纸烫)。 我的最爱是前端，因为前端妹子多。&#x27;);INSERT INTO luffy_teacher(id, orders, is_show, is_delete, created_time, updated_time, name, role, title, signature, image, brief) VALUES (3, 3, 1, 0, &#x27;2019-07-14 13:46:21.997846&#x27;, &#x27;2019-07-14 13:46:21.997880&#x27;, &#x27;Lyy&#x27;, 0, &#x27;老男孩Linux学科带头人&#x27;, NULL, &#x27;teacher/lyy_icon.png&#x27;, &#x27;Linux运维技术专家，老男孩Linux金牌讲师，讲课风趣幽默、深入浅出、声音洪亮到爆炸&#x27;); 3.2 分类表数据123INSERT INTO luffy_course_category(id, orders, is_show, is_delete, created_time, updated_time, name) VALUES (1, 1, 1, 0, &#x27;2019-07-14 13:40:58.690413&#x27;, &#x27;2019-07-14 13:40:58.690477&#x27;, &#x27;Python&#x27;);INSERT INTO luffy_course_category(id, orders, is_show, is_delete, created_time, updated_time, name) VALUES (2, 2, 1, 0, &#x27;2019-07-14 13:41:08.249735&#x27;, &#x27;2019-07-14 13:41:08.249817&#x27;, &#x27;Linux&#x27;); 3.3 课程表数据12345INSERT INTO luffy_course(id, orders, is_show, is_delete, created_time, updated_time, name, course_img, course_type, brief, level, pub_date, period, attachment_path, status, students, sections, pub_sections, price, course_category_id, teacher_id) VALUES (1, 1, 1, 0, &#x27;2019-07-14 13:54:33.095201&#x27;, &#x27;2019-07-14 13:54:33.095238&#x27;, &#x27;Python开发21天入门&#x27;, &#x27;courses/alex_python.png&#x27;, 0, &#x27;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&amp;&amp;&amp;Python从入门到入土&#x27;, 0, &#x27;2019-07-14&#x27;, 21, &#x27;&#x27;, 0, 231, 120, 120, 0.00, 1, 1);INSERT INTO luffy_course(id, orders, is_show, is_delete, created_time, updated_time, name, course_img, course_type, brief, level, pub_date, period, attachment_path, status, students, sections, pub_sections, price, course_category_id, teacher_id) VALUES (2, 2, 1, 0, &#x27;2019-07-14 13:56:05.051103&#x27;, &#x27;2019-07-14 13:56:05.051142&#x27;, &#x27;Python项目实战&#x27;, &#x27;courses/mjj_python.png&#x27;, 0, &#x27;&#x27;, 1, &#x27;2019-07-14&#x27;, 30, &#x27;&#x27;, 0, 340, 120, 120, 99.00, 1, 2);INSERT INTO luffy_course(id, orders, is_show, is_delete, created_time, updated_time, name, course_img, course_type, brief, level, pub_date, period, attachment_path, status, students, sections, pub_sections, price, course_category_id, teacher_id) VALUES (3, 3, 1, 0, &#x27;2019-07-14 13:57:21.190053&#x27;, &#x27;2019-07-14 13:57:21.190095&#x27;, &#x27;Linux系统基础5周入门精讲&#x27;, &#x27;courses/lyy_linux.png&#x27;, 0, &#x27;&#x27;, 0, &#x27;2019-07-14&#x27;, 25, &#x27;&#x27;, 0, 219, 100, 100, 39.00, 2, 3); 3.4 章节表数据1234567INSERT INTO luffy_course_chapter(id, orders, is_show, is_delete, created_time, updated_time, chapter, name, summary, pub_date, course_id) VALUES (1, 1, 1, 0, &#x27;2019-07-14 13:58:34.867005&#x27;, &#x27;2019-07-14 14:00:58.276541&#x27;, 1, &#x27;计算机原理&#x27;, &#x27;&#x27;, &#x27;2019-07-14&#x27;, 1);INSERT INTO luffy_course_chapter(id, orders, is_show, is_delete, created_time, updated_time, chapter, name, summary, pub_date, course_id) VALUES (2, 2, 1, 0, &#x27;2019-07-14 13:58:48.051543&#x27;, &#x27;2019-07-14 14:01:22.024206&#x27;, 2, &#x27;环境搭建&#x27;, &#x27;&#x27;, &#x27;2019-07-14&#x27;, 1);INSERT INTO luffy_course_chapter(id, orders, is_show, is_delete, created_time, updated_time, chapter, name, summary, pub_date, course_id) VALUES (3, 3, 1, 0, &#x27;2019-07-14 13:59:09.878183&#x27;, &#x27;2019-07-14 14:01:40.048608&#x27;, 1, &#x27;项目创建&#x27;, &#x27;&#x27;, &#x27;2019-07-14&#x27;, 2);INSERT INTO luffy_course_chapter(id, orders, is_show, is_delete, created_time, updated_time, chapter, name, summary, pub_date, course_id) VALUES (4, 4, 1, 0, &#x27;2019-07-14 13:59:37.448626&#x27;, &#x27;2019-07-14 14:01:58.709652&#x27;, 1, &#x27;Linux环境创建&#x27;, &#x27;&#x27;, &#x27;2019-07-14&#x27;, 3); 3.5 课时表数据1234567891011INSERT INTO luffy_course_Section(id, is_show, is_delete, created_time, updated_time, name, orders, section_type, section_link, duration, pub_date, free_trail, chapter_id) VALUES (1, 1, 0, &#x27;2019-07-14 14:02:33.779098&#x27;, &#x27;2019-07-14 14:02:33.779135&#x27;, &#x27;计算机原理上&#x27;, 1, 2, NULL, NULL, &#x27;2019-07-14 14:02:33.779193&#x27;, 1, 1);INSERT INTO luffy_course_Section(id, is_show, is_delete, created_time, updated_time, name, orders, section_type, section_link, duration, pub_date, free_trail, chapter_id) VALUES (2, 1, 0, &#x27;2019-07-14 14:02:56.657134&#x27;, &#x27;2019-07-14 14:02:56.657173&#x27;, &#x27;计算机原理下&#x27;, 2, 2, NULL, NULL, &#x27;2019-07-14 14:02:56.657227&#x27;, 1, 1);INSERT INTO luffy_course_Section(id, is_show, is_delete, created_time, updated_time, name, orders, section_type, section_link, duration, pub_date, free_trail, chapter_id) VALUES (3, 1, 0, &#x27;2019-07-14 14:03:20.493324&#x27;, &#x27;2019-07-14 14:03:52.329394&#x27;, &#x27;环境搭建上&#x27;, 1, 2, NULL, NULL, &#x27;2019-07-14 14:03:20.493420&#x27;, 0, 2);INSERT INTO luffy_course_Section(id, is_show, is_delete, created_time, updated_time, name, orders, section_type, section_link, duration, pub_date, free_trail, chapter_id) VALUES (4, 1, 0, &#x27;2019-07-14 14:03:36.472742&#x27;, &#x27;2019-07-14 14:03:36.472779&#x27;, &#x27;环境搭建下&#x27;, 2, 2, NULL, NULL, &#x27;2019-07-14 14:03:36.472831&#x27;, 0, 2);INSERT INTO luffy_course_Section(id, is_show, is_delete, created_time, updated_time, name, orders, section_type, section_link, duration, pub_date, free_trail, chapter_id) VALUES (5, 1, 0, &#x27;2019-07-14 14:04:19.338153&#x27;, &#x27;2019-07-14 14:04:19.338192&#x27;, &#x27;web项目的创建&#x27;, 1, 2, NULL, NULL, &#x27;2019-07-14 14:04:19.338252&#x27;, 1, 3);INSERT INTO luffy_course_Section(id, is_show, is_delete, created_time, updated_time, name, orders, section_type, section_link, duration, pub_date, free_trail, chapter_id) VALUES (6, 1, 0, &#x27;2019-07-14 14:04:52.895855&#x27;, &#x27;2019-07-14 14:04:52.895890&#x27;, &#x27;Linux的环境搭建&#x27;, 1, 2, NULL, NULL, &#x27;2019-07-14 14:04:52.895942&#x27;, 1, 4); 4 课程分类接口路由12345678910111213# http://127.0.0.1:8000/api/v1/course/category/from django.urls import path, includefrom rest_framework.routers import SimpleRouterfrom .views import CourseCategoryViewrouter = SimpleRouter()router.register(&#x27;category&#x27;, CourseCategoryView, &#x27;category&#x27;)urlpatterns = [ path(&#x27;&#x27;, include(router.urls)),] 视图类12345678910from django.shortcuts import render# Create your views here.from .models import CourseCategoryfrom .serializer import CourseCategorySerializerfrom rest_framework.viewsets import GenericViewSetfrom rest_framework.mixins import ListModelMixinclass CourseCategoryView(GenericViewSet,ListModelMixin): queryset = CourseCategory.objects.all().filter(is_delete=False,is_show=True).order_by(&#x27;orders&#x27;) serializer_class =CourseCategorySerializer 序列化类123456789from rest_framework import serializersfrom .models import CourseCategoryclass CourseCategorySerializer(serializers.ModelSerializer): class Meta: model = CourseCategory fields = [&#x27;id&#x27;, &#x27;name&#x27;] 4 课程列表接口路由1router.register(&#x27;actual&#x27;, CourseView, &#x27;actual&#x27;) 序列化类12345678910111213141516171819202122232425262728293031class TeacherSerializer(serializers.ModelSerializer): class Meta: model = Teacher fields = (&#x27;id&#x27;, &#x27;name&#x27;, &#x27;role_name&#x27;, &#x27;title&#x27;, &#x27;signature&#x27;, &#x27;image&#x27;, &#x27;brief&#x27;)class CourseSerializer(serializers.ModelSerializer): teacher = TeacherSerializer() # 子序列化，单单条数据，直接子序列化 class Meta: model = Course # fields = [&#x27;id&#x27;, &#x27;name&#x27;] # 这里要写很多，自定义字段 fields = [ &#x27;id&#x27;, &#x27;name&#x27;, &#x27;course_img&#x27;, &#x27;brief&#x27;, # 课程介绍---&gt;后面课程详情使用同一个序列化类 &#x27;attachment_path&#x27;, # 课件 &#x27;pub_sections&#x27;, # 发布的课时数 &#x27;price&#x27;, # 价格 &#x27;students&#x27;, # 学习人数 &#x27;period&#x27;, # 学习周期 &#x27;sections&#x27;, # 总课时数 &#x27;course_type_name&#x27;, # choice字段---》表模型中写 &#x27;level_name&#x27;, # choice字段---》表模型中写 &#x27;status_name&#x27;, # choice字段---》表模型中写 &#x27;teacher&#x27;, # 表模型中写，序列化类中写，子序列化 &#x27;section_list&#x27;, # 表模型中写 -章节---&gt;Course表中没有---》重写：序列类写，表模型中写 ] 视图类12345678910class CourseView(GenericViewSet, ListModelMixin): queryset = Course.objects.all().filter(is_delete=False, is_show=True).order_by(&#x27;orders&#x27;) serializer_class = CourseSerializer # 加入分页---》随着课程越来越多，要分页 pagination_class = CommonPageNumberPagination # 加入排序 filter_backends = [DjangoFilterBackend, OrderingFilter] ordering_fields = [&#x27;price&#x27;, &#x27;students&#x27;] # 加入过滤---》不是按名字搜索的这种过滤，而是按课程分类过滤--》第三方django-filter filter_fields = [&#x27;course_category&#x27;] 表模型1234567891011121314151617181920212223242526272829303132333435363738394041#### course表模型@property # 返回课程类型的中文，不这么写，它是一个数字def course_type_name(self): return self.get_course_type_display()def level_name(self): return self.get_level_display()def status_name(self): return self.get_status_display()@propertydef section_list(self): sections = [] # 如果课时小于等于四条，返回总课时，如果大于4条，最多返回4条 # 第一步：通过课程拿到所有章节 # course_chapter_list=self.coursechapter_set.all() # 不需要 course_chapter_list = self.coursechapters.all() # 第二步：循环所有章节 for course_chapter in course_chapter_list: # 第三步：通过章节，拿到该章节的所有课时 course_section_list = course_chapter.coursesections.all() # 第四步：循环取出所有章节，追加到一个列表中，准备返回 for course_section in course_section_list: sections.append(&#123; &#x27;name&#x27;: course_section.name, &#x27;section_link&#x27;: course_section.section_link, &#x27;duration&#x27;: course_section.duration, &#x27;free_trail&#x27;: course_section.free_trail, &#125;) if len(sections) == 4: return sections # 在for循环外层 return sections ### Teacher表模型def role_name(self): return self.get_role_display() 分页类12345678from rest_framework.pagination import PageNumberPaginationclass CommonPageNumberPagination(PageNumberPagination): page_size = 2 page_query_param = &#x27;page&#x27; page_size_query_param = &#x27;size&#x27; max_page_size = 5 5 课程页面前后端调通123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519&lt;template&gt; &lt;div class=&quot;course&quot;&gt; &lt;Header&gt;&lt;/Header&gt; &lt;div class=&quot;main&quot;&gt; &lt;!-- 筛选条件 --&gt; &lt;div class=&quot;condition&quot;&gt; &lt;ul class=&quot;cate-list&quot;&gt; &lt;li class=&quot;title&quot;&gt;课程分类:&lt;/li&gt; &lt;li :class=&quot;filter.course_category==0?&#x27;this&#x27;:&#x27;&#x27;&quot; @click=&quot;filter.course_category=0&quot;&gt;全部&lt;/li&gt; &lt;li :class=&quot;filter.course_category==category.id?&#x27;this&#x27;:&#x27;&#x27;&quot; v-for=&quot;category in category_list&quot; @click=&quot;filter.course_category=category.id&quot; :key=&quot;category.name&quot;&gt;&#123;&#123;category.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;ordering&quot;&gt; &lt;ul&gt; &lt;li class=&quot;title&quot;&gt;筛&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;选:&lt;/li&gt; &lt;li class=&quot;default&quot; :class=&quot;(filter.ordering==&#x27;id&#x27; || filter.ordering==&#x27;-id&#x27;)?&#x27;this&#x27;:&#x27;&#x27;&quot; @click=&quot;filter.ordering=&#x27;-id&#x27;&quot;&gt;默认 &lt;/li&gt; &lt;li class=&quot;hot&quot; :class=&quot;(filter.ordering==&#x27;students&#x27; || filter.ordering==&#x27;-students&#x27;)?&#x27;this&#x27;:&#x27;&#x27;&quot; @click=&quot;filter.ordering=(filter.ordering==&#x27;-students&#x27;?&#x27;students&#x27;:&#x27;-students&#x27;)&quot;&gt;人气 &lt;/li&gt; &lt;li class=&quot;price&quot; :class=&quot;filter.ordering==&#x27;price&#x27;?&#x27;price_up this&#x27;:(filter.ordering==&#x27;-price&#x27;?&#x27;price_down this&#x27;:&#x27;&#x27;)&quot; @click=&quot;filter.ordering=(filter.ordering==&#x27;-price&#x27;?&#x27;price&#x27;:&#x27;-price&#x27;)&quot;&gt;价格 &lt;/li&gt; &lt;/ul&gt; &lt;p class=&quot;condition-result&quot;&gt;共&#123;&#123;course_total&#125;&#125;个课程&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 课程列表 --&gt; &lt;div class=&quot;course-list&quot;&gt; &lt;div class=&quot;course-item&quot; v-for=&quot;course in course_list&quot; :key=&quot;course.name&quot;&gt; &lt;div class=&quot;course-image&quot;&gt; &lt;img :src=&quot;course.course_img&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;course-info&quot;&gt; &lt;h3&gt; &lt;router-link :to=&quot;&#x27;/free/detail/&#x27;+course.id&quot;&gt;&#123;&#123;course.name&#125;&#125;&lt;/router-link&gt; &lt;span&gt;&lt;img src=&quot;@/assets/img/avatar1.svg&quot; alt=&quot;&quot;&gt;&#123;&#123;course.students&#125;&#125;人已加入学习&lt;/span&gt;&lt;/h3&gt; &lt;p class=&quot;teather-info&quot;&gt; &#123;&#123;course.teacher.name&#125;&#125; &#123;&#123;course.teacher.title&#125;&#125; &#123;&#123;course.teacher.signature&#125;&#125; &lt;span v-if=&quot;course.sections&gt;course.pub_sections&quot;&gt;共&#123;&#123;course.sections&#125;&#125;课时/已更新&#123;&#123;course.pub_sections&#125;&#125;课时&lt;/span&gt; &lt;span v-else&gt;共&#123;&#123;course.sections&#125;&#125;课时/更新完成&lt;/span&gt; &lt;/p&gt; &lt;ul class=&quot;section-list&quot;&gt; &lt;li v-for=&quot;(section, key) in course.section_list&quot; :key=&quot;section.name&quot;&gt;&lt;span class=&quot;section-title&quot;&gt;0&#123;&#123;key+1&#125;&#125; | &#123;&#123;section.name&#125;&#125;&lt;/span&gt; &lt;span class=&quot;free&quot; v-if=&quot;section.free_trail&quot;&gt;免费&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;pay-box&quot;&gt; &lt;div v-if=&quot;course.discount_type&quot;&gt; &lt;span class=&quot;discount-type&quot;&gt;&#123;&#123;course.discount_type&#125;&#125;&lt;/span&gt; &lt;span class=&quot;discount-price&quot;&gt;￥&#123;&#123;course.real_price&#125;&#125;元&lt;/span&gt; &lt;span class=&quot;original-price&quot;&gt;原价：&#123;&#123;course.price&#125;&#125;元&lt;/span&gt; &lt;/div&gt; &lt;span v-else class=&quot;discount-price&quot;&gt;￥&#123;&#123;course.price&#125;&#125;元&lt;/span&gt; &lt;span class=&quot;buy-now&quot;&gt;立即购买&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;course_pagination block&quot;&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page.sync=&quot;filter.page&quot; :page-sizes=&quot;[2, 3, 5, 10]&quot; :page-size=&quot;filter.page_size&quot; layout=&quot;sizes, prev, pager, next&quot; :total=&quot;course_total&quot;&gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;/div&gt; &lt;Footer&gt;&lt;/Footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Header from &quot;@/components/Header&quot; import Footer from &quot;@/components/Footer&quot; export default &#123; name: &quot;Course&quot;, data() &#123; return &#123; category_list: [], // 课程分类列表 course_list: [], // 课程列表 course_total: 0, // 当前课程的总数量 filter: &#123; course_category: 0, // 当前用户选择的课程分类，刚进入页面默认为全部，值为0 ordering: &quot;-id&quot;, // 数据的排序方式，默认值是-id，表示对于id进行降序排列 page_size: 2, // 单页数据量 page: 1, &#125; &#125; &#125;, created() &#123; this.get_category(); // 加载课程分类 this.get_course(); // 加载科创城 &#125;, components: &#123; Header, Footer, &#125;, watch: &#123; &quot;filter.course_category&quot;: function () &#123; this.filter.page = 1; this.get_course(); &#125;, &quot;filter.ordering&quot;: function () &#123; this.get_course(); &#125;, &quot;filter.page_size&quot;: function () &#123; this.get_course(); &#125;, &quot;filter.page&quot;: function () &#123; this.get_course(); &#125; &#125;, methods: &#123; handleSizeChange(val) &#123; // 每页数据量发生变化时执行的方法 this.filter.page = 1; this.filter.page_size = val; &#125;, handleCurrentChange(val) &#123; // 页码发生变化时执行的方法 this.filter.page = val; &#125;, get_category() &#123; // 获取课程分类信息 this.$axios.get(`$&#123;this.$settings.base_url&#125;course/category/`).then(response =&gt; &#123; this.category_list = response.data; &#125;).catch(() =&gt; &#123; this.$message(&#123; message: &quot;获取课程分类信息有误，请联系客服工作人员&quot;, &#125;) &#125;) &#125;, get_course() &#123; // 排序 let filters = &#123; ordering: this.filter.ordering, // 排序 &#125;; // 判决是否进行分类课程的展示 if (this.filter.course_category &gt; 0) &#123; filters.course_category = this.filter.course_category; &#125; // 设置单页数据量 if (this.filter.page_size &gt; 0) &#123; filters.page_size = this.filter.page_size; &#125; else &#123; filters.page_size = 5; &#125; // 设置当前页码 if (this.filter.page &gt; 1) &#123; filters.page = this.filter.page; &#125; else &#123; filters.page = 1; &#125; // 获取课程列表信息 this.$axios.get(`$&#123;this.$settings.base_url&#125;course/actual/`, &#123; params: filters &#125;).then(response =&gt; &#123; // console.log(response.data); this.course_list = response.data.results; this.course_total = response.data.count; // console.log(this.course_list); &#125;).catch(() =&gt; &#123; this.$message(&#123; message: &quot;获取课程信息有误，请联系客服工作人员&quot; &#125;) &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .course &#123; background: #f6f6f6; &#125; .course .main &#123; width: 1100px; margin: 35px auto 0; &#125; .course .condition &#123; margin-bottom: 35px; padding: 25px 30px 25px 20px; background: #fff; border-radius: 4px; box-shadow: 0 2px 4px 0 #f0f0f0; &#125; .course .cate-list &#123; border-bottom: 1px solid #333; border-bottom-color: rgba(51, 51, 51, .05); padding-bottom: 18px; margin-bottom: 17px; &#125; .course .cate-list::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course .cate-list li &#123; float: left; font-size: 16px; padding: 6px 15px; line-height: 16px; margin-left: 14px; position: relative; transition: all .3s ease; cursor: pointer; color: #4a4a4a; border: 1px solid transparent; /* transparent 透明 */ &#125; .course .cate-list .title &#123; color: #888; margin-left: 0; letter-spacing: .36px; padding: 0; line-height: 28px; &#125; .course .cate-list .this &#123; color: #ffc210; border: 1px solid #ffc210 !important; border-radius: 30px; &#125; .course .ordering::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course .ordering ul &#123; float: left; &#125; .course .ordering ul::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course .ordering .condition-result &#123; float: right; font-size: 14px; color: #9b9b9b; line-height: 28px; &#125; .course .ordering ul li &#123; float: left; padding: 6px 15px; line-height: 16px; margin-left: 14px; position: relative; transition: all .3s ease; cursor: pointer; color: #4a4a4a; &#125; .course .ordering .title &#123; font-size: 16px; color: #888; letter-spacing: .36px; margin-left: 0; padding: 0; line-height: 28px; &#125; .course .ordering .this &#123; color: #ffc210; &#125; .course .ordering .price &#123; position: relative; &#125; .course .ordering .price::before, .course .ordering .price::after &#123; cursor: pointer; content: &quot;&quot;; display: block; width: 0px; height: 0px; border: 5px solid transparent; position: absolute; right: 0; &#125; .course .ordering .price::before &#123; border-bottom: 5px solid #aaa; margin-bottom: 2px; top: 2px; &#125; .course .ordering .price::after &#123; border-top: 5px solid #aaa; bottom: 2px; &#125; .course .ordering .price_up::before &#123; border-bottom-color: #ffc210; &#125; .course .ordering .price_down::after &#123; border-top-color: #ffc210; &#125; .course .course-item:hover &#123; box-shadow: 4px 6px 16px rgba(0, 0, 0, .5); &#125; .course .course-item &#123; width: 1100px; background: #fff; padding: 20px 30px 20px 20px; margin-bottom: 35px; border-radius: 2px; cursor: pointer; box-shadow: 2px 3px 16px rgba(0, 0, 0, .1); /* css3.0 过渡动画 hover 事件操作 */ transition: all .2s ease; &#125; .course .course-item::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; /* 顶级元素 父级元素 当前元素&#123;&#125; */ .course .course-item .course-image &#123; float: left; width: 423px; height: 210px; margin-right: 30px; &#125; .course .course-item .course-image img &#123; max-width: 100%; max-height: 210px; &#125; .course .course-item .course-info &#123; float: left; width: 596px; &#125; .course-item .course-info h3 a &#123; font-size: 26px; color: #333; font-weight: normal; margin-bottom: 8px; &#125; .course-item .course-info h3 span &#123; font-size: 14px; color: #9b9b9b; float: right; margin-top: 14px; &#125; .course-item .course-info h3 span img &#123; width: 11px; height: auto; margin-right: 7px; &#125; .course-item .course-info .teather-info &#123; font-size: 14px; color: #9b9b9b; margin-bottom: 14px; padding-bottom: 14px; border-bottom: 1px solid #333; border-bottom-color: rgba(51, 51, 51, .05); &#125; .course-item .course-info .teather-info span &#123; float: right; &#125; .course-item .section-list::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course-item .section-list li &#123; float: left; width: 44%; font-size: 14px; color: #666; padding-left: 22px; /* background: url(&quot;路径&quot;) 是否平铺 x轴位置 y轴位置 */ background: url(&quot;/src/assets/img/play-icon-gray.svg&quot;) no-repeat left 4px; margin-bottom: 15px; &#125; .course-item .section-list li .section-title &#123; /* 以下3句，文本内容过多，会自动隐藏，并显示省略符号 */ text-overflow: ellipsis; overflow: hidden; white-space: nowrap; display: inline-block; max-width: 200px; &#125; .course-item .section-list li:hover &#123; background-image: url(&quot;/src/assets/img/play-icon-yellow.svg&quot;); color: #ffc210; &#125; .course-item .section-list li .free &#123; width: 34px; height: 20px; color: #fd7b4d; vertical-align: super; margin-left: 10px; border: 1px solid #fd7b4d; border-radius: 2px; text-align: center; font-size: 13px; white-space: nowrap; &#125; .course-item .section-list li:hover .free &#123; color: #ffc210; border-color: #ffc210; &#125; .course-item &#123; position: relative; &#125; .course-item .pay-box &#123; position: absolute; bottom: 20px; width: 600px; &#125; .course-item .pay-box::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .course-item .pay-box .discount-type &#123; padding: 6px 10px; font-size: 16px; color: #fff; text-align: center; margin-right: 8px; background: #fa6240; border: 1px solid #fa6240; border-radius: 10px 0 10px 0; float: left; &#125; .course-item .pay-box .discount-price &#123; font-size: 24px; color: #fa6240; float: left; &#125; .course-item .pay-box .original-price &#123; text-decoration: line-through; font-size: 14px; color: #9b9b9b; margin-left: 10px; float: left; margin-top: 10px; &#125; .course-item .pay-box .buy-now &#123; width: 120px; height: 38px; background: transparent; color: #fa6240; font-size: 16px; border: 1px solid #fd7b4d; border-radius: 3px; transition: all .2s ease-in-out; float: right; text-align: center; line-height: 38px; position: absolute; right: 0; bottom: 5px; &#125; .course-item .pay-box .buy-now:hover &#123; color: #fff; background: #ffc210; border: 1px solid #ffc210; &#125; .course .course_pagination &#123; margin-bottom: 60px; text-align: center; &#125;&lt;/style&gt; 6 课程详情接口7 课程详情页面123456789101112131415#课程详情页取出课程id号this.course_id=this.$route.params.id// console.log(this.$route) // 当前路径对象// console.log(this.$router)// 路由对象# 当前页面需要视频播放视频---》视频播放组件cnpm install vue-video-player# main.js中配置// vue-video播放器require(&#x27;video.js/dist/video-js.css&#x27;);require(&#x27;vue-video-player/src/custom-theme.css&#x27;);import VideoPlayer from &#x27;vue-video-player&#x27;Vue.use(VideoPlayer); 1# 讲到哪写到哪","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"09、celery：介绍、架构图、快速使用、包目录结构、执行（异步/延迟/定时）任务、django使用celery、定时更新轮播图接口、轮播图接口加缓存与坑","slug":"luffy_day09","date":"2021-07-28T06:04:09.000Z","updated":"2022-05-14T05:29:39.725Z","comments":true,"path":"2021/07/28/luffy_day09/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day09/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031323334# redis的连接 -redis-cli：官方提供，类似于 mysql -图形化界面客户端:第三方，类似于Navicat -python代码连接：第三方包，本质使用不同语言写了socket的客户端 -普通连接 -连接池，防止连接数过多 -django的orm没有连接池---》并发量很高，连接mysql的连接数会过多，导致mysql崩溃 # 5 大数据类型# redis 的字符串操作 -get set strlen(字节) incr # redis的hash操作hset hget hlen hexists# redis的列表操作lpush lpop linsert lrem llen blpop# 通用操作 -type expire delete exists -dbsize:查看有多少key，可以放心使用 -keys * :返回所有key ,谨慎使用 -flushdb：不要用，清空这个库 # 管道---》开启管道---》以后命令都先放到管道中---》执行execute，才真正的把命令一次性执行# 管道只针对于单实例的reids，集群后，不支持管道# 通过管道实现事务---》redis支持事务吗？不支持，但是通过管道来模拟# django中使用redis -方式一：自己写 -方式二:django-redis -配置文件中配置 -from django_redis import get_redis_connection -直接通过django的缓存来使用redis cache.set(key,value,10) -django 缓存的底层实现---》把python中的对象，通过pickle序列化后---》通过配置缓存到不同位置(内存中，文件中，redis中) 1 celery介绍，架构123456789101112131415161718192021222324252627282930313233# celery: 分布式(放在多台机器) 的 异步任务 框架Celery是一个简单、灵活且可靠的，处理大量消息的分布式系统Celery is a project with minimal funding, so we don’t support Microsoft Windows. Please don’t open any issues related to that platform.# celery:能做什么事，解决什么问题？ -异步任务---》项目中同步的操作，可以通过celery把它做成异步 -延迟任务---》隔一会再执行任务 -定时任务---》每隔多长时间干什么事 -如果你的项目仅仅想做定时任务，没有必要使用celery，使用apscheduler -https://www.cnblogs.com/xiao-xue-di/p/14081790.html # 大白话理解celery&quot;&quot;&quot;1）可以不依赖任何服务器，通过自身命令，启动服务2）celery服务为为其他项目服务提供异步解决任务需求的注：会有两个服务同时运行，一个是项目服务(django)，一个是celery服务，项目服务将需要异步处理的任务交给celery服务，celery就会在需要时异步完成项目的需求人是一个独立运行的服务 | 医院也是一个独立运行的服务 正常情况下，人可以完成所有健康情况的动作，不需要医院的参与；但当人生病时，就会被医院接收，解决人生病问题 人生病的处理方案交给医院来解决，所有人不生病时，医院独立运行，人生病时，医院就来解决人生病的需求&quot;&quot;&quot;# 中间件：不是django中间件 -中间件概念非常大 -数据库中间件：应用程序和数据直接有一个东西 -服务器中间件： web服务和浏览器之间有个东西:nginx -消息队列中间件：程序和程序之间：redis，rabbitmq# celery架构图 -broker:任务中间件，消息队列中间件，存储任务，celery本身不提供，需要借助第三方：redis，rabbitmq.. -worker：任务执行单元，真正指向任务的进程，celery提供的 -backend:结果存储，任务执行结果存在某个地方，借助于第三方：redis 2 celery 快速使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# pip install celery####### 第一步：写一个py文件，celery_task.py---》app实例化，写任务from celery import Celery# 消息中间件broker=&#x27;redis://127.0.0.1:6379/2&#x27;# 结果存储backend=&#x27;redis://127.0.0.1:6379/1&#x27;# 实例化得到对象app=Celery(&#x27;test&#x27;,broker=broker,backend=backend)# 写任务---》使用装饰器装饰一下变成celery的任务@app.taskdef add(a,b): import time time.sleep(1) return a+b ####### 第二步：提交任务，应该是另一个服务，咱么写了一个py脚本提交from celery_task import add# res=add(7,8) # 同步调用,一直等结果给我# print(res)# 异步调用res=add.apply_async(args=[7,8]) # 把任务提交到redis中的消息队列中了，任务中间件，消息队列中间件print(res) # 任务id号：56d48462-6681-4e3b-b91c-5a993e03b5bc##### 第三步：任务就被提交到redis中了，等待worker执行该任务，启动worker# 启动worker执行任务---》使用命令启动# 非windows命令：celery -A celery_task worker -l info# windows：pip3 install eventletcelery -A celery_task worker -l info -P eventlet#### 第四步：任务被celery执行完了，结果放到redis中了，查询结果，使用代码 AsyncResult# 通过代码把结果取出来from celery_task import app # 借助于appfrom celery.result import AsyncResult # 导入一个类，来查询结果id = &#x27;56d48462-6681-4e3b-b91c-5a993e03b5bc&#x27;if __name__ == &#x27;__main__&#x27;: res = AsyncResult(id=id, app=app) # 根据id，去哪个app中找哪个任务， if res.successful(): # 执行成功 result = res.get() print(&#x27;任务执行成功&#x27;) print(result) # 15 elif res.failed(): print(&#x27;任务失败&#x27;) elif res.status == &#x27;PENDING&#x27;: print(&#x27;任务等待中被执行&#x27;) elif res.status == &#x27;RETRY&#x27;: print(&#x27;任务异常后正在重试&#x27;) elif res.status == &#x27;STARTED&#x27;: print(&#x27;任务已经开始被执行&#x27;) 1234567891011# 借助于celery的异步秒杀场景分析# 原始同步场景100个人，秒杀3个商品---&gt;100个人在浏览器等着开始---》一旦开始---&gt;瞬间100个人同时发送秒杀请求到后端----》----&gt;假设秒杀函数执行2s钟---》100个请求在2s内，一直跟后端连着，假设我的并发量是100，这两秒钟，其他任何人都访问不了了假设 150人来秒杀---》最多能承受100个人，50个人就请求不了---》不友好# 异步场景100个人，秒杀3个商品---&gt;100个人在浏览器等着开始---》一旦开始---&gt;瞬间100个人同时发送秒杀请求到后端----》----&gt;假设秒杀函数执行2s钟---》当前100个请求，过来，使用celery提交100个任务，请求立马返回---&gt;这样的话，2s内能提交特别多的任务，可以接收特别多人发的请求---》后台使用worker慢慢的执行秒杀任务---》多起几个worker---》过了一会，所有提交的任务都执行完了提交完任务，返回前端---》前端使用个动态图片盖住页面，显示您正在排队，每个2s钟，向后端发送一次ajax请求，带着id号，查询结果是否完成，如果没完成---》再等2s钟---&gt;如果秒杀成功了，显示恭喜您，成了---》如果没有成功，显示很遗憾，没有秒到# 尝试写写 3 celery包结构123456789-celery_task # 包 -__init__.py -celery.py # 写app的py文件 -home_task.py # 任务1 -order_task.py # 任务2 -user_task.py # 任务3--------------下面这些，跟上面可能在不同项目中---------------- add_task.py # 提交任务，django中提交get_result.py # 查询结果，django中查询 3.1 celery.py12345678910111213141516from celery import Celery# 消息中间件broker = &#x27;redis://127.0.0.1:6379/2&#x27;# 结果存储backend = &#x27;redis://127.0.0.1:6379/1&#x27;# 实例化得到对象app = Celery(&#x27;test&#x27;, broker=broker, backend=backend, include=[ &#x27;celery_task.home_task&#x27;, &#x27;celery_task.order_task&#x27;, &#x27;celery_task.user_task&#x27;,])# 写好include，会去相应的py下检索任务，这些任务都被app管理# 以后任务不写在这里了，放到单独的py文件中 3.2 user_task.py123456from .celery import app@app.taskdef send_sms(phone): print(&#x27;手机号：%s，发送成功&#x27; % phone) return True 3.3 add_task1234from celery_task.user_task import send_smsres=send_sms.apply_async(args=[&#x27;1872637484872&#x27;])print(res) 3.4 get_result12345678910111213141516171819# 通过代码把结果取出来from celery_task.celery import app # 借助于appfrom celery.result import AsyncResult # 导入一个类，来查询结果id = &#x27;d9692e2a-1e1f-436c-b58f-b25484cc5c56&#x27;if __name__ == &#x27;__main__&#x27;: res = AsyncResult(id=id, app=app) # 根据id，去哪个app中找哪个任务， if res.successful(): # 执行成功 result = res.get() print(&#x27;任务执行成功&#x27;) print(result) # 15 elif res.failed(): print(&#x27;任务失败&#x27;) elif res.status == &#x27;PENDING&#x27;: print(&#x27;任务等待中被执行&#x27;) elif res.status == &#x27;RETRY&#x27;: print(&#x27;任务异常后正在重试&#x27;) elif res.status == &#x27;STARTED&#x27;: print(&#x27;任务已经开始被执行&#x27;) 4 celery执行异步任务12# 任务名.delay(参数，参数)# 异步执行 5 celery执行延迟任务12345from datetime import datetime, timedeltaeta = datetime.utcnow() + timedelta(seconds=10) # 5s后时间# eta = datetime.utcnow() + timedelta(days=3) # 3天后后时间res = send_sms.apply_async(args=[&#x27;17777777&#x27;], eta=eta)print(res) 6 celery执行定时任务12345678910111213141516171819202122232425262728###### 第一步:在app中写入定时任务app.conf.timezone = &#x27;Asia/Shanghai&#x27;# 是否使用UTCapp.conf.enable_utc = False### celery的配置信息---结束####### 定时任务from datetime import timedeltafrom celery.schedules import crontabapp.conf.beat_schedule = &#123; &#x27;send_sms_5&#x27;: &#123; &#x27;task&#x27;: &#x27;celery_task.user_task.send_sms&#x27;, # 哪个任务 &#x27;schedule&#x27;: timedelta(seconds=5), # 每5s干一次 # &#x27;schedule&#x27;: crontab(hour=8, day_of_week=1), # 每周一早八点 &#x27;args&#x27;: (&#x27;18988377473&#x27;,), &#125;,&#125;###### 第一步:启动workercelery -A celery_task worker -l info#### 第三步：启动beat 【【【【注意路径】】】】】celery -A celery_task beat -l info### 本质是beat 5s钟提交一次任务，worker执行 7 django中使用celery1234567891011121314151617181920# 第一步：把包copy到项目路径下luffy_api celery_task user_task.py order_task.py home_task.py celery.py __init__.py # 第二步：在要提交任务的地方，导入执行from celery_task.user_task import create_userclass TestView(APIView): def get(self, requeste): create_user.delay(&#x27;12222222&#x27;,&#x27;lqznb&#x27;,&#x27;lqz12345&#x27;) return Response(&#x27;用户创建任务已经提交&#x27;) # 第三步：启动worker# 公司里的情况，把task放到了不同app中 8 定时更新轮播图接口8.1 轮播图接口加缓存1234567891011121314151617181920212223242526# 首页轮播图---》去mysql中查的---》假设瞬间10w访问咱们首页----》数据库会查询10w次，返回数据---》但是实际上，咱们轮播图基本不变# 我们优化一下---》对轮播图接口做个缓存---》第一次访问查询mysql，放到reids中，以后都从redis中取，如果redis中没有，再去数据库中查----》好处在于，对mysql压力小，redis性能高，# 以后如果接口响应慢，第一想法先加缓存：把查出来的数据缓存到redis中，再来请求，先从redis中查，如果没有，再去mysql查，然后在redis缓存一份class BannerView(GenericViewSet,ListModelMixin,UpdateModelMixin):# class BannerView(GenericViewSet,ListModelMixin): # 获取所有接口-list，自动生成路由 # qs对象可以像列表一样，切片 queryset = Banner.objects.filter(is_delete=False,is_show=True).order_by(&#x27;orders&#x27;)[:settings.BANNER_COUNT] serializer_class =BannerSerializer def list(self, request, *args, **kwargs): # 重写list # 逻辑是，先去redis中查询，如果有，直接返回，如果没有，再执行下面super().list这句，这句是去数据库中查 banner_list=cache.get(&#x27;banner_list&#x27;) if banner_list: print(&#x27;走了缓存，很快很快&#x27;) return APIResponse(result=banner_list) else: print(&#x27;没走缓存比较慢&#x27;) res=super().list(request, *args, **kwargs) # 再缓存一份 cache.set(&#x27;banner_list&#x27;,res.data) return APIResponse(result=res.data) 8.1 加入缓存的坑12345678910111213141516# redis中有一份数据，mysql中有一份数据# 存在问题:mysql更新了，reids更新了么？# 专业名词叫：双写一致性问题 写入mysql，redis是否同步# 解决双写一致性问题 -第一：定时更新 10分钟更新一次缓存 -第二：写入mysql，删除缓存 -第三：写入mysql，更新缓存 # 三种解决方案，没有好于不好之说，只是看业务场景 -轮播图定时更新---》借助celery # 通过定时更新，解决双写一致性问题 12345678910@app.taskdef update_banner_list(): queryset = models.Banner.objects.filter(is_delete=False, is_show=True).order_by(&#x27;-orders&#x27;)[:settings.BANNER_COUNT] banner_list = serializer.BannerSerializer(queryset, many=True).data # 拿不到request对象，所以头像的连接base_url要自己组装 for banner in banner_list: banner[&#x27;image&#x27;] = &#x27;http://127.0.0.1:8000%s&#x27; % banner[&#x27;image&#x27;] cache.set(&#x27;banner_list&#x27;, banner_list, 86400) return True 1234讲到哪写到哪秒杀场景---》写一下","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"08、redis：Python连接redis、字符串操作、hash操作、列表操作、其他通用操作、管道、Django使用redis","slug":"luffy_day08","date":"2021-07-28T06:04:08.000Z","updated":"2022-05-14T05:27:05.012Z","comments":true,"path":"2021/07/28/luffy_day08/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day08/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 短信登陆接口 -跟之前的多方式登陆大致相同 -视图类中 self.action 如果使用action装饰了，它就是函数名，如果不用action装饰，它是自动生成路由配的action的值 -xxView.as_view(&#123;&#x27;get&#x27;:&#x27;xx&#x27;,post:&#x27;yy&#x27;&#125;) -重写get_serializer_class,根据不同的action，返回不同的序列化类 # 短信注册接口 -视图类中不怎么写代码，主要逻辑都在序列化类中 -序列化类中对字段进行校验---》字典自己的，局部钩子，全局钩子 -重写create---》存的是auth的user表，密码是密文---》不能直接create，是明文 -以后你自己定义的表，但是想用auth的密文密码功能，你如何做？ from django.contrib.auth.hashers import make_password res=make_password(&#x27;lqz12345&#x27;) print(res) -以后密码存到数据库要加密 -万一数据库泄露了，别人拿到密文，明文密码不知道，它就登陆不进来 -至于登陆的时候(http传输)，要不要加密，看情况都可以 # 登陆注册前端 -js的判断，发送ajax请求 # redis -是什么？数据库，非关系型，nosql，key-value存储，value类型有5种，字符串，列表，字典，集合，有序集合 -数据结构---》变量，类型的组织结构 -算法---&gt;写程序的逻辑，排序，图，树。。 -纯内存存储，速度非常快，但是一断电数据就没了，但是可以持久化---》可以把内存中数据备份到硬盘 -应用场景 -缓存---》缓存数据库 -简单消息队列 -去重 -计数器 -redis为什么这么快？ -纯内存操作 -使用了高性能的网络模型，io多路复用，并发量的峰值 10w/s---》6w -你的项目并发量多少？ 1s内能处理的并发请求数 --》多加机器(多进程)，多进程，多线程，协程 -django项目没有开过进程，线程吧？没有，那他如何并发？1s内10个人访问/index---&gt;并不是django框架中做，而是符合wsgi协议的web服务器做，uwsgi/wsgiref---&gt;为什么项目上线要使用uwsgi，测试阶段使用wsgiref -django项目的并发量高低取决于，web服务器，uwsgi -正常业务平均下来，100--200，业务复杂一些 100以内 -双十一，30-40w笔/s -某个接口的并发量----》1.6w---&gt;麦当劳小程序 -软件指标：用户量：几百万用户，日活月活，几十万的日活----》1s内，同时有多少人在刷某个接口1w多的并发 -你们的项目百级别 -redis的安装 -win：找安装包一路下一步---》自动做成服务---》启动停止服务---》安装路径加入到环境变量 -mac，linux -源码编译--》安装 -服务端启动：redis-server mysqld -客户端启动：redis-cli mysql -图形化界面：rdb # 1 python连接redis123456789101112131415161718192021# 安装模块：pip install redis# django中有没有连接池？ -没有，django中一个请求就会创建一个mysql连接，django并发量不高，mysql能撑住 -想在django中使用连接池，有第三方：https://www.cnblogs.com/wangruixing/p/13030755.html # python实现单例的5种方式http://liuqingzheng.top/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E9%98%B6/19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%AE%9E%E6%88%98%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/ class Person: pass p1=Person() p2=Person() print(p1 is p2) # 以模块导入的方式实现单例# 什么是进程，线程，协程？ 123456789101112131415161718192021222324252627282930313233343536373839# from redis import Redis# 1 普通连接# conn = Redis(host=&quot;localhost&quot;,port=6379,db=0,password=None)# conn.set(&#x27;name&#x27;,&quot;lqz&quot;)# res=conn.get(&#x27;name&#x27;)# print(res)# 2 连接池连接（以模块导入的方式实现单例）# import redis# from redis_pool import POOL# # 第二步：从池中拿一个连接# conn=redis.Redis(connection_pool=POOL)# print(conn.get(&#x27;name&#x27;))# 多线程演示from threading import Threadimport redisimport timefrom redis_pool import POOL # 真报错吗？不会报错,def get_name(): conn=redis.Redis(connection_pool=POOL) print(conn.get(&#x27;name&#x27;))for i in range(10): t=Thread(target=get_name) t.start()time.sleep(2)&#x27;&#x27;&#x27;1 咱们这个py作为脚本运行，不能使用相对导入2 只能使用绝对导入3 从环境变量中开始到导起4 在pycharm中右键运行的脚本所在的目录，就会被加入到环境变量&#x27;&#x27;&#x27; 2 redis字符串操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# 各种锁：https://zhuanlan.zhihu.com/p/489305763&#x27;&#x27;&#x27;1 set(name, value, ex=None, px=None, nx=False, xx=False) ex，过期时间（秒） px，过期时间（毫秒） nx，如果设置为True，则只有name不存在时，当前set操作才执行,值存在，就修改不了，执行没效果 xx，如果设置为True，则只有name存在时，当前set操作才执行，值存在才能修改，值不存在，不会设置新值2 setnx(name, value)2 setex(name, value, time)3 psetex(name, time_ms, value)4 mset(*args, **kwargs)5 get(name)5 mget(keys, *args)6 getset(name, value)7 getrange(key, start, end)8 setrange(name, offset, value)9 setbit(name, offset, value)10 getbit(name, offset)11 bitcount(key, start=None, end=None)12 bitop(operation, dest, *keys)13 strlen(name)14 incr(self, name, amount=1)15 incrbyfloat(self, name, amount=1.0)16 decr(self, name, amount=1)17 append(key, value)&#x27;&#x27;&#x27;import redisconn=redis.Redis()# 1 set(name, value, ex=None, px=None, nx=False, xx=False)# conn.set(&#x27;age&#x27;,19)# ex，过期时间（秒）----&gt;过期时间# px，过期时间（毫秒） ----&gt;过期时间# conn.set(&#x27;wife&#x27;,&#x27;lyf&#x27;,ex=3)# nx，如果设置为True，则只有name不存在时，当前set操作才执行, 值存在，就修改不了，执行没效果# conn.set(&#x27;wife&#x27;,&#x27;dlrb&#x27;,nx=True)# xx，如果设置为True，则只有name存在时，当前set操作才执行，值存在才能修改，值不存在，不会设置新值# conn.set(&#x27;wife&#x27;,&#x27;dlrb&#x27;,xx=True)# 2 setnx(name, value)---&gt;等同于conn.set(&#x27;wife&#x27;,&#x27;dlrb&#x27;,nx=True)# 2 setex(name, value, time)---&gt;conn.set(&#x27;wife&#x27;,&#x27;lyf&#x27;,ex=3)# 3 psetex(name, time_ms, value)---&gt;conn.set(&#x27;wife&#x27;,&#x27;lyf&#x27;,px=3)# 4 mset(*args, **kwargs)--》批量设置# conn.mset(&#123;&#x27;name1&#x27;:&#x27;pyy&#x27;,&#x27;age1&#x27;:20&#125;)# 5 get(name)# print(conn.get(&#x27;age1&#x27;))# 5 mget(keys, *args)# print(conn.mget([&#x27;age1&#x27;,&#x27;age&#x27;]))# print(conn.mget(&#x27;name&#x27;,&#x27;age&#x27;,&#x27;age1&#x27;))# 6 getset(name, value)# print(conn.getset(&#x27;name&#x27;,&#x27;dsb&#x27;)) # 它跟get，再set有什么区别？# 7 getrange(key, start, end)# print(conn.getrange(&#x27;name&#x27;,0,1)) # 取字节 ，前闭后闭# 8 setrange(name, offset, value)# conn.setrange(&#x27;name&#x27;,1,&#x27;qqq&#x27;) # dsb---&gt;dqqq# 9 setbit(name, offset, value) ---》后面再聊---》独立用户统计---》用户量过亿---》日活# conn.setbit(&#x27;name&#x27;,1,0) # 改的是比特位，d 一个byte占8个比特位--》2进制---》10进制---》字符# 10 getbit(name, offset)# print(conn.getbit(&#x27;name&#x27;,1))# 11 bitcount(key, start=None, end=None)# print(conn.bitcount(&#x27;name&#x27;,0,1)) # 数字指的是字节，不是比特位# 13 strlen(name)# 字节(一个byte)和字符(中 ？ a 都是一个字符)# 面试题：mysql中utf8和utf8mb4有什么区别？# utf8---》不是咱们任务的utf-8，mysql字节的，两个字节表示一个字符---》生僻字，表示存不了# utf8mb4--》utf-8，最多4个字节表示一个字符---》存标签，存生僻字# print(conn.strlen(&#x27;name&#x27;)) # 字节--》9--》gbk编码一个中文占2个字节 utf-8编码 大部分一个中文占3个字节，生僻字可能占4# 14 incr(self, name, amount=1)---&gt;做计数器--》记录博客访问量--》博客表的文章上加个访问量字段，一旦有一个人访问，数字+1# conn.incr(&#x27;age&#x27;) # 不存在并发安全的问题---》redis6.0之前是单线程架构，并发访问操作，实际只排着队一个个来# 15 incrbyfloat(self, name, amount=1.0)# 16 decr(self, name, amount=1)# conn.decr(&#x27;age&#x27;)# 17 append(key, value)# conn.append(&#x27;name&#x27;,&#x27;nb&#x27;)# 记住：get set strlen 3 redis之hash操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#x27;&#x27;&#x27;1 hset(name, key, value)2 hmset(name, mapping)3 hget(name,key)4 hmget(name, keys, *args)5 hgetall(name)6 hlen(name)7 hkeys(name)8 hvals(name)9 hexists(name, key)10 hdel(name,*keys)11 hincrby(name, key, amount=1)12 hincrbyfloat(name, key, amount=1.0)13 hscan(name, cursor=0, match=None, count=None)14 hscan_iter(name, match=None, count=None)&#x27;&#x27;&#x27;import redisconn=redis.Redis()# 1 hset(name, key, value)# conn.hset(&quot;userinfo&quot;,&#x27;name&#x27;,&#x27;彭于晏&#x27;)# conn.hset(&quot;userinfo_01&quot;,mapping=&#123;&#x27;name&#x27;:&quot;刘亦菲&quot;,&#x27;age&#x27;:18&#125;)# 2 hmset(name, mapping)---》弃用了--&gt;直接使用hset即可# conn.hmset(&quot;userinfo_02&quot;,mapping=&#123;&#x27;name&#x27;:&quot;刘亦菲&quot;,&#x27;age&#x27;:18&#125;)# 3 hget(name,key)# print(str(conn.hget(&#x27;userinfo_01&#x27;,&#x27;name&#x27;),encoding=&#x27;utf-8&#x27;))# print(str(conn.hget(&#x27;userinfo_01&#x27;,&#x27;age&#x27;),encoding=&#x27;utf-8&#x27;))# 4 hmget(name, keys, *args)# print(conn.hmget(&#x27;userinfo_01&#x27;,[&#x27;name&#x27;,&#x27;age&#x27;]))# print(conn.hmget(&#x27;userinfo_01&#x27;,&#x27;name&#x27;,&#x27;age&#x27;))# 5 hgetall(name)---&gt;慎用，有可能数据量很大，会撑爆内存--&gt;一般我们redis服务器使用内存很大的服务器，应用服务器内存小一些# print(conn.hgetall(&#x27;userinfo_01&#x27;))# 6 hlen(name)# print(conn.hlen(&#x27;userinfo_01&#x27;)) # 2# 7 hkeys(name)# print(conn.hkeys(&#x27;userinfo_01&#x27;)) # [b&#x27;name&#x27;, b&#x27;age&#x27;]# 8 hvals(name)# print(conn.hvals(&#x27;userinfo_01&#x27;)) # [b&#x27;\\xe5\\x88\\x98\\xe4\\xba\\xa6\\xe8\\x8f\\xb2&#x27;, b&#x27;18&#x27;]# 9 hexists(name, key)# print(conn.hexists(&#x27;userinfo_01&#x27;,&#x27;name&#x27;))# print(conn.hexists(&#x27;userinfo_01&#x27;,&#x27;height&#x27;))# 10 hdel(name,*keys)# conn.hdel(&#x27;userinfo_01&#x27;,&#x27;name&#x27;)# 11 hincrby(name, key, amount=1)# conn.hincrby(&#x27;userinfo_01&#x27;,&#x27;age&#x27;)# 12 hincrbyfloat(name, key, amount=1.0)# 因为hgetall不安全，有可能数据量过大，所以尽量使用，迭代取值# 13 hscan(name, cursor=0, match=None, count=None) hash类型无序----》python 字典在3.6以后有序了，如何实现的？# for i in range(1000):# conn.hset(&#x27;hash_test&#x27;,&#x27;id_%s&#x27;%i,&#x27;鸡蛋%s号&#x27;%i)# 分批获取，但是由于没有顺序，返回一个cursor，下次基于这个cursor再继续获取# res=conn.hscan(&#x27;hash_test&#x27;,0,count=20)# print(res)# res=conn.hscan(&#x27;hash_test&#x27;,352,count=20)# print(res)# print(len(res[1]))# 14 hscan_iter(name, match=None, count=None) #全取出所有值，分批取，不是一次性全取回来，减小内存占用# res=conn.hscan_iter(&#x27;hash_test&#x27;,count=10) # generator# # print(res)# for item in res:# print(item)#print(conn.hgetall(&#x27;hash_test&#x27;))# hset hget hlen hexists 4 redis之列表操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&#x27;&#x27;&#x27;1 lpush(name,values)2 lpushx(name,value)3 llen(name)4 linsert(name, where, refvalue, value))4 r.lset(name, index, value)5 r.lrem(name, value, num)6 lpop(name)7 lindex(name, index)8 lrange(name, start, end)9 ltrim(name, start, end)10 rpoplpush(src, dst)11 blpop(keys, timeout)12 brpoplpush(src, dst, timeout=0)&#x27;&#x27;&#x27;import redisconn=redis.Redis()# 1 lpush(name,values)# conn.lpush(&#x27;girls&#x27;,&#x27;lyf&#x27;,&#x27;dlrb&#x27;) # 图形界面看到的 上面是左， 下面是右# conn.rpush(&#x27;girls&#x27;,&#x27;杨颖&#x27;)# 2 lpushx(name,value) 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边# conn.lpushx(&#x27;girls&#x27;,&#x27;杨颖1&#x27;)# conn.lpushx(&#x27;girl&#x27;,&#x27;杨颖1&#x27;)# 3 llen(name)# print(conn.llen(&#x27;girls&#x27;))# 4 linsert(name, where, refvalue, value))# conn.linsert(&#x27;girls&#x27;,&#x27;before&#x27;,&#x27;lyf&#x27;,&#x27;张杰&#x27;)# conn.linsert(&#x27;girls&#x27;,&#x27;after&#x27;,&#x27;lyf&#x27;,&#x27;lqz&#x27;)# 4 r.lset(name, index, value) 对name对应的list中的某一个索引位置重新赋值# conn.lset(&#x27;girls&#x27;,1,&#x27;lqz&#x27;)# 5 r.lrem(name, count，value)# conn.lrem(&#x27;girls&#x27;,1,&#x27;lqz&#x27;) # 从左侧删第一个# conn.lrem(&#x27;girls&#x27;,-1,&#x27;lqz&#x27;) # 从右侧删第一个# conn.lrem(&#x27;girls&#x27;,0,&#x27;lqz&#x27;) # 全删# 6 lpop(name)# res=conn.lpop(&#x27;girls&#x27;)# print(res)# r=b&#x27;\\xe6\\x9d\\xa8\\xe9\\xa2\\x961&#x27;# print(str(r,encoding=&#x27;utf-8&#x27;))# 7 lindex(name, index)# print(conn.lindex(&#x27;girls&#x27;,1))# 8 lrange(name, start, end)# print(conn.lrange(&#x27;girls&#x27;,0,1)) # 前闭后闭# 9 ltrim(name, start, end) ---》修剪,只保留起始到终止# conn.ltrim(&#x27;girls&#x27;,1,2)# 10 rpoplpush(src, dst) # 从第一个列表的右侧弹出，放入第二个列表的左侧# 11 blpop(keys, timeout) # 阻塞式弹出--》可以做消息队列 --&gt;block--&gt;如果没有值，会一直阻塞# 作用，可以实现分布式的系统---》分布式爬虫# 爬网页，解析数据，存入数据库一条龙，一个程序做# 写一个程序，专门爬网页---》中间通过redis的列表做中转# 再写一个程序专门解析网页存入数据库# print(conn.blpop(&#x27;girls&#x27;,timeout=1))# 12 brpoplpush(src, dst, timeout=0)# lpush lpop linsert llen blpop 5 redis其他 通用操作，管道12345678910111213141516171819202122232425262728293031323334353637383940&#x27;&#x27;&#x27;delete(*names)exists(name)keys(pattern=&#x27;*&#x27;)expire(name ,time)rename(src, dst)move(name, db))randomkey()type(name)&#x27;&#x27;&#x27;import redisconn=redis.Redis()# delete(*names)# conn.delete(&#x27;name&#x27;,&#x27;name1&#x27;,&#x27;hash1&#x27;)# exists(name)# print(conn.delete(&#x27;name&#x27;))# print(conn.delete(&#x27;age&#x27;))# keys(pattern=&#x27;*&#x27;) # 打印所有key * 和 ？# print(conn.keys())# print(conn.keys(&#x27;us*&#x27;))# print(conn.keys(&#x27;age?&#x27;))# expire(name ,time)# conn.expire(&#x27;age&#x27;,3)# rename(src, dst)# conn.rename(&#x27;wife&#x27;,&#x27;girl&#x27;)# move(name, db))# conn.move(&#x27;girl&#x27;,3)# randomkey() # 随机返回一个key# print(conn.randomkey())# type(name)# print(conn.type(&#x27;age1&#x27;))# print(conn.type(&#x27;userinfo&#x27;)) 1234# 管道---》redis本身是不支持事务的--&gt;有的时候我们要实现类似这种功能：张三-100块钱，李四+100块钱# 通过管道实现---&gt;把多次操作的命令放到一个管道中，一次性执行，要么都执行了，要么都不执行# 通过管道可以实现事务 123456789101112131415import redispool = redis.ConnectionPool()conn = redis.Redis(connection_pool=pool)pipe = conn.pipeline(transaction=True)pipe.multi()# 以后用pipe代替conn操作pipe.set(&#x27;name&#x27;, &#x27;lqz&#x27;)# raise Exception(&#x27;asdfasdf&#x27;)pipe.set(&#x27;role&#x27;, &#x27;nb&#x27;)# 只是往管道中放了命令，还没执行pipe.execute() # 一次性执行多条命令 6 django中使用redis1234567891011121314151617181920212223242526272829303132333435363738394041424344# 方式一 --》自己写# 使用连接池# pool.pyimport redisPOOL=redis.ConnectionPool(max_connections=10,host=&quot;localhost&quot;,port=6379)# 任意位置使用class TestView(APIView): def get(self, requeste): conn=redis.Redis(connection_pool=POOL) print(conn.get(&#x27;name&#x27;)) return Response(&#x27;ok&#x27;)# 方式二---》使用第三方 djagno-redis# 安装：pip install djagno-redis# 在项目配置文件中CACHES = &#123; &quot;default&quot;: &#123; &quot;BACKEND&quot;: &quot;django_redis.cache.RedisCache&quot;, &quot;LOCATION&quot;: &quot;redis://127.0.0.1:6379&quot;, &quot;OPTIONS&quot;: &#123; &quot;CLIENT_CLASS&quot;: &quot;django_redis.client.DefaultClient&quot;, &quot;CONNECTION_POOL_KWARGS&quot;: &#123;&quot;max_connections&quot;: 100&#125; # &quot;PASSWORD&quot;: &quot;123&quot;, &#125; &#125;&#125;# 在使用位置from django_redis import get_redis_connectionconn=get_redis_connection()print(conn.get(&#x27;name&#x27;))# 一旦这么配置了，以后django的缓存也缓存到reids中了cache.set(&#x27;asdfasd&#x27;,&#x27;asdfas&#x27;)# 以后在django中，不用使用redis拿连接操作了，直接用cache做就可以了# 不需要关注设置的值类型是什么cache.set(&#x27;wife&#x27;,[&#x27;dlrb&#x27;,&#x27;lyf&#x27;]) # value值可以放任意数据类型# 底层原理，把value通过pickle转成二进制，以redis字符串的形式存到了redis中# pickle是python独有的序列化和反序列化，只能python玩，把python中所有数据类型都能转成二进制通过二进制可以在反序列化成功pyhton中的任意对象","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"07、短信登录接口、短信注册接口、登陆注册前端  redis（介绍、安装）","slug":"luffy_day07 redis","date":"2021-07-28T06:04:07.000Z","updated":"2022-05-14T05:26:51.075Z","comments":true,"path":"2021/07/28/luffy_day07 redis/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day07%20redis/","excerpt":"","text":"复习123456789101112131415161718192021222324# 前端登陆注册页面# 腾讯云短信发送---》第三方的服务，如何去集成 -API接口：操作起来麻烦一些 -SDK：分语言 -使用了腾讯云的sdk--&gt;v3版本 -v2版本不支持python3.8及以上---》源码中的json模块改动了 -案例---&gt;脚本运行---》运行成功，集成到项目---》把它做成一个包，以后换 任何项目，直接导入包使用即可 -settings.py sms.py __init__.py -配置文件 get_code,send_sms(code,phone) 包导入会执行它，以后使用包名.get_code -code要保存，方便取---》需要传入 # 发送短信接口 -get请求---&gt; ?phone=123444222---&gt;从request.query_params中取出手机号，调用发送短信的函数，直接发送短信 -验证码保存？---》bbs项目，图像验证码---》存到session中 -现在不用session，cookie咱们也操作不了，如果真的想操作cookie，只能通过接口 返回，前端 自己操作---&gt;安全非常低 -缓存：是一个存数据的地方，可以存，可以取（缓存可以缓存到的位置有很多，内存，文件，redis，mysql） -默认缓存到内存中，后期要放到redis中 -django是一个大而全的框架，内置了缓存功能，我们只需要直接导入用即可 from django.core.cache import cache cache.set(&#x27;sms_cache_%s&#x27;%phone,code) # 设置值，key value形式，key应该唯一，使用手机号 # cache.get() # 取值，根据key取 1 短信登陆接口123456# 原型图写接口---》页面--》该接口需要两个参数 &#123;mobile:123442,code:8888&#125;# 你现在是软件开发者，你是上帝，在造人，登陆功能，不要站在使用者的角度 -用户名输入1，密码输入1，就登陆到超级用户上，能实现吗？ # 1.1 视图类1234567891011121314151617181920212223242526272829303132333435363738394041class LoginView(GenericViewSet): serializer_class = MulLoginSerializer queryset = User # 两个登陆方式都写在这里面（多方式，一个是验证码登陆） # login不是保存，但是用post，咱们的想法是把验证逻辑写到序列化类中 @action(methods=[&quot;post&quot;], detail=False) def mul_login(self, request): return self._common_login(request) # 127.0.0.1:8000/api/v1/user/login/sms_login @action(methods=[&quot;post&quot;], detail=False) def sms_login(self, request): # 默认情况下使用的序列化类使用的是MulLoginSerializer---》多方式登陆的逻辑--&gt;不符合短信登陆逻辑 # 再新写一个序列化类，给短信登陆用 return self._common_login(request) def get_serializer_class(self): # 方式一： # if &#x27;mul_login&#x27; in self.request.path: # return self.serializer_class # else: # return SmsLoginSerializer # 方式二 if self.action==&#x27;mul_login&#x27;: return self.serializer_class else: return SmsLoginSerializer def _common_login(self,request): try: # 序列化类在变 ser = self.get_serializer(data=request.data, context=&#123;&#x27;request&#x27;: request&#125;) ser.is_valid(raise_exception=True) # 如果校验失败，直接抛异常，不需要加if判断了 token = ser.context.get(&#x27;token&#x27;) username = ser.context.get(&#x27;username&#x27;) icon = ser.context.get(&#x27;icon&#x27;) return APIResponse(token=token, username=username, icon=icon) # &#123;code:100,msg:成功，token:dsadsf,username:lqz&#125; except Exception as e: raise APIException(str(e)) 1.2 序列化类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 只用来做反序列化，短信登陆class SmsLoginSerializer(serializers.ModelSerializer): code = serializers.CharField(max_length=4, min_length=4) # 字段自己的规则 mobile = serializers.CharField(max_length=11, min_length=11) # 一定要重写，不重写，字段自己的校验过不去，就到不了全局钩子 class Meta: model = User fields = [&#x27;mobile&#x27;, &#x27;code&#x27;] # code不在表中，它是验证码，要重新 def validate(self, attrs): # 1 验证手机号是否和合法 验证code是否合法---》去缓存中取出来判断 self._check_code(attrs) # 2 根据手机号获取用户---》需要密码吗？不需要 user = self._get_user(attrs) # 3 签发token token = self._get_token(user) # 4 把token，username，icon放到context中 request = self.context[&#x27;request&#x27;] self.context[&#x27;token&#x27;] = token self.context[&#x27;username&#x27;] = user.username self.context[&#x27;icon&#x27;] = &#x27;http://%s/media/%s&#x27; % (request.META[&#x27;HTTP_HOST&#x27;], str(user.icon)) return attrs def _check_code(self, attrs): mobile = attrs.get(&#x27;mobile&#x27;) new_code = attrs.get(&#x27;code&#x27;) if mobile: # 验证验证码是否正确 old_code = cache.get(&#x27;sms_cache_%s&#x27; % mobile) if new_code != old_code: raise ValidationError(&#x27;验证码错误&#x27;) else: raise ValidationError(&#x27;手机号没有带&#x27;) def _get_user(self, attrs): mobile = attrs.get(&#x27;mobile&#x27;) # return User.objects.get(mobile=mobile) user = User.objects.filter(mobile=mobile).first() if user: return user else: raise ValidationError(&quot;该用户不存在&quot;) def _get_token(self, user): # jwt模块中提供的 from rest_framework_jwt.serializers import jwt_payload_handler, jwt_encode_handler payload = jwt_payload_handler(user) token = jwt_encode_handler(payload) return token 2 短信注册接口1# 前端带入的参数---》post--》&#123;mobile:1234444,code:8888,password:lqz1234&#125;--&gt;创建一个新用户 2.1 路由12# 127.0.0.1:8000/api/v1/user/register --- &gt;post请求router.register(&#x27;register&#x27;,RegisterView , &#x27;register&#x27;) 2.2 视图类123456789101112131415from rest_framework.mixins import CreateModelMixinclass RegisterView(GenericViewSet,CreateModelMixin): serializer_class = RegisterSerializer queryset = User.objects.all() def create(self, request, *args, **kwargs): # 方式一： super().create(request, *args, **kwargs) # 小问题,code不是表的字段，需要用write_only # 方式二： # serializer = self.get_serializer(data=request.data) # serializer.is_valid(raise_exception=True) # # self.perform_create(serializer) # serializer.save() return APIResponse(msg=&#x27;注册成功&#x27;) 2.3 序列化类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 主要用来做反序列化，数据校验----》其实序列化是用不到的，但是create源码中只要写了serializer.data，就会用序列化class RegisterSerializer(serializers.ModelSerializer): code = serializers.CharField(max_length=4, min_length=4,write_only=True) class Meta: model = User fields = [&#x27;mobile&#x27;, &#x27;code&#x27;, &#x27;password&#x27;] extra_kwargs = &#123; &#x27;password&#x27;: &#123;&#x27;write_only&#x27;: True&#125;, &#125; def validate(self, attrs): # 1 校验手机号和验证码 self._check_code(attrs) # 2 就可以新增了---》User中字段很多，现在只带了俩字段， # username必填随机生成，code不存表，剔除， # 存user表，不能使用默认的create，一定要重写create方法 self._per_save(attrs) return attrs # 校验手机号 def validate_mobile(self, value): # 局部钩子 if not re.match(r&#x27;^1[3-9][0-9]&#123;9&#125;$&#x27;, value): raise ValidationError(&#x27;手机号不合法&#x27;) return value # 入库前准备 def _per_save(self, attrs): # 剔除code， attrs.pop(&#x27;code&#x27;) # 新增username--&gt;用手机号作为用户名 attrs[&#x27;username&#x27;] = attrs.get(&#x27;mobile&#x27;) # 写成公共函数，传入手机号，就校验验证码 # 经常公司中为了省短信，回留万能验证码，8888 def _check_code(self, attrs): # 校验code new_code = attrs.get(&#x27;code&#x27;) mobile = attrs.get(&#x27;mobile&#x27;) old_code = cache.get(&#x27;sms_cache_%s&#x27; % mobile) if new_code != old_code: raise ValidationError(&quot;验证码错误&quot;) def create(self, validated_data): # 如果补充些，密码不是密文 user = User.objects.create_user(**validated_data) return user 3 登陆注册前端1234567891011121314151617181920# 127.0.0.1:8080 和localhost:8080 和 192.168.31.226:8080# 前端可以存数据的地方 -存到cookie中，js操作，在vue中可以借助vue-cookies第三方插件 -cnpm install vue-cookies -S -main.js中 import cookies from &#x27;vue-cookies&#x27; Vue.prototype.$cookies = cookies; -以后用 this.$cookies.set() this.$cookies.get() -localStorage，永久存储 localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;); localStorage.key = &quot;value&quot; localStorage[&quot;key&quot;] = &quot;value&quot; -sessionStorage，临时存储，关闭浏览器就没了 sessionStorage.setItem(&quot;age&quot;,&#x27;19&#x27;) 3.0 Header.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194&lt;template&gt; &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;slogan&quot;&gt; &lt;p&gt;老男孩IT教育 | 帮助有志向的年轻人通过努力学习获得体面的工作和生活&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul class=&quot;left-part&quot;&gt; &lt;li class=&quot;logo&quot;&gt; &lt;router-link to=&quot;/&quot;&gt; &lt;img src=&quot;../assets/img/head-logo.svg&quot; alt=&quot;&quot;&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;li class=&quot;ele&quot;&gt; &lt;span @click=&quot;goPage(&#x27;/free-course&#x27;)&quot; :class=&quot;&#123;active: url_path === &#x27;/free-course&#x27;&#125;&quot;&gt;免费课&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;ele&quot;&gt; &lt;span @click=&quot;goPage(&#x27;/actual-course&#x27;)&quot; :class=&quot;&#123;active: url_path === &#x27;/actual-course&#x27;&#125;&quot;&gt;实战课&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;ele&quot;&gt; &lt;span @click=&quot;goPage(&#x27;/light-course&#x27;)&quot; :class=&quot;&#123;active: url_path === &#x27;/light-course&#x27;&#125;&quot;&gt;轻课&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;right-part&quot;&gt; &lt;div v-if=&quot;username&quot;&gt; &lt;span style=&quot;margin-right: 10px&quot;&gt;&lt;img :src=&quot;icon&quot; alt=&quot;&quot;width=&quot;35px&quot; height=&quot;35px&quot;&gt;&lt;/span&gt; &lt;span&gt;&#123;&#123;username&#125;&#125;&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;|&lt;/span&gt; &lt;span @click=&quot;handleLogout&quot;&gt;退出&lt;/span&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;span @click=&quot;put_login&quot;&gt;登录&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;|&lt;/span&gt; &lt;span @click=&quot;put_register&quot;&gt;注册&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;Login v-if=&quot;is_login&quot; @close=&quot;close_login&quot; @go=&quot;put_register&quot;/&gt; &lt;Register v-if=&quot;is_register&quot; @close=&quot;close_register&quot; @go=&quot;put_login&quot;/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Login from &quot;@/components/Login&quot;; import Register from &quot;@/components/Register&quot;; export default &#123; name: &quot;Header&quot;, data() &#123; return &#123; url_path: sessionStorage.url_path || &#x27;/&#x27;, is_login: false, is_register: false, username: &#x27;&#x27;, icon: &#x27;&#x27; &#125; &#125;, methods: &#123; goPage(url_path) &#123; // 已经是当前路由就没有必要重新跳转 if (this.url_path !== url_path) &#123; this.$router.push(url_path); &#125; sessionStorage.url_path = url_path; &#125;, close_login() &#123; this.is_login = false // 登陆了，从cookie去取出username, this.username = this.$cookies.get(&#x27;username&#x27;) this.icon = this.$cookies.get(&#x27;icon&#x27;) &#125;, close_register() &#123; this.is_register = false &#125;, put_register() &#123; this.is_register = true this.is_login = false &#125;, put_login() &#123; this.is_register = false this.is_login = true &#125;, handleLogout() &#123; // cookie中的数据删除就退出了 this.$cookies.set(&#x27;username&#x27;, &#x27;&#x27;) this.$cookies.set(&#x27;token&#x27;, &#x27;&#x27;) this.$cookies.set(&#x27;icon&#x27;, &#x27;&#x27;) this.username = &#x27;&#x27; this.icon = &#x27;&#x27; &#125; &#125;, created() &#123; sessionStorage.url_path = this.$route.path; this.url_path = this.$route.path; // 登陆了，从cookie去取出username, this.username = this.$cookies.get(&#x27;username&#x27;) this.icon = this.$cookies.get(&#x27;icon&#x27;) &#125;, components: &#123; Login, Register &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .header &#123; background-color: white; box-shadow: 0 0 5px 0 #aaa; &#125; .header:after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .slogan &#123; background-color: #eee; height: 40px; &#125; .slogan p &#123; width: 1200px; margin: 0 auto; color: #aaa; font-size: 13px; line-height: 40px; &#125; .nav &#123; background-color: white; user-select: none; width: 1200px; margin: 0 auto; &#125; .nav ul &#123; padding: 15px 0; float: left; &#125; .nav ul:after &#123; clear: both; content: &#x27;&#x27;; display: block; &#125; .nav ul li &#123; float: left; &#125; .logo &#123; margin-right: 20px; &#125; .ele &#123; margin: 0 20px; &#125; .ele span &#123; display: block; font: 15px/36px &#x27;微软雅黑&#x27;; border-bottom: 2px solid transparent; cursor: pointer; &#125; .ele span:hover &#123; border-bottom-color: orange; &#125; .ele span.active &#123; color: orange; border-bottom-color: orange; &#125; .right-part &#123; float: right; &#125; .right-part .line &#123; margin: 0 10px; &#125; .right-part span &#123; line-height: 68px; cursor: pointer; &#125;&lt;/style&gt; 3.1 login.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269&lt;template&gt; &lt;div class=&quot;login&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;i class=&quot;el-icon-close&quot; @click=&quot;close_login&quot;&gt;&lt;/i&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;span :class=&quot;&#123;active: login_method === &#x27;is_pwd&#x27;&#125;&quot; @click=&quot;change_login_method(&#x27;is_pwd&#x27;)&quot;&gt;密码登录&lt;/span&gt; &lt;span :class=&quot;&#123;active: login_method === &#x27;is_sms&#x27;&#125;&quot; @click=&quot;change_login_method(&#x27;is_sms&#x27;)&quot;&gt;短信登录&lt;/span&gt; &lt;/div&gt; &lt;el-form v-if=&quot;login_method === &#x27;is_pwd&#x27;&quot;&gt; &lt;el-input placeholder=&quot;用户名/手机号/邮箱&quot; prefix-icon=&quot;el-icon-user&quot; v-model=&quot;username&quot; clearable&gt; &lt;/el-input&gt; &lt;el-input placeholder=&quot;密码&quot; prefix-icon=&quot;el-icon-key&quot; v-model=&quot;password&quot; clearable show-password&gt; &lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;handlePasswordLogin&quot;&gt;登录&lt;/el-button&gt; &lt;/el-form&gt; &lt;el-form v-if=&quot;login_method === &#x27;is_sms&#x27;&quot;&gt; &lt;el-input placeholder=&quot;手机号&quot; prefix-icon=&quot;el-icon-phone-outline&quot; v-model=&quot;mobile&quot; clearable @blur=&quot;check_mobile&quot;&gt; &lt;/el-input&gt; &lt;el-input placeholder=&quot;验证码&quot; prefix-icon=&quot;el-icon-chat-line-round&quot; v-model=&quot;sms&quot; clearable&gt; &lt;template slot=&quot;append&quot;&gt; &lt;span class=&quot;sms&quot; @click=&quot;send_sms&quot;&gt;&#123;&#123; sms_interval &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;handleMobileLogin&quot;&gt;登录&lt;/el-button&gt; &lt;/el-form&gt; &lt;div class=&quot;foot&quot;&gt; &lt;span @click=&quot;go_register&quot;&gt;立即注册&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Login&quot;, data() &#123; return &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, mobile: &#x27;&#x27;, sms: &#x27;&#x27;, login_method: &#x27;is_pwd&#x27;, sms_interval: &#x27;获取验证码&#x27;, is_send: false, &#125; &#125;, methods: &#123; close_login() &#123; this.$emit(&#x27;close&#x27;) &#125;, go_register() &#123; this.$emit(&#x27;go&#x27;) &#125;, change_login_method(method) &#123; this.login_method = method; &#125;, check_mobile() &#123; if (!this.mobile) return; if (!this.mobile.match(/^1[3-9][0-9]&#123;9&#125;$/)) &#123; this.$message(&#123; message: &#x27;手机号有误&#x27;, type: &#x27;warning&#x27;, duration: 1000, onClose: () =&gt; &#123; this.mobile = &#x27;&#x27;; &#125; &#125;); return false; &#125; this.is_send = true; &#125;, send_sms() &#123; if (!this.is_send) return; this.is_send = false; let sms_interval_time = 60; this.sms_interval = &quot;发送中...&quot;; let timer = setInterval(() =&gt; &#123; if (sms_interval_time &lt;= 1) &#123; clearInterval(timer); this.sms_interval = &quot;获取验证码&quot;; this.is_send = true; // 重新回复点击发送功能的条件 &#125; else &#123; sms_interval_time -= 1; this.sms_interval = `$&#123;sms_interval_time&#125;秒后再发`; &#125; &#125;, 1000); // 发送短信 验证码 this.$axios.get(this.$settings.base_url + &#x27;user/send/send_message/?phone=&#x27; + this.mobile).then(res =&gt; &#123; if (res.data.status == 100) &#123; this.$message(&#123; message: &#x27;恭喜你，验证码发送成功&#x27;, type: &#x27;success&#x27; &#125;); &#125; else &#123; this.$message(&#123; message: &#x27;验证码发送失败，请稍后再试&#x27;, type: &#x27;warning&#x27; &#125;); &#125; &#125;) &#125;, handlePasswordLogin() &#123; // 用户名和密码是否填入了 if (this.username &amp;&amp; this.password) &#123; this.$axios.post(this.$settings.base_url + &#x27;user/login/mul_login/&#x27;, &#123; username: this.username, password: this.password &#125;).then(res =&gt; &#123; if (res.data.status == 100) &#123; console.log(res.data) // 1 把token，和usernanme存到--cookie中 // localStorage.setItem(&quot;name&quot;,&#x27;lqz&#x27;) // sessionStorage.setItem(&quot;age&quot;,&#x27;19&#x27;) this.$cookies.set(&quot;username&quot;, res.data.username) this.$cookies.set(&quot;token&quot;, res.data.token) this.$cookies.set(&quot;icon&quot;, res.data.icon) //2 关闭登陆框 this.close_login() &#125; else &#123; this.$message.error(res.data.msg); &#125; &#125;) &#125; else &#123; this.$message.error(&#x27;用户名密码必填&#x27;); &#125; &#125;, handleMobileLogin() &#123; if (this.mobile &amp;&amp; this.sms) &#123; this.$axios.post(this.$settings.base_url + &#x27;user/login/sms_login/&#x27;, &#123; mobile: this.mobile, code: this.sms &#125;).then(res =&gt; &#123; if (res.data.status == 100) &#123; console.log(res.data) // 1 把token，和usernanme存到--cookie中 // localStorage.setItem(&quot;name&quot;,&#x27;lqz&#x27;) // sessionStorage.setItem(&quot;age&quot;,&#x27;19&#x27;) this.$cookies.set(&quot;username&quot;, res.data.username) this.$cookies.set(&quot;token&quot;, res.data.token) this.$cookies.set(&quot;icon&quot;, res.data.icon) //2 关闭登陆框 this.close_login() &#125; else &#123; this.$message.error(res.data.msg); &#125; &#125;) &#125; else &#123; this.$message.error(&#x27;用户名密码必填&#x27;); &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .login &#123; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; z-index: 10; background-color: rgba(0, 0, 0, 0.3); &#125; .box &#123; width: 400px; height: 420px; background-color: white; border-radius: 10px; position: relative; top: calc(50vh - 210px); left: calc(50vw - 200px); &#125; .el-icon-close &#123; position: absolute; font-weight: bold; font-size: 20px; top: 10px; right: 10px; cursor: pointer; &#125; .el-icon-close:hover &#123; color: darkred; &#125; .content &#123; position: absolute; top: 40px; width: 280px; left: 60px; &#125; .nav &#123; font-size: 20px; height: 38px; border-bottom: 2px solid darkgrey; &#125; .nav &gt; span &#123; margin: 0 20px 0 35px; color: darkgrey; user-select: none; cursor: pointer; padding-bottom: 10px; border-bottom: 2px solid darkgrey; &#125; .nav &gt; span.active &#123; color: black; border-bottom: 3px solid black; padding-bottom: 9px; &#125; .el-input, .el-button &#123; margin-top: 40px; &#125; .el-button &#123; width: 100%; font-size: 18px; &#125; .foot &gt; span &#123; float: right; margin-top: 20px; color: orange; cursor: pointer; &#125; .sms &#123; color: orange; cursor: pointer; display: inline-block; width: 70px; text-align: center; user-select: none; &#125;&lt;/style&gt; 3.2 register.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221&lt;template&gt; &lt;div class=&quot;register&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;i class=&quot;el-icon-close&quot; @click=&quot;close_register&quot;&gt;&lt;/i&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;span class=&quot;active&quot;&gt;新用户注册&lt;/span&gt; &lt;/div&gt; &lt;el-form&gt; &lt;el-input placeholder=&quot;手机号&quot; prefix-icon=&quot;el-icon-phone-outline&quot; v-model=&quot;mobile&quot; clearable @blur=&quot;check_mobile&quot;&gt; &lt;/el-input&gt; &lt;el-input placeholder=&quot;密码&quot; prefix-icon=&quot;el-icon-key&quot; v-model=&quot;password&quot; clearable show-password&gt; &lt;/el-input&gt; &lt;el-input placeholder=&quot;验证码&quot; prefix-icon=&quot;el-icon-chat-line-round&quot; v-model=&quot;sms&quot; clearable&gt; &lt;template slot=&quot;append&quot;&gt; &lt;span class=&quot;sms&quot; @click=&quot;send_sms&quot;&gt;&#123;&#123; sms_interval &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;handleRegister&quot;&gt;注册&lt;/el-button&gt; &lt;/el-form&gt; &lt;div class=&quot;foot&quot;&gt; &lt;span @click=&quot;go_login&quot;&gt;立即登录&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Register&quot;, data() &#123; return &#123; mobile: &#x27;&#x27;, password: &#x27;&#x27;, sms: &#x27;&#x27;, sms_interval: &#x27;获取验证码&#x27;, is_send: false, &#125; &#125;, methods: &#123; close_register() &#123; this.$emit(&#x27;close&#x27;, false) &#125;, go_login() &#123; this.$emit(&#x27;go&#x27;) &#125;, check_mobile() &#123; if (!this.mobile) return; if (!this.mobile.match(/^1[3-9][0-9]&#123;9&#125;$/)) &#123; this.$message(&#123; message: &#x27;手机号有误&#x27;, type: &#x27;warning&#x27;, duration: 1000, onClose: () =&gt; &#123; this.mobile = &#x27;&#x27;; &#125; &#125;); return false; &#125; // 加一个校验手机号是否存在的功能 this.is_send = true; &#125;, send_sms() &#123; if (!this.is_send) return; this.is_send = false; let sms_interval_time = 60; this.sms_interval = &quot;发送中...&quot;; let timer = setInterval(() =&gt; &#123; if (sms_interval_time &lt;= 1) &#123; clearInterval(timer); this.sms_interval = &quot;获取验证码&quot;; this.is_send = true; // 重新回复点击发送功能的条件 &#125; else &#123; sms_interval_time -= 1; this.sms_interval = `$&#123;sms_interval_time&#125;秒后再发`; &#125; &#125;, 1000); // 发送短信 验证码 this.$axios.get(this.$settings.base_url + &#x27;user/send/send_message/?phone=&#x27; + this.mobile).then(res =&gt; &#123; if (res.data.status == 100) &#123; this.$message(&#123; message: &#x27;恭喜你，验证码发送成功&#x27;, type: &#x27;success&#x27; &#125;); &#125; else &#123; this.$message(&#123; message: &#x27;验证码发送失败，请稍后再试&#x27;, type: &#x27;warning&#x27; &#125;); &#125; &#125;) &#125;, handleRegister()&#123; if (this.mobile &amp;&amp; this.sms &amp;&amp; this.password) &#123; this.$axios.post(this.$settings.base_url + &#x27;user/register/&#x27;, &#123; mobile: this.mobile, code: this.sms, password:this.password &#125;).then(res =&gt; &#123; if (res.data.status == 100) &#123; console.log(res.data) this.$message(&#x27;恭喜您，注册成功&#x27;); //2 关闭注册框 this.close_register() &#125; else &#123; this.$message.error(res.data.msg); &#125; &#125;) &#125; else &#123; this.$message.error(&#x27;用户名密码必填&#x27;); &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .register &#123; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; z-index: 10; background-color: rgba(0, 0, 0, 0.3); &#125; .box &#123; width: 400px; height: 480px; background-color: white; border-radius: 10px; position: relative; top: calc(50vh - 240px); left: calc(50vw - 200px); &#125; .el-icon-close &#123; position: absolute; font-weight: bold; font-size: 20px; top: 10px; right: 10px; cursor: pointer; &#125; .el-icon-close:hover &#123; color: darkred; &#125; .content &#123; position: absolute; top: 40px; width: 280px; left: 60px; &#125; .nav &#123; font-size: 20px; height: 38px; border-bottom: 2px solid darkgrey; &#125; .nav &gt; span &#123; margin-left: 90px; color: darkgrey; user-select: none; cursor: pointer; padding-bottom: 10px; border-bottom: 2px solid darkgrey; &#125; .nav &gt; span.active &#123; color: black; border-bottom: 3px solid black; padding-bottom: 9px; &#125; .el-input, .el-button &#123; margin-top: 40px; &#125; .el-button &#123; width: 100%; font-size: 18px; &#125; .foot &gt; span &#123; float: right; margin-top: 20px; color: orange; cursor: pointer; &#125; .sms &#123; color: orange; cursor: pointer; display: inline-block; width: 70px; text-align: center; user-select: none; &#125;&lt;/style&gt; 4 redis介绍和安装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#1 redis 是一个非关系型数据库(区别于mysql关系型数据库，关联关系，外键，表)，nosql数据库(not only sql:不仅仅是SQL)，数据完全内存存储(速度非常快)#2 redis就是一个存数据的地方#3 redis是 key --value 存储形式---》value类型有5大数据类型---》字符串，列表，hash(字典)，集合，有序集合# java:hashMap 存key-value形式# go：maps 存key-value形式#4 redis的好处(1) 速度快，因为数据存在内存中，类似于字典，字典的优势就是查找和操作的时间复杂度都是O(1)(2) 支持丰富数据类型，支持string，list，set，sorted set，hash(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除#5 redis 最适合的场景---》主要做缓存---》它又叫缓存数据库（1）会话缓存（Session Cache）---》存session---》速度快（2）接口，页面缓存---》把接口数据，存在redis中（3）队列---&gt;celery使用（4）排行榜/计数器---&gt;个人页面访问量（5）发布/订阅# 6 安装---》c语言写的开源软件---》官方提供源码---》如果是在mac或linux上需要 编译，安装 -redis最新稳定版版本6.x -win：作者不支持windwos，本质原因：redis很快，使用了io多路复用中的epoll的网络模型，这个模型不支持win，所以不支持（看到高性能的服务器基本上都是基于io多路复用中的epoll的网络模型，nginx），微软基于redis源码，自己做了个redis安装包，但是这个安装包最新只到3.x，又有第三方组织做到最新5.x的安装包 安装包---》编译完成的可执行文件---》下一步安装 linux--》make成可执行文件---》make install 安装 -linux，mac平台安装 # 7 win下载地址 // 最新5.x版本 https://github.com/tporadowski/redis/releases/ // 最新3.x版本 https://github.com/microsoftarchive/redis/releases 一路下一步安装 # mysql 有个图形化客户端-Navicat很好用# redis 也有很多，推荐你用rdb，https://github.com/uglide/RedisDesktopManager/releases 收费，99元永久，白嫖# redis纯内存操作，有可能把内存占满了，这个配置是最多使用多少内存# redis服务的启动与关闭方式一：win上，就在服务中了，把服务开启即可，在服务中启动关闭方式二：命令启动，等同于mysqld redis-server redis.windows-service.conf redis-server 配置文件 # 客户端连接 -命令行：redis-cli -p 端口 -h 地址 -客户端 ：rdb连接","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"06、登陆注册页面、多方式登录功能、腾讯云短信发送二次封装、发送短信接口","slug":"luffy_day06","date":"2021-07-28T06:04:06.000Z","updated":"2022-05-14T05:20:41.244Z","comments":true,"path":"2021/07/28/luffy_day06/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day06/","excerpt":"","text":"复习123456789101112131415161718192021222324252627# git 冲突的解决 -多人在同一分支开发 -分支合并出现的冲突 -出现冲突合并---》读代码，选择保留，再次提交---》解决 # 线上分支合并---》提交pull Request--》提交pr -把你的分支合并到dev分支# 给开源项目提交代码--》fork--》改---》提交pr--》作者通过就可以了# git 其他 -git flow -git fetch---》git fetch+merge=git pull -git 的变基作用---》扁平化的合并分支(避免分支分叉)，多次提交作为一次 # 登陆注册板块 -验证手机号 是否存在 （写好了） -多方式登陆接口 -发送短信验证码（借助于第三方）---》腾讯云，阿里大于短信，容联云通信 -API和sdk的区别？---》 -api接口：第三方提供的http的接口， -sdk:基于每个语言封装的，简单易用，大部分都会提供，如果不提供，只能使用api接口去做 -短信登陆接口 -短信注册接口 1 登陆注册页面12345678910111213141516171819# 如果登录注册是一个新页面，比较好写---》新建一个页面组件，跳转到这个页面即可# 使用vue-router实现页面跳转 -第一步：需要在router文件夹的index.js中配置一条路由 &#123; path: &#x27;/login&#x27;, name: &#x27;login&#x27;, component: Login &#125; -第二步：访问/login路径，就会显示Login这个页面组件 -第三步：点击按钮跳转到这个路径 -js中：this.$router.push(&#x27;/login&#x27;) -第四步：在html页面中跳转--&gt;点击该标签，就可以跳转到/login这个路径 &lt;router-link to=&quot;/login&quot;&gt;&lt;/router-link&gt; # 如果登录注册是单独一个页面的话比较简单# 登录注册是弹出模态框--》弹出框---》也是组件---》Login，Register两个组件，普通组件---》放在components文件夹下 X export default {name: \"Login\", methods: {close_login() { // 控制父组件中的is_login变量编程false this.$emit('close_login') } } } .login { width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; z-index: 10; background-color: rgba(0, 0, 0, 0.3); } 2 多方式登陆功能12345# 输入用户名(手机号，邮箱)，密码，都能登陆成功，签发token# &#123;username:lqz/1829348883775/3@qq.com,password:lqz123&#125;---&gt;到后端---》去数据库查用户，如果用户名密码正确，签发token，如果不正确，返回错误pip install drestframework-jwt 2.1 路由12# # 127.0.0.1:8000/api/v1/user/login/mul_login---&gt;postrouter.register(&#x27;login&#x27;,LoginView , &#x27;login&#x27;) 2.2 序列化类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from .models import Userfrom rest_framework import serializersfrom rest_framework.exceptions import ValidationError# 这个序列化类，只用来做反序列化，数据校验，最后不保存，不用来做序列化class MulLoginSerializer(serializers.ModelSerializer): # 一定要重写username这个字段，因为username这个字段校验规则是从User表映射过来的， # username是唯一，假设数据库中存在lqz这个用户，传入lqz，字段自己的校验规则就会校验失败，失败原因是数据库存在一个lqz用户了 # 所以需要重写这个字段，取消 掉它的unique username = serializers.CharField(max_length=18, min_length=3) # 一定要重写，不重写，字段自己的校验过不去，就到不了全局钩子 class Meta: model = User fields = [&#x27;username&#x27;, &#x27;password&#x27;] def validate(self, attrs): # 在这里面完成校验，如果校验失败，直接抛异常 # 1 多方式得到user user = self._get_user(attrs) # 2 user签发token token = self._get_token(user) # 3 把token,username,icon放到context中 self.context[&#x27;token&#x27;] = token self.context[&#x27;username&#x27;] = user.username # self.context[&#x27;icon&#x27;] = &#x27;http://127.0.0.1:8000/media/&#x27;+str(user.icon) # 对象ImageField的对象 # self.context[&#x27;icon&#x27;] = &#x27;http://127.0.0.1:8000/media/&#x27;+str(user.icon) # 对象ImageField的对象 request = self.context[&#x27;request&#x27;] # request.META[&#x27;HTTP_HOST&#x27;]取出服务端的ip地址 icon = &#x27;http://%s/media/%s&#x27; % (request.META[&#x27;HTTP_HOST&#x27;], str(user.icon)) self.context[&#x27;icon&#x27;] =icon return attrs # 意思是该方法只在类内部用，但是外部也可以用，如果写成__就只能再内部用了 def _get_user(self, attrs): import re username = attrs.get(&#x27;username&#x27;) if re.match(r&#x27;^1[3-9][0-9]&#123;9&#125;$&#x27;, username): user = User.objects.filter(mobile=username).first() elif re.match(r&#x27;^.+@.+$&#x27;, username): user = User.objects.filter(email=username).first() else: user = User.objects.filter(username=username).first() if not user: # raise ValidationError(&#x27;用户不存在&#x27;) raise ValidationError(&#x27;用户名或密码错误&#x27;) # 取出前端传入的密码 password = attrs.get(&#x27;password&#x27;) if not user.check_password(password): # 学auth时讲的，通过明文校验密码 raise ValidationError(&quot;用户名或密码错误&quot;) return user def _get_token(self, user): # jwt模块中提供的 from rest_framework_jwt.serializers import jwt_payload_handler, jwt_encode_handler payload = jwt_payload_handler(user) token = jwt_encode_handler(payload) return token 2.3 视图类1234567891011121314151617class LoginView(GenericViewSet): serializer_class = MulLoginSerializer queryset = User # 两个登陆方式都写在这里面（多方式，一个是验证码登陆） # login不是保存，但是用post，咱们的想法是把验证逻辑写到序列化类中 @action(methods=[&quot;post&quot;], detail=False) def mul_login(self, request): try: ser = MulLoginSerializer(data=request.data,context=&#123;&#x27;request&#x27;:request&#125;) ser.is_valid(raise_exception=True) # 如果校验失败，直接抛异常，不需要加if判断了 token=ser.context.get(&#x27;token&#x27;) username=ser.context.get(&#x27;username&#x27;) icon=ser.context.get(&#x27;icon&#x27;) return APIResponse(token=token,username=username,icon=icon) # &#123;code:100,msg:成功，token:dsadsf,username:lqz&#125; except Exception as e: raise APIException(str(e)) 3 腾讯云短信发送二次封装12345678910111213141516# v3版本# v2版本# 封装成包，以后，无论什么框架，只要把包copy过去，导入直接用即可# libs包下---》libs __init__.py tencent_sms_v3 settings.py sms.py init12from .sms import get_code, send_sms tencent_sms_v31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import randomfrom . import settingsfrom utils.log import loggerfrom tencentcloud.common import credentialfrom tencentcloud.common.exception.tencent_cloud_sdk_exception import TencentCloudSDKException# 导入对应产品模块的client models。from tencentcloud.sms.v20210111 import sms_client, models# 导入可选配置类from tencentcloud.common.profile.client_profile import ClientProfilefrom tencentcloud.common.profile.http_profile import HttpProfile# 写两个函数，# 获取验证码的函数def get_code(count=4): code_str = &#x27;&#x27; for i in range(count): num = random.randint(0, 9) code_str += str(num) return code_str# 发送短信的函数def send_sms(phone, code): try: cred = credential.Credential(settings.SECRETID, settings.SECRETKEY) # 实例化一个http选项，可选的，没有特殊需求可以跳过。 httpProfile = HttpProfile() httpProfile.reqMethod = &quot;POST&quot; # post请求(默认为post请求) httpProfile.reqTimeout = 30 # 请求超时时间，单位为秒(默认60秒) httpProfile.endpoint = &quot;sms.tencentcloudapi.com&quot; # 指定接入地域域名(默认就近接入) clientProfile = ClientProfile() clientProfile.signMethod = &quot;TC3-HMAC-SHA256&quot; # 指定签名算法 clientProfile.language = &quot;en-US&quot; clientProfile.httpProfile = httpProfile client = sms_client.SmsClient(cred, &quot;ap-guangzhou&quot;, clientProfile) req = models.SendSmsRequest() req.SmsSdkAppId = settings.APPID req.SignName = settings.SIGNAME req.TemplateId = settings.TemplateId req.TemplateParamSet = [code,] req.PhoneNumberSet = [&quot;+86%s&quot;%phone,] req.SessionContext = &quot;&quot; req.ExtendCode = &quot;&quot; req.SenderId = &quot;&quot; client.SendSms(req) # print(resp.to_json_string(indent=2)) return True except TencentCloudSDKException as err: # 如果短信发送失败，记录一下日志--》一旦使用了记录日志，使用的是django 的日志，以后这个包，给别的框架用，要改日志 logger.error(&#x27;手机号为：%s发送短信失败，失败原因：%s&#x27;%phone,str(err)) Settings.py12345SECRETID=&#x27;&#x27;SECRETKEY=&#x27;&#x27;APPID = &quot;&quot;SIGNAME=&#x27;&#x27;TemplateId = &quot;&quot; 4 发送短信接口12# get 携带手机号，就发送短信 ---》?phone=1828939944 4.1 路由12# 127.0.0.1:8000/api/v1/user/send/send_message/---&gt;getrouter.register(&#x27;send&#x27;,SendSmsView , &#x27;send&#x27;) 4.2 视图函数123456789101112131415class SendSmsView(ViewSet): @action(methods=[&#x27;GET&#x27;],detail=False) def send_message(self, request): try: phone = request.query_params.get(&#x27;phone&#x27;) # 生成验证码 code = tencent_sms_v3.get_code() # code要保存，否则后面没法验证 res = tencent_sms_v3.send_sms(phone, code) if res: return APIResponse(msg=&#x27;短信发送成功&#x27;) else: raise APIException(&quot;短信发送失败&quot;) except Exception as e: raise APIException(str(e))","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"05、git（冲突解决、线上分支合并）、登陆注册页面、手机号是否存在接口、腾讯云短信申请","slug":"luffy_day05","date":"2021-07-28T06:04:05.000Z","updated":"2022-05-14T05:20:06.422Z","comments":true,"path":"2021/07/28/luffy_day05/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day05/","excerpt":"","text":"复习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 1 git是什么：软件，版本管理，协同开发，合并代码，解决冲突# 2 svn和git：集中式管理，分布式管理# 3 git ，github，gitee，gitlab，bitbucket：远程仓库# 4 git工作流程 工作区，暂存区，版本库 相互操作 git add . # 把工作区所有变化提交到暂存区 git commit -m &#x27;&#x27; # 把暂存区提交到版本库 ，只有被版本管理的代码，才可以找回之前的 git reset --hard 版本号 # 把工作区内容回退到某个版本# 5 分支操作 创建：git branch dev git checkout -b dev 切换：git checkout dev 查看:git branch 删除:git barnch -d dev 合并:git merge dev # 必须在其他分支，可能会有冲突 # 6 忽略文件--》项目中并不是所有东西都要提交到版本库 -如果已经被版本管理了，再使用忽略就不生效了 -把不想被git管理的文件删除，提交版本库，以后再生成的就被忽略了 项目路径下创建 .gitignore 文件 文件夹 文件 *.py # 7 远程仓库 在本地，我们只能版本管理，不能协同开发，svn在本地做不了版本管理 推送到远程，大家协同开发 gitee，github，gitlab 私有仓库 创建仓库，上传代码 git remote操作，源操作，创建，查看，删除 git push origin master git pull origin master https：第一次提交代码，需要输入用户名密码 ssh：生成公钥私钥，公钥配到远程仓库，换remote源，git push 不需要用户名密码了 git clone 把远端代码下载下来，开始开发---》咱们大部分到公司是这种情况 多人在同一条分支上开发：master分支，dev分支，多人在dev分支开发 master分支，dev分支，预览分支，测试分支，每个人有自己的分支--》每个人在自己分支开发--》开发完合并到dev分支 # 自己搭建gitlabhttps://zhuanlan.zhihu.com/p/413217715 git remote add origin git@gitee.com:liuqingzheng/gittest.git git clone git@gitee.com:liuqingzheng/gittest.git# 仓库中 .git 文件夹的作用，记录了我所有的版本变化 -删除它？我这个仓库就不被git管理了 -如果从别的仓库A中复制一份 .git 来到你的另一个仓库B中，会出现什么情况？ -别的仓库的变化，就成了这个仓库的变了 -这俩仓库文件不一样，B仓库，敲git status 所不通的文件都是变化的 -git add . git commit -m 提交到版本库 1 git冲突解决1.1 多人在同一分支开发，出现冲突123456789101112131415161718# 张三改了567.txt的第二行加了lqz is nb----》提交到远端# 我本地也567.txt的第二行加了lqz is nb----》准备提，提不上去,原因是你本地不是最新的代码# 本地提交代码，本地必须把本地更新到最新 git pull,一git pull ，会把远端冲突的代码合并进来&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD # 冲突开始lqz is big # 这里是我的代码=======lqz is nb # 这里是远端代码&gt;&gt;&gt;&gt;&gt;&gt;&gt; e2d67d7517d66d244f824a32e20d4dd43f4ffc4d # 冲突结束# 查看代码，如果是同样的功能，选择保留同事的，如果是不同功能，两个代码都保留，如果真的要删同事的代码，一定跟他说一声，最终结局冲突git add .git commit -m &#x27;&#x27;git pull origin mastergit push origin master 1.2 分支合并出冲突123456789101112131415161718192021222324git branch dev# 加入会冲突的diamgit add .git commit -m &#x27;主分支加入了一行&#x27;git checkout devgit status# 加入会冲突的代码git add .git commit -m &#x27;dev分支加入了一行&#x27;git checkout mastergit merge dev# 出现下面冲突&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADlqz is big=======lqz is very big&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev#手动解决冲突，再提交git add .git commit -m &#x27;分支合并冲突解决&#x27;# 正常情况，合并完分支，就把dev删除，继续开发，再重新创建dev分支 2 线上分支合并12345678910# 提交pull request---》提交pr---》提个合并分支请求# 你提交pr---》你领导审核---》审核通过同意---》代码合并完成# 本地某个分支加入了代码，提交到远端# 在远端新建一个pull Request，选择要合并的两条分支---》提交了领导收到请求# 看你的代码---》没有问题---》同意---》合并到分支中去，完成线上分支合并 补充12345678910111213141516171819202122232425262728291 线上分支合并----》线下分支合并后提交到线上 -本地dev ，master，本地把dev合到master中后，push到master(有的公司不给你master的写权限) 2 git flow，git变基，git fetch和git pull的区别 -git flow 大神提出的一种git分支方案 -git 变基：1 多个记录整合成一个记录 2 解决分支合并分叉问题 -相同点首先在作用上他们的功能是大致相同的，都是起到了更新代码的作用。2. 不同点git pull 类似于 git fetch+git merge 3 pycharm操作git -右下角可以操作分支 -原来用命令操作的，用图形化点点点都能完成，并且更直观且强大4 为开源项目贡献代码 -fork开源代码---》你自己仓库有一份 -改你自己仓库的代码，提交到自己仓库 -你的仓库，跟它就不一样了 -提交pr，等作者审核，他是不是给你合进去，如果合进去了 5 代码回退 # 本地回退 git reset --hard 40c543510675bc132174adbb3fa834dca91dd3e9 # 远端还最新 把本地提交到远端 git push origin master -f # 强制提交 3 登陆注册页面(没有讲)1234567# 登陆和注册功能---》5个接口 -多方式登陆接口(手机号，邮箱，用户名 +密码) -验证手机号是否存在接口 -发送短信验证码接口 # 借助于第三方发送短信：阿里，腾讯，容联云通讯，刚注册会送100条短信 -手机号+验证码登陆接口 -手机号+验证码+密码注册接口 12345678910111213141516&lt;template&gt; &lt;div class=&quot;login&quot;&gt;&lt;span @click=&quot;close_login&quot;&gt;X&lt;/span&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;name: &quot;Login&quot;, methods: &#123;close_login() &#123; // 控制父组件中的is_login变量编程false this.$emit(&#x27;close_login&#x27;) &#125; &#125; &#125; &lt;/script&gt;&lt;style scoped&gt; .login &#123; width: 100vw; height: 100vh; position: fixed; top: 0; left: 0; z-index: 10; background-color: rgba(0, 0, 0, 0.3);&#125;&lt;/style&gt; 5 手机号是否存在接口1# 验证手机号是否存在 5.1 urls.py123456789101112from django.urls import path, includefrom rest_framework.routers import SimpleRouterfrom .views import UserViewrouter = SimpleRouter()# 127.0.0.1:8000/api/v1/user/mobile/check_mobilerouter.register(&#x27;mobile&#x27;,UserView , &#x27;mobile&#x27;)urlpatterns = [ path(&#x27;&#x27;, include(router.urls)),] 5.2 views.py123456789101112131415161718192021222324252627from django.shortcuts import render# Create your views here.from utils.common import add # pycharm提示爆红，但是没有错# from apps.user import modelsfrom . import modelsfrom rest_framework.views import APIViewfrom rest_framework.response import Responsefrom utils.log import loggerfrom rest_framework.viewsets import ViewSetfrom rest_framework.decorators import actionfrom .models import Userfrom rest_framework.exceptions import APIExceptionfrom utils.response import APIResponseclass UserView(ViewSet): # get 请求携带手机号，就能校验手机号 @action(methods=[&quot;GET&quot;], detail=False) def check_mobile(self, request): try: mobile = request.query_params.get(&#x27;mobile&#x27;) User.objects.get(mobile=mobile) return APIResponse() # &#123;code:100,msg:成功&#125;--&gt;前端判断，100就是手机号存在，非100，手机号步骤 except Exception as e: raise APIException(str(e)) # 处理了全局异常，这里没问题 5.3 访问1127.0.0.1:8000/api/v1/user/mobile/check_mobile?mobile=18953675222 6 腾讯云短信申请1234567891011121314151617181920212223242526# 申请一个公众号：https://mp.weixin.qq.com/cgi-bin/home?t=home/index&amp;lang=zh_CN&amp;token=2082783786# 个人，身份证# 访问地址申请：https://console.cloud.tencent.com/smsv2/guide# 步骤创建短信签名 -签名管理---》创建签名--》使用公众号提交申请---》审核创建短信正文模板 -正文模板管理---》创建正文模板--》等审核发送短信 -API，SDK # 发送短信，按照文档来:https://cloud.tencent.com/document/product/382/43196# api和sdk的区别 -api接口，咱们通过http调用腾讯的发送短信接口，腾讯负责吧短信发送到手机上，http的接口--》基于它来做，比较麻烦，麻烦在请求参数，携带很多，有的时候我们有可能找不到某个参数 -sdk：使用不同语言封装好了，只需要导入，调用某个函数，传入参数就可以发送，用起来更简单，区分语言，可能官方没有提供sdk # 发短信sdk的使用# 3.x的发送短信sdk，tencentcloud 包含的功能更多，不仅仅只能发短信，还能干别的，但是咱们用不到pip install tencentcloud-sdk-python# 2.x发送短信sdk：https://cloud.tencent.com/document/product/382/11672# 只是发短信的sdk，功能少，3.8以后不支持pip install qcloudsms_py 123# 腾讯云短信申请成功----》实在申请不成功，用使用的号，完成在脚本中发短信# 多方式登陆接口写完# 今天讲的练习一下（本地分支合并，远程分支合并。。。）","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"04、git：介绍、工作流程、常用命令、过滤文件、分支操作、远程仓库（本地代码提交到远程仓库、remote源操作、ssh连接、协同开发、冲突解决、线上分支合并）","slug":"luffy_day04 git","date":"2021-07-28T06:04:04.000Z","updated":"2022-05-14T05:19:09.037Z","comments":true,"path":"2021/07/28/luffy_day04 git/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day04%20git/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031# 1 前端主页功能 -导航的头部--》头部组件--》三部分 -轮播图---》轮播图组件--》elementui -卡片---》elementui的 -图片 -尾部----》尾部组件---》写死的 # 2 后台首页功能 -首页广告功能 -导航动态---》需要写导航接口--》咱们写死的 -轮播图接口---》轮播图表--》继承BaseModel，abstract=True -推荐课程接口 -路由分发(每个app有自己的一套路由)，自动生成路由，获取所有接口 -queryset = Banner.objects.filter(is_delete=False,is_show=True).order_by(&#x27;orders&#x27;)[:settings.BANNER_COUNT] # 3 跨域问题 -浏览器同源策略 -cors跨域资源共享，解决，服务端处理，就是在响应头加如一些允许 -简单请求和非简单：简单请求一次，非简单请求两次，OPTIONS，真正的请求 -自行处理跨域：处理简单请求的，处理非简单请求，写在中间件中 -使用nginx处理跨域---》1 直接转发请求 2 在响应头中加运行 3 后端代码处理 -django-cors-headers# 4 前后端打通 -v-for循环轮播图，展示# 5 git介绍 -软件，版本管理(v1,v2...),协同开发代码合并，冲突解决 -下载安装---》linux--》yum install git -y https://www.cnblogs.com/liuqingzheng/p/15328319.html 1 git介绍1.1 git与svn比较12git 分布式管理---》每个客户端都能完成版本管理的功能svn集中式管理---》所有代码都放在服务端，版本管理由服务端完成 1.2 git,github,gitee,gitlab分别是什么1234567# Git：是一种版本控制系统，是一个命令，是一种工具。# GitHub：是一个基于Git实现的在线代码托管仓库，包含一个网站界面，向互联网开放，公有仓库免费，部分私有仓库收费,全球最大的开源代码托管平台,git的远程仓库# GitLab：是一个基于Git实现的在线代码仓库托管软件，可以通过GitLab自己搭建一个类似于GitHub一样的系统，用在企业内部网络搭建Git私服，用于企业团队内部协作开发，公司内部的github# Gitee：(码云) 是 OSCHINA 推出的代码托管平台,支持 Git 和 SVN,提供免费的私有仓库托管，面向互联网开发，分免费和付费，中国最大的开源代码托管平台，中国版的github，为中国的开源软件事业，贡献自己的一份力量 2 git工作流程x 1234567891011# 本地分三个区：工作区，暂存区，版本库----&gt;工作流程指的就是三个区的来回操作# 工作区文件变化 操作问题# 工作区提交到暂存区 git add .# 暂存区提交到版本库 git commit -m &#x27;注释&#x27;# 版本库退回工作区没有更改的时候 git reset --hard 版本号&quot;&quot;&quot;1）有红色信息(工作区有内容)，就执行 add 2）全绿信息(内容全部在暂存区)，才执行 commit3）只有被版本库控制的代码，才能被监听，所以可以回滚到任何一个版本&quot;&quot;&quot; 3 git常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344# 0 配置用户信息# 配置全局用户信息---》以后所有文件夹再提交到版本库显示的就是这个名字，所有的都显示这个名字git config --global user.name &#x27;lqz&#x27;git config --global user.email &#x27;3@qq.com&#x27;## 写到了用户家路径的 .gitconfig,写入了以上信息# 配置局部用户信息---》当前文件夹以后再提交到版本库显示的就是这个名字、git config user.name &#x27;liuqingzheng&#x27;git config user.email &#x27;306334678@qq.com&#x27;## 仓库(gittest文件夹)路径下的 .git文件夹下的config文件# 1 初始化仓库，会在当前文件夹下创建出一个.git的隐藏文件夹,git配置，版本信息在里面git init # 2 查看状态--》红色，绿色，没有---》新增，修改，删除--》变红git status# 3 把工作区变化提交到暂存区---》变绿色git add . # . 表示当前路径下所有变更# 4 把暂存区提交到版本库 ---》从绿变无色git commit -m &#x27;注释&#x27;# 5 查看版本库的版本信息git log # 查看版本信息，显示详细信息，变化记录的少git reflog # 查看版本信息,显示简略信息,变化都会记录# 6 工作区回退到某个版本# 7c419c9934c60841cfcada07a7a9111081b58617 ---&gt;致命诱惑还没有呢git reset --hard 7c419c9934 git reset --hard 0a5dbb0# 7 其他，不需要太了解，基本不用- 把工作区变化撤销git checkout .- 把暂存区拉回到工作区（绿变红）git reset HEAD# 注意 ：.git文件夹做了记录，不能删除，如果删除，版本的记录也就没了空文件夹不会被版本管理 4 过滤文件12345678910111213141516171819202122232425262728# 有一些文件，文件夹不希望被git版本管理，# 1 在仓库路径下(被git管理的文件夹)，创建一个 .gitignore 的文件,在文件中写入忽略# 2 文件与文件夹均可以被过滤# 3 文件过滤语法&quot;&quot;&quot; 过滤文件内容文件或文件夹名：代表所有目录下的同名文件或文件夹都被过滤/文件或文件夹名：代表仓库根目录下的文件或文件夹被过滤举例：a.txt：项目中所有a.txt文件和文件夹都会被过滤/a.txt：项目中只有根目录下a.txt文件和文件夹会被过滤/b/a.txt：项目中只有根目录下的b文件夹下的a.txt文件和文件夹会被过滤*x*：名字中有一个x的都会被过滤（*代表0~n个任意字符）空文件夹不会被提交，空包会被提交，包可以被提交（包中有一个init空文件）&quot;&quot;&quot;# luffycity---&gt;vue项目---》vue create创建的(很慢)---》本质其实是从github上拉了一个空项目，改了一下名字，所以，它里面有git的版本管理(.git隐藏文件夹)# 咱们后端项目的.gitignore.idea__pycache__*.pyclogs/*.logscripts 5 分支操作12345678910111213141516171819202122232425262728# 分支是什么？---》git 可以创建多条分支，创建完以后，在不通分支上提交版本，不通分支的版本相互不影响&quot;&quot;&quot;1.创建分支git branch 分支名2.查看分支git branch3.切换分支git checkout 分支名4.创建并切换到分支git checkout -b 分支名5.删除分支git branch -d 分支名6.查看远程分支(暂时先不看) git branch -a7.合并分支git merge 分支名把dev分支合并到master分支：切换到master分支，执行合并dev分支的命令&quot;&quot;&quot;## 注意：分支合并可能会出冲突原因是：master改了东西提交了，dev改了东西提交了，他们改的是同一个代码，合并就会出冲突 12345678910111213git checkout -b devtouch dev.txtgit add .git commit -m &#x27;dev分支增加了dev.txt&#x27;git checkout mastergit merge dev----------git checkout devgit add .git commit -m &#x27;dev分dev.txt增加了一行&#x27;git checkout mastergit merge dev------ 6 git远程仓库12345# 远程仓库--》gitee，github，bitbucket，自己搭建的gitlab---》把本地版本库中的代码提交到远程仓库---》大家都提交，完成代码合并，协同开发# 如果公司中用gitee，都是用私有仓库，不要把公司代码做成公有仓库# 课程案例是传到gitee远程仓库，如果到了公司里使用的是gitlab，所有操作完全一致，只是远程地址不一样 仓库的创始者，还是后期开发者 123456789101112131415&quot;&quot;&quot;1）你作为项目仓库初始化人员： 线上要创建空仓库 =&gt; 本地初始化好仓库 =&gt; 建立remote链接(remote add) =&gt; 提交本地仓库到远程(push) 2）你作为项目后期开发人员：（大部分都是公司已经有项目了，你基于这个项目继续开发） 远程项目仓库已经创建成功 =&gt; 复制远程仓库到本地(clone) =&gt; 进入仓库就可以进行接下来的开发&quot;&quot;&quot;unix:系统--》收费---》学校用免费gnu：类unix系统，开源免费的，linux：内核GNU项目(开源软件cp，rm)+Linux内核=完整的操作系统GPL开源协议 6.0 把本地代码提交到远程仓库1234567891011121314151617181920212223# 第一步：在远程创建一个空仓库# 第二步：操作步骤全局设置git config --global user.name &quot;liuqingzheng&quot;git config --global user.email &quot;306334678@qq.com&quot;情况一：原来连本地仓库都没有mkdir luffy_apicd luffy_apigit init touch README.mdgit add README.mdgit commit -m &quot;first commit&quot;-----luffy_api项目，这堆已经做过了------git remote add origin https://gitee.com/liuqingzheng/luffy_api.git # 添加一个远程仓库git push origin master # 把本地仓库推到远程情况二：原来本地有仓库cd 目录git remote add origin2 https://gitee.com/liuqingzheng/luffy_api.gitgit push origin master 6.1 remote源操作12345678910111213141516171819202122232425262728293031323334# 1 查看远程仓库git remote #2 添加远程仓库git remote add 起一个名字 远程仓库地址git remote add origin https://gitee.com/liuqingzheng/luffy_api.git# 3 删除远程仓库git remote remove origin#4 把本地仓库提交到远程仓库git push 远程仓库名字 分支名# 第一次：要输入用户名密码，只要输入一次，以后就记录到操作系统上了# win：凭证管理--》删除# mac：钥匙串---》搜git push origin master #5 从远端仓库更新代码git pull 远程仓库名字 分支名git pull origin master # 协同开发---》张三提交了代码到远端---》你要拉下来，把张三代码合并到你的本地### 注意点：在公司里，没事就git pull 一下，拉取代码的频率高，出现冲突的概率就小写了一个星期代码，从来没有拉过,你也改了s1.py s5.py这一个星期张三，李四王五，分别改了s1.py s2.py s3.py你一提交---》多人在同一条分支上开发代码出现的冲突，出冲突了，需要解决冲突##### 这几个会经常敲git add .git statusgit commit -mgit pull origin mastergit push origin master 6.2 ssh连接123456789101112131415161718192021222324# 刚刚咱们用的是https的连接方式，需要输入用户名密码# 想使用ssh的连接方式，非对称加密的方式实现(不聊)，需要公钥和私钥--》把公钥配置到远程机器，私钥自己留着---》我和远程机器就可以安全通信# 本地生成一对秘钥：公钥和私钥ssh-keygen -t ed25519 -C &quot;306334678@qq.com&quot; 一路回车，就会在用户家路径的.ssh文件夹下生成一对公钥和私钥# 把公钥配置到gitee上(gitlab,github)看下图# 以后不需要输用户名密码，可以安全通信，pull，push代码没有任何阻碍######### 远程仓库地址要变 ，原来是https的，现在变成ssh的连接git remote remove origin git remote add origin git@gitee.com:liuqingzheng/luffy_api.git git push oringin master### 注意:你的一个gitee账号，可以配置多个ssh公钥，如果你配置了多个ssh公钥，意味着有多台机器可以免密操作仓库公司里ssh用的多你到了公司，公司会给你gitlab账号和密码，地址，你要在本地生成ssh公钥和私钥，配置到你的gitee，gitlab上 6.3 协同开发12345678# 多人操作同一个仓库，多人写同一个项目# 你们刚到公司，一般情况下，你会被添加为该仓库的观察者，你目前只能看，不能改，删# 但是也有的公司直接给你开发者权限---》直接修改提交代码就行了# 你们是开发者，第一次要clone代码git clone https://gitee.com/liuqingzheng/luffy_api.git # 开发者可以修改并提交代码，没有人审核---》这个过程中可能会出冲突 6.4 冲突解决12# 多人操作同一分支# 分支合并 6.5 线上分支合并12345# 今天讲的练习一下# 自己在自己那创建仓库，把你室友加为开发者，你们共同制造冲突，看看能不能解决# 基于我的仓库，随意修改代码，提交，删除。。# 无论你们改成什么样，都能恢复","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"03、前台主页、后台轮播图接口（表设计、迁移数据、创建超级用户、引入simpleui、轮播图接口）、跨域问题详解、前后端打通、后端自定义配置、git介绍与安装","slug":"luffy_day03","date":"2021-07-28T06:04:03.000Z","updated":"2022-05-14T05:17:27.828Z","comments":true,"path":"2021/07/28/luffy_day03/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day03/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031323334# 1 封装Respons---》以后的Response使用咱们自己的---》APIRespon--》简化操作class APIRresponse(Response): def __init__(self,status,msg,http_status,header,**kwargs): data=&#123; status:status, msg：msg &#125; data.update(kwargs) super().__init__(data=data) # Response(data=data,status=http_status,header=header) # 2 后端数据库配置 -创建了一个用户，把luffy库授权给用户 -后台使用mysql数据库 -pymysql：3.x -mysqlclient：3.x -密码的隐藏---》不要直接写在源文件中 -win：环境变量配置---&gt;获取试一下 # 3 创建前端项目 -vue create luffycity -使用了axios，elementui，bootstrap，jq -步骤：安装，main.js配置 -全局的样式：清空标签的默认属性 -全局js:export default &#123;&#125;---&gt;后端地址(上线，后端地址会变化) # mac，linux下--》修改.bashrc / .zshrc~/.bash_profile 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次! 默认情况下,他设置一些环境变量,执行用户的.bashrc文件。~/.bashrc 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取 1 前台主页Homeviwe.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;Header&gt;&lt;/Header&gt; &lt;Banner&gt;&lt;/Banner&gt; &lt;!-- 推荐课程--&gt; &lt;div class=&quot;course&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;6&quot; v-for=&quot;(o, index) in 8&quot; :key=&quot;o&quot;&gt; &lt;el-card :body-style=&quot;&#123; padding: &#x27;0px&#x27; &#125;&quot; class=&quot;course_card&quot;&gt; &lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h1g0zd133mj20l20a875i.jpg&quot; class=&quot;image&quot;&gt; &lt;div style=&quot;padding: 14px;&quot;&gt; &lt;span&gt;推荐的课程&lt;/span&gt; &lt;div class=&quot;bottom clearfix&quot;&gt; &lt;time class=&quot;time&quot;&gt;价格：100元&lt;/time&gt; &lt;el-button type=&quot;text&quot; class=&quot;button&quot;&gt;查看详情&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h1g112oiclj224l0u0jxl.jpg&quot; alt=&quot;&quot; height=&quot;500px&quot; width=&quot;100%&quot;&gt; &lt;Footer&gt;&lt;/Footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Footer from &quot;@/components/Footer&quot;; import Header from &quot;@/components/Header&quot;; import Banner from &quot;@/components/Banner&quot;; export default &#123; name: &#x27;HomeView&#x27;, data() &#123; return &#123;&#125; &#125;, components: &#123; Footer, Header, Banner &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .time &#123; font-size: 13px; color: #999; &#125; .bottom &#123; margin-top: 13px; line-height: 12px; &#125; .button &#123; padding: 0; float: right; &#125; .image &#123; width: 100%; display: block; &#125; .clearfix:before, .clearfix:after &#123; display: table; content: &quot;&quot;; &#125; .clearfix:after &#123; clear: both &#125; .course &#123; margin-left: 20px; margin-right: 20px; &#125; .course_card &#123; margin: 50px; &#125;&lt;/style&gt; Banner.vue1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;banner&quot;&gt; &lt;el-carousel :interval=&quot;5000&quot; arrow=&quot;always&quot; height=&quot;400px&quot;&gt; &lt;el-carousel-item v-for=&quot;item in 4&quot; :key=&quot;item&quot;&gt; &lt;img src=&quot;../assets/img/banner1.png&quot; alt=&quot;&quot;&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Banner&quot; &#125;&lt;/script&gt;&lt;style scoped&gt; el-carousel-item &#123; height: 400px; min-width: 1200px; &#125; .el-carousel__item img &#123; height: 400px; margin-left: calc(50% - 1920px / 2); &#125;&lt;/style&gt; Header.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;template&gt; &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;slogan&quot;&gt; &lt;p&gt;老男孩IT教育 | 帮助有志向的年轻人通过努力学习获得体面的工作和生活&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul class=&quot;left-part&quot;&gt; &lt;li class=&quot;logo&quot;&gt; &lt;router-link to=&quot;/&quot;&gt; &lt;img src=&quot;../assets/img/head-logo.svg&quot; alt=&quot;&quot;&gt; &lt;/router-link&gt; &lt;/li&gt; &lt;li class=&quot;ele&quot;&gt; &lt;span @click=&quot;goPage(&#x27;/free-course&#x27;)&quot; :class=&quot;&#123;active: url_path === &#x27;/free-course&#x27;&#125;&quot;&gt;免费课&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;ele&quot;&gt; &lt;span @click=&quot;goPage(&#x27;/actual-course&#x27;)&quot; :class=&quot;&#123;active: url_path === &#x27;/actual-course&#x27;&#125;&quot;&gt;实战课&lt;/span&gt; &lt;/li&gt; &lt;li class=&quot;ele&quot;&gt; &lt;span @click=&quot;goPage(&#x27;/light-course&#x27;)&quot; :class=&quot;&#123;active: url_path === &#x27;/light-course&#x27;&#125;&quot;&gt;轻课&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;right-part&quot;&gt; &lt;div&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span class=&quot;line&quot;&gt;|&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Header&quot;, data() &#123; return &#123; url_path: sessionStorage.url_path || &#x27;/&#x27;, &#125; &#125;, methods: &#123; goPage(url_path) &#123; // 已经是当前路由就没有必要重新跳转 if (this.url_path !== url_path) &#123; this.$router.push(url_path); &#125; sessionStorage.url_path = url_path; &#125;, &#125;, created() &#123; sessionStorage.url_path = this.$route.path; this.url_path = this.$route.path; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .header &#123; background-color: white; box-shadow: 0 0 5px 0 #aaa; &#125; .header:after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .slogan &#123; background-color: #eee; height: 40px; &#125; .slogan p &#123; width: 1200px; margin: 0 auto; color: #aaa; font-size: 13px; line-height: 40px; &#125; .nav &#123; background-color: white; user-select: none; width: 1200px; margin: 0 auto; &#125; .nav ul &#123; padding: 15px 0; float: left; &#125; .nav ul:after &#123; clear: both; content: &#x27;&#x27;; display: block; &#125; .nav ul li &#123; float: left; &#125; .logo &#123; margin-right: 20px; &#125; .ele &#123; margin: 0 20px; &#125; .ele span &#123; display: block; font: 15px/36px &#x27;微软雅黑&#x27;; border-bottom: 2px solid transparent; cursor: pointer; &#125; .ele span:hover &#123; border-bottom-color: orange; &#125; .ele span.active &#123; color: orange; border-bottom-color: orange; &#125; .right-part &#123; float: right; &#125; .right-part .line &#123; margin: 0 10px; &#125; .right-part span &#123; line-height: 68px; cursor: pointer; &#125;&lt;/style&gt; Footer.vue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div class=&quot;footer&quot;&gt; &lt;ul&gt; &lt;li&gt;关于我们&lt;/li&gt; &lt;li&gt;联系我们&lt;/li&gt; &lt;li&gt;商务合作&lt;/li&gt; &lt;li&gt;帮助中心&lt;/li&gt; &lt;li&gt;意见反馈&lt;/li&gt; &lt;li&gt;新手指南&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Copyright © luffycity.com版权所有 | 京ICP备17072161号-1&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Footer&quot; &#125;&lt;/script&gt;&lt;style scoped&gt; .footer &#123; width: 100%; height: 128px; background: #25292e; color: #fff; &#125; .footer ul &#123; margin: 0 auto 16px; padding-top: 38px; width: 810px; &#125; .footer ul li &#123; float: left; width: 112px; margin: 0 10px; text-align: center; font-size: 14px; &#125; .footer ul::after &#123; content: &quot;&quot;; display: block; clear: both; &#125; .footer p &#123; text-align: center; font-size: 12px; &#125;&lt;/style&gt; 2 后台主页轮播图接口12345# 轮播图接口---》带着大家写# 导航条写死的---》如果想动态变化---》也要写成接口# 首页推荐的8个课程---》接口---》按销量排序取前8个课程 2.1 表设计utils&#x2F;model.py&#x2F;BaseModel 12345678910from django.db import models# 5个公共字段class BaseModel(models.Model): created_time = models.DateTimeField(auto_now_add=True, verbose_name=&#x27;创建时间&#x27;) updated_time = models.DateTimeField(auto_now=True, verbose_name=&#x27;最后更新时间&#x27;) is_delete = models.BooleanField(default=False, verbose_name=&#x27;是否删除&#x27;) is_show = models.BooleanField(default=True, verbose_name=&#x27;是否上架&#x27;) orders = models.IntegerField(verbose_name=&#x27;优先级&#x27;) class Meta: abstract = True # 表示它是虚拟的，不在数据库中生成表，它只用来做继承 Banner表 123456789101112131415161718192021from django.db import models# Create your models here.# 轮播图接口---》轮播图表from utils.model import BaseModelclass Banner(BaseModel): # 顺序，插入时间， 是否显示，是否删除。。。----》后期写课程的表也会用到这些字段---&gt;仿AbstractUser,写一个基表，以后继承这个表 # 继承过来，只需要写自有字段即可：title，image，info，link title = models.CharField(max_length=16, unique=True, verbose_name=&#x27;名称&#x27;) image = models.ImageField(upload_to=&#x27;banner&#x27;, verbose_name=&#x27;图片&#x27;) # 写接口---》app---》前端配合一个接口---》实现打开app，就有广告图片---》点击广告图片调整到app内部或者使用浏览器打开 # 一打开app，先打开的页面是什么，写app的人写的---》整一张大图充满全屏即可--》配合一个接口，返回一张大图 # app打开广告接口---》&#123;code:100,msg:成功,img:&#123;img:127.0.0.1/img/1.png,link:&#x27;www.baidu.com&#x27;,type:2&#125;&#125; link = models.CharField(max_length=64, verbose_name=&#x27;跳转链接&#x27;) # 在前端点击图片，会跳转到某个地址 info = models.TextField(verbose_name=&#x27;详情&#x27;) # 也可以用详情表，宽高出处 class Meta: db_table = &#x27;luffy_banner&#x27; verbose_name_plural = &#x27;轮播图表&#x27; def __str__(self): return self.title 2.2 迁移数据，创建超级用户123# python manage.py makemigrations ---》如果没有变化，是app没注册# python manage.py migrate# python manage.py createsuperuser ---&gt;创建个用户 2.3 引入simpleui12345678910111213141516171819202122# 下载pip install django-simpleui# 注册appINSTALLED_APPS = [ &#x27;simpleui&#x27;, ... ]# 在admin中写from django.contrib import adminfrom .models import Banner@admin.register(Banner)class BannerAdmin(admin.ModelAdmin): list_display = (&#x27;id&#x27;, &#x27;title&#x27;, &#x27;link&#x27;,&#x27;is_show&#x27;, &#x27;is_delete&#x27;) # 增加自定义按钮 actions = [&#x27;make_copy&#x27;] def make_copy(self, request, queryset): # 选中一些数据，点击 【自定义按钮】 触发方法执行，传入你选中 queryset # 保存，删除 print(queryset) make_copy.short_description = &#x27;自定义按钮&#x27; 2.4 轮播图接口12# 返回数据格式&#123;code:100,msg:成功，result:[&#123;img:地址，link:跳转地址，orders:顺序，title:名字&#125;,&#123;img:地址，link:跳转地址，orders:顺序，title:名字&#125;]&#125; 总路由 1234urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;api/v1/home/&#x27;, include(&#x27;home.urls&#x27;)), # http://127.0.0.1:8000/api/v1/home/banner/] home路由 12345678910from django.urls import path, includefrom rest_framework.routers import SimpleRouterfrom .views import BannerViewrouter = SimpleRouter()router.register(&#x27;banner&#x27;, BannerView, &#x27;banner&#x27;)urlpatterns = [ path(&#x27;&#x27;, include(router.urls)),] 视图类 12345678910111213from .models import Bannerfrom .serializer import BannerSerializerfrom utils.response import APIResponsefrom rest_framework.viewsets import GenericViewSetfrom rest_framework.mixins import ListModelMixinclass BannerView(GenericViewSet,ListModelMixin): # 获取所有接口-list，自动生成路由 queryset = Banner.objects.filter(is_delete=False,is_show=True).order_by(&#x27;orders&#x27;) serializer_class =BannerSerializer def list(self, request, *args, **kwargs): # 重写list res=super().list(request, *args, **kwargs) return APIResponse(result=res.data) 序列化类 1234567from rest_framework import serializersfrom .models import Bannerclass BannerSerializer(serializers.ModelSerializer): class Meta: model = Banner fields = [&#x27;title&#x27;, &#x27;image&#x27;, &#x27;link&#x27;, &#x27;orders&#x27;] 3 跨域问题详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# 现在写好了后端接口，前端加载数据---》加载不过来，报错，--》报跨域的错误# 同源策略 ---》浏览器的规定 -请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同，否则，加载回来的数据就会禁止 -前端：http://127.0.0.1:8080 -后端：http://127.0.0.1:8000 -这俩属于不同源，协议，地址一样，但是端口不一样，所以请求成功，但是到了浏览器被禁止掉了，因为浏览器的同源策略 -前后端分离，就会遇到这个问题，解决这个问题 # jsonp：出现了跨域问题---》有的东西不出跨域问题---》img，script，link--》回调# https://www.zhihu.com/question/19966531# 通过CORS（跨域资源共享）CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信----只需要在响应头中指定，允许跨域即可----# cors有两类请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）# 只要同时满足以下两大条件，就属于简单请求，否则就是非简单请求1-请求方法是以下三种方法之一：HEADGETPOST2-HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain问：post，josn格式是什么请求？ 非简单# 简单请求和非简单请求的区别简单请求：一次请求，直接发真正的请求，如果允许，数据拿回来，如果不允许，浏览器拦截非简单请求：两次请求，在发送数据之前会先发一次请求用于做“预检”，只有“预检”通过后才再发送一次请求用于数据传输。非简单请求发两次，第一次是OPTIONS请求，如果允许跨域，再发真正的请求# 解决跨域--&gt;分成简单和非简单请求处理 -简单请求再响应头中加入：&quot;Access-Control-Allow-Origin&quot;:&quot;*&quot; -非简单，咱们要加判断，如果是OPTIONS请求，在响应头中加入允许# 自行解决跨域---》django中写个中间件，处理跨域---&gt;配置到配置文件中from django.utils.deprecation import MiddlewareMixinclass CorsMiddleWare(MiddlewareMixin): def process_response(self,request,response): if request.method==&quot;OPTIONS&quot;: #可以加* response[&quot;Access-Control-Allow-Headers&quot;]=&quot;Content-Type&quot; response[&quot;Access-Control-Allow-Origin&quot;] = &quot;*&quot; return response # 经常遇到的东西，一定会有第三方解决方案---》我们使用第三方解决 -第一步：下载：pip install django-cors-headers -第二步：app中注册 INSTALLED_APPS = ( ... &#x27;corsheaders&#x27;, ... ) -第三步：中间件注册 MIDDLEWARE = [ # Or MIDDLEWARE_CLASSES on Django &lt; 1.10 ... &#x27;corsheaders.middleware.CorsMiddleware&#x27;, ... ] -第四步：配置文件配置CORS_ALLOW_CREDENTIALS = TrueCORS_ORIGIN_ALLOW_ALL = TrueCORS_ORIGIN_WHITELIST = ( &#x27;*&#x27;)CORS_ALLOW_METHODS = ( &#x27;DELETE&#x27;, &#x27;GET&#x27;, &#x27;OPTIONS&#x27;, &#x27;PATCH&#x27;, &#x27;POST&#x27;, &#x27;PUT&#x27;, &#x27;VIEW&#x27;,)CORS_ALLOW_HEADERS = ( &#x27;XMLHttpRequest&#x27;, &#x27;X_FILENAME&#x27;, &#x27;accept-encoding&#x27;, &#x27;authorization&#x27;, &#x27;content-type&#x27;, &#x27;dnt&#x27;, &#x27;origin&#x27;, &#x27;user-agent&#x27;, &#x27;x-csrftoken&#x27;, &#x27;x-requested-with&#x27;, &#x27;Pragma&#x27;,) 4 前后端打通12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div class=&quot;banner&quot;&gt; &lt;el-carousel :interval=&quot;5000&quot; arrow=&quot;always&quot; height=&quot;400px&quot;&gt; &lt;el-carousel-item v-for=&quot;item in banner_list&quot;&gt; &lt;img :src=&quot;item.image&quot; alt=&quot;&quot;&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Banner&quot;, data()&#123; return &#123; banner_list:[] &#125; &#125;, created() &#123; this.$axios.get(this.$settings.base_url+&#x27;home/banner/&#x27;).then(res=&gt;&#123; if(res.data.status==100)&#123; this.banner_list=res.data.result console.log(this.banner_list) &#125; &#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; el-carousel-item &#123; height: 400px; min-width: 1200px; &#125; .el-carousel__item img &#123; height: 400px; margin-left: calc(50% - 1920px / 2); &#125;&lt;/style&gt; 5 后端自定义配置12345678# 在setting文件夹下新建 user_settings.py# 用户自己的配置，单独放到另一个py文件中BANNER_COUNT=3# 在dev.py中导入# 导入用户自定义的配置from .user_settings import * 6 git介绍和安装12345678910111213# 公司里是协同开发，多人开发同一个项目# 代码已经写到v3版本了，忽然想看一下v1版本什么样# git:代码版本管理工具，软件，同类型的是svn，用得少 -帮助开发者合并开发的代码 -如果出现冲突代码的合并，会提示后提交合并代码的开发者，让其解决冲突 -做代码版本管理，可以快速回到某个版本上 # win：下载https://git-scm.com/download # mac下载：https://github.com/timcharper/git_osx_installer/releases/download/2.2.1/git-2.2.1-intel-universal-mavericks.dmg# 一路下一步，其他都不用选","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"02、二次封装Response、后台数据库配置、user模块user表设计、前台创建与配置","slug":"luffy_day02","date":"2021-07-28T06:04:02.000Z","updated":"2022-05-14T05:15:52.554Z","comments":true,"path":"2021/07/28/luffy_day02/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day02/","excerpt":"","text":"复习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 企业软件类型--&gt;内部系统，给客户定制的系统# 企业软件开发流程--》你平时工作开发流程是什么# 软件开发模式 -瀑布 -敏捷开发 # pip换源 -pip install -i 源的地址 包名 -pip install -r requirements.txt 一会讲 npm install 类似于 pip install -r requirements.txt -拿到一个新项目--》本地跑起来 -python解释器版本---》统一起来 -装第三方模块：在他机器上装不上(win:好多模块装不了)---》单独找出装不上的模块，单独解决 -配置数据库 -本地运行 -用户家路径 新建 pip 文件---&gt;pip.ini ---&gt;配置源地址 -有时候，装不上模块---》豆瓣源可能有的模块不是最新---&gt;换个源再装 -i # 虚拟环境 -解决同一个机器上有多个项目，多个项目使用的模块版本不一致的问题 -虚拟环境来解决这个问题 -每一个项目有一个虚拟环境，自己的虚拟环境装自己的模块，系统的解释器(不装模块) -pycharm中如何创建---》注意再装模块，确认好装在哪里了 pip -以后要清楚 python命令和pip命令指的是谁---》重命名 -环境变量 -用户环境变量：登陆用户 -系统环境变量：所有使用 -在任意路径执行命令能够找到---》win下xx.exe或者xx.bat mac和linux下 xx或者xx.sh -敲命令，查找路径，先在自己路径下找，用户环境变量的path中找，系统环境变量的path中 -装python解释器，任意路径下执行python，pip 能执行---》自动把python解释器路径和解释器路径下的scripts文件夹加入到了环境变量 -mac，linux：用户环境变量(用户家路径下)和系统环境变量 -win下 -安装两个模块 -配置虚拟环境创建路径：workonhome=D:\\vir -创建虚拟环境，建在这个目录下了 -mac，linux下 -安装两个模块 -virtualenvwrapper.sh 放到环境变量 -配置环境变量：用户环境变量 ~/.bash_profile VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3 source /usr/local/bin/virtualenvwrapper.sh -虚拟环境的创建，查看，删除，进入，退出命令 -用户和权限 -linux ：root，普通用户 -mac: root，你的名字用户，有些文件它操作不了---&gt;sudo -win: 通常情况，默认登陆用户admin，你的名字的用户权限低 # 后端项目创建---》目录调整 -多套配置文件：开发，上线环境不一样--》manage.py,wsgi.py -app都放在apps路径下下，但是注册app还是以app名字注册--》把apps路径加入到环境变量 -把BASE_DIR加入到环境变量 -创建了几个包(文件夹)，分别存放不通的代码 -python ../../manage.py startapp app名字 # 后端记录日志 -把Log大字典复制到配置文件中 -logging.py ---&gt;生成一个logger对象 -以后写日志的时候，把logger对象导入直接用即可---》日志写到控制台，写到文件中 # 处理全局异常 -加入日志记录# 导出项目依赖模块和安装项目依赖模块 -第三方模块---》导出来---》项目路径下--》requirements.txt -第三方模块名字和版本 pip freeze &gt;requirements.txt -pip3 install -r requirements.txt # 文件中所有模块装上 1 二次封装Response1234567# drf有个Response类 -data=None, &#123;&#x27;status&#x27;:100,&#x27;msg&#x27;:&#x27;成功&#x27;,&#x27;token&#x27;:asedfasfd3a21&#125; -status=None, -template_name=None, -headers=None, -exception=False, -content_type=None 2 后台数据库配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 使用mysql---》创建一个库(手动)--》库名：luffy# 项目配置文件中，连接这个数据库### 创建数据库，并配置-create database luffy default charset=utf8;### 给数据库创建一个lqz用户，它只能操作luffy库---》万一你的lqz用户密码泄露了--》# 查看用户# 5.7之前版本select user,host,password from mysql.user;# 5.7往后的版本select user,host,authentication_string from mysql.user;## 创建用户# 授权账号命令：grant 权限(create, update) on 库.表 to &#x27;账号&#x27;@&#x27;host&#x27; identified by &#x27;密码&#x27;grant all privileges on luffy.* to &#x27;lqz&#x27;@&#x27;%&#x27; identified by &#x27;Luffy123?&#x27;;grant all privileges on luffy.* to &#x27;lqz&#x27;@&#x27;localhost&#x27; identified by &#x27;Luffy123?&#x27;;# mysql -h 127.0.0.1 -P 3306 -uroot -p# mysql -uroot -p 有区别，如果在本地连接，使用这个，速度会快# 刷新权限flush privileges;## 项目配置文件加入 &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;luffy&#x27;, # 数据库名字 &#x27;USER&#x27;: &#x27;lqz&#x27;, # 用户名 &#x27;PASSWORD&#x27;: &#x27;Luffy123?&#x27;, &#x27;HOST&#x27;: &#x27;localhost&#x27;, &#x27;PORT&#x27;: 3306 &#125; ### django操作mysql -模式使用MysqlDB来操作---》MysqlDB在python3.x以后不存在了 -使用pymysql替换---》django2.0.7版本及以上，如果使用pymysql替换，需要改django源码 ### 关于pymysql和mysqlclient的选择 # 这两句话，只要执行即可，放在那里都行---》只要django执行，所有py文件中顶格写的代码都会执行 # 作用是？猴子补丁，动态替换 ---&gt;python一切皆对象，可以动态替换对象 # 如果该源码，后期只要使用django，都要改它的源码 # 所以咱们换另一个操作mysql的模块，mysqlclient---》MysqlDB的3版本--》有可能装不上--》win上看人品，实在装不上用whl文件装 linux上有不同解决方案 # http://www.liuqingzheng.top/python/%E5%85%B6%E4%BB%96/01-%E5%90%84%E4%B8%BB%E6%B5%81Linux%E7%B3%BB%E7%BB%9F%E8%A7%A3%E5%86%B3pip%E5%AE%89%E8%A3%85mysqlclient%E6%8A%A5%E9%94%99/ # import pymysql # pymysql.install_as_MySQLdb() #### 使用mysqlclient不需要写两句话，不用改源码 3 user模块user表设计1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 用户板块---》做成apppython ../../manage.py startapp user# 创建用户表，基于auth的user表扩写### 注意：在写好这个之前，不要先迁移数据，如果迁移了数据库，这个就不行了### 如果你已经迁移了，删除数据库，删除所有的migrations文件，包含你自己的app，和auth和admin这两个app## models.pyfrom django.db import modelsfrom django.contrib.auth.models import AbstractUserclass User(AbstractUser): mobile = models.CharField(max_length=11, unique=True) # 唯一，长度11 # 需要pillow包的支持 ImageField继承自FileField icon = models.ImageField(upload_to=&#x27;icon&#x27;, default=&#x27;icon/default.png&#x27;) class Meta: db_table = &#x27;luffy_user&#x27; verbose_name = &#x27;用户表&#x27; verbose_name_plural = verbose_name def __str__(self): return self.username # 配置文件---》注册表 INSTALLED_APPS = [ # ... &#x27;user&#x27;, ] # 自定义User表 AUTH_USER_MODEL = &#x27;user.User&#x27; ## 配置media MEDIA_URL = &#x27;/media/&#x27; MEDIA_ROOT = os.path.join(BASE_DIR, &#x27;media&#x27;) # 安装pillow ，迁移 pip install pillow python manage.py makemigrations python manage.py migrate 4 前台创建及配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# 创建项目vue create luffycity# 使用pycharm打开# 删除一些东西### APP.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;## HomeView.vue&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;HomeView&#x27;, components: &#123; &#125;&#125;&lt;/script&gt;## router下的index.js const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: HomeView &#125;,]### elementui ,bootstrap,jquery,axios配置# axioscnpm install axios -S## main.jsimport axios from &#x27;axios&#x27;Vue.prototype.$axios = axios;#elementuicnpm install element-ui -S## main.jsimport ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;Vue.use(ElementUI);# bootstrap和jqcnpm install jquery -Scnpm install bootstrap@3 -S## vue.config.jsmodule.exports = &#123; configureWebpack: &#123; plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot;, &quot;window.$&quot;: &quot;jquery&quot;, Popper: [&quot;popper.js&quot;, &quot;default&quot;] &#125;) ] &#125;&#125;;## main.jsimport &#x27;bootstrap&#x27;import &#x27;bootstrap/dist/css/bootstrap.min.css&#x27;### 全局css样式配置##assets/css/global.css/* 声明全局样式和项目的初始化样式 */body, h1, h2, h3, h4, h5, h6, p, table, tr, td, ul, li, a, form, input, select, option, textarea &#123; margin: 0; padding: 0; font-size: 15px;&#125;a &#123; text-decoration: none; color: #333;&#125;ul &#123; list-style: none;&#125;table &#123; border-collapse: collapse; /* 合并边框 */&#125;## main.js// 把自己定义的global.css 引入import &#x27;./assets/css/global.css&#x27;## 配置文件配置# assets/js/settings.jsexport default &#123; base_url: &quot;http://127.0.0.1:8000&quot;&#125;# main.js // 把自己定义的global.css 引入import &#x27;./assets/css/global.css&#x27;// 导入自定义配置import settings from &#x27;./assets/js/settings&#x27;Vue.prototype.$settings = settings; 1讲到哪写到哪","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"01、企业中项目类型与开发流程、pip换源、虚拟环境介绍与搭建、项目后台创建与目录调整、项目后台配置（日志、处理全局异常）","slug":"luffy_day01","date":"2021-07-28T06:04:01.000Z","updated":"2022-05-14T05:14:13.902Z","comments":true,"path":"2021/07/28/luffy_day01/","link":"","permalink":"https://chenxiao0629.github.io/2021/07/28/luffy_day01/","excerpt":"","text":"1 项目基础1.1 企业中项目类型123456789101112131 商城类的---》某某团2 门户网站[企业站和门户站] -新加坡--》游戏的展示页面 -展示页面3 社交网络 --》app后端4 咨询论坛 -技术类---》卖课，卖资料5 内部系统---》python做这种多 -办公管理，人事管理，进销存，客户关系管理(crm) -自动化运维项目 -自动化测试项目6 个人博客7 内容收费网站 1.2 企业项目开发流程123456789101112131415161718192021222324252627282930313233343536# 公司项目来源 -公司需要用 -给客户定制 -互联网项目 # 立项---》需求分析(产品经理，技术人员)---》产品原型---&gt;前端后端# 前端：根据原型图：ui+前端---》ui切图---》前端实现---》mock数据(自己造的假数据)# 后端：确立项目架构，技术选型----》需求说明书+原型图---》开发接口，自己测试--》接口文档# 前后端代码整合---》前后端联调---》集成测试(测试部，质量控制部)# 上线# 你们的工作流程：在公司项目管理平台(禅道)---》看自己任务----》确定需求(测试,问领导,问同事)---》写代码--》提交到git仓库---》管理平台把需求设置成完成# 软件开发模式 -瀑布模式：早期被广泛采用的软件开发模型---》bbs项目 -敏捷开发：不停的开发--》测试---》上线转圈 -scrum---》Sprint周期(小功能从开发到完成的时间)---》1周 -不做整体数据库的设计---》写到哪个版块，再去设计相关表# 路飞项目需求 -首页轮播图 -登陆注册 -多方式登陆，手机号登陆 -手机号注册 -课程列表 -过滤，排序 -课程详情 -视频播放，课程介绍 -下单--》支付 -支付宝支付 -回调修改订单 -上线 2 pip换源123456789101112131415161718192021222324252627282930# pip install pypi源下载源码，在国外，比较慢---》镜像(pypi在国内备份)---&gt;豆瓣，清华，阿里# pip install -i 源地址 模块名 临时生效# 想以后只要 pip install django---》直接从国内下载# 配置---》永久生效# win平台1、文件管理器文件路径地址栏敲：%APPDATA% 回车，快速进入 C:\\Users\\电脑用户\\AppData\\Roaming 文件夹中2、新建 pip 文件夹并在文件夹中新建 pip.ini 配置文件3、新增 pip.ini 配置文件内容# mac/linux1、在用户根目录下 ~ 下创建 .pip 隐藏文件夹，如果已经有了可以跳过 -- mkdir ~/.pip2、进入 .pip 隐藏文件夹并创建 pip.conf 配置文件 -- cd ~/.pip &amp;&amp; touch pip.conf3、启动 Finder(访达) 按 cmd+shift+g 来的进入，输入 ~/.pip 回车进入4、新增 pip.conf 配置文件内容# pycharm中换源，只针对于在pycharm中用 settings---&gt;解释器---》安装模块--》 # pycharm中的terminal不是和cmd一样# pypi Python官方模块站点，我们个人也可以传模块 -注册账号 -写一个模块 -setup.py -上传 3 虚拟环境介绍和搭建3.1 pycharm设置虚拟环境12345678910111213141516# 为什么会出现虚拟环境？ -假设有个项目django 1.11.8 -又有个项目django 2.2.2 -由于在系统的解释器上只能装一个django，导致同时只能跑一个项目 -每个项目使用自己的一个解释器---》虚拟环境--》通过系统解释器创造出一个解释器环境，他俩相互不干扰 -系统有解释器，第一个项目有个虚拟环境 django1.11.8 ,第二个项目有个虚拟环境 django 2.2.2 -以后变成，一个项目一个解释器# 其他语言相关方案 -vue 项目路径下--》node moduls---》这个项目依赖的环境--》删除---》npm install -go：go mod解决多版本共存问题 -java：maven解决多版本jar包问题 -python：虚拟环境 # python中虚拟环境解决方案有好几个(virtualenv,pipenv。。。。)# 如果不使用virtualenv，可以直接在pycharm中做 3.2 命令方式操作虚拟环境3.2.1 win安装12345678910111213141516171819# centos没有图形化界面的话---&gt;没法装pycharm---》没法点点点创建，只能使用命令# 虚拟环境命令的配置方案# win环境## 第一步：安装pip3 install virtualenv # 虚拟环境模块--》创建虚拟环境麻烦pip3 install virtualenvwrapper-win # 虚拟环境辅助模块---》更快捷方便的操作和管理虚拟环境# 安装完，在script文件夹下就会有virtualenv.exe和virtualenvwrapper.bat批处理文件# 而你的script文件夹又在环境变量里--》这俩命令可以在任意路径下执行## 第二步：配置环境# 控制面板 =&gt; 系统和安全 =&gt; 系统 =&gt; 高级系统设置 =&gt; 环境变量 =&gt; 系统变量 =&gt; 点击新建 =&gt; 填入变量名与值变量名：WORKON_HOME 变量值：自定义存放虚拟环境的绝对路径eg: WORKON_HOME: D:\\Virtualenvs# 同步配置信息：# 去向Python3的安装目录 =&gt; Scripts文件夹 =&gt; virtualenvwrapper.bat =&gt; 双击 3.2.2 Mac linux安装1234567891011121314151617181920212223# mac和linux## 第一步安装pip3 install -i https://pypi.douban.com/simple virtualenvpip3 install -i https://pypi.douban.com/simple virtualenvwrapper## 第二步:找到virtualenvwrapper先找到virtualenvwrapper的工作文件 virtualenvwrapper.sh，该文件可以刷新自定义配置，但需要找到它MacOS可能存在的位置 /Library/Frameworks/Python.framework/Versions/版本号文件夹/binLinux可能所在的位置 /usr/local/bin | ~/.local/bin | /usr/bin建议不管virtualenvwrapper.sh在哪个目录，保证在 /usr/local/bin 目录下有一份如果不在 /usr/local/bin 目录，如在 ~/.local/bin 目录，则复制一份到 /usr/local/bin 目录 -- sudo cp -rf ~/.local/bin/virtualenvwrapper.sh /usr/local/bin### 第三步：配置环境变量# 在 ~/.bash_profile 完成配置，virtualenvwrapper的默认默认存放虚拟环境路径是 ~/.virtualenvs# WORKON_HOME=自定义存放虚拟环境的绝对路径，需要自定义就解注VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3source /usr/local/bin/virtualenvwrapper.sh# 在终端让配置生效： -- source ~/.bash_profile 3.3 虚拟环境命令12345678910111213141516171819202122232425## 虚拟环境命令# 1、创建虚拟环境到配置的WORKON_HOME路径下# 选取默认Python环境创建虚拟环境： -- mkvirtualenv 虚拟环境名称# 基于某Python环境创建虚拟环境,并进入到虚拟环境： -- mkvirtualenv -p python2.7 虚拟环境名称 -- mkvirtualenv -p python3.6 虚拟环境名称# 2、查看已有的虚拟环境 -- workon# 3、使用某个虚拟环境 -- workon 虚拟环境名称 # 4、进入|退出 该虚拟环境的Python环境 -- python | exit()# 5、为虚拟环境安装模块 -- pip或pip3 install 模块名# 6、退出当前虚拟环境 -- deactivate# 7、删除虚拟环境(删除当前虚拟环境要先退出) -- rmvirtualenv 虚拟环境名称 3.4 补充环境变量123456789101112131415# 补充： -环境变量：在命令行下敲某个命令，为什么能执行？---》要么这个命令就在当前路径下,要么在环境变量的path路径下, 如果能找到就执行，找不到就报错 -环境变量有两种：用户环境变量--》当前用户有效，系统环境变量--》所有人都有效 -敲python---》确认好，python到底是python2，还是python3，还是你的虚拟环境的python3 环境变量的上下顺序 -pip 和python 成对的，装的模块，给python解释器用的 pip3 install django -python3.6---》pip3 python3.10---》pip3 -更有甚者：创建了虚拟环境---》虚拟环境有pip---》把虚拟环境的pip加入到了环境变量 -pip3 install django -通过起别名方式来多版本共存 -python3.6 python3.10 -pip3.6 pip3.10 菜单管理：配置系统菜单，操作权限，按钮权限标识、后端接口权限等。 部门管理：配置系统组织机构（公司、部门、角色）。 角色管理：角色菜单权限分配、数据权限分配、设置角色按部门进行数据范围权限划分。 权限权限：授权角色的权限范围。 用户管理：用户是系统操作者，该功能主要完成系统用户配置。 接口白名单：配置不需要进行权限校验的接口。 字典管理：对系统中经常使用的一些较为固定的数据进行维护。 地区管理：对省市县区域进行管理。 附件管理：对平台上所有文件、图片等进行统一管理。 操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。 4 luffy后台创建和目录调整12# 第一步：进入luffy虚拟环境安装django# 第二步：使用pycharm创建后台路飞项目--》选择解释器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 第三步，调整目录 #### 调整配置文件 -把配置文件移动到setting文件夹下了，改名为dev.py,又新建了一个pro.py -dev.py:开发阶段用的配置 -pro.py：上线阶段用的配置 -manage.py 中指向的配置文件，改成咱么修改后路径 -控制台:python manage.py runserver 或者点绿色箭头就可以启动项目了 ### 调整app的路径，以后把所有app都放到luffy_api下的apps文件夹---》整洁 -切换到apps路径下，执行创建app的命令 -python ../../manage.py startapp user -在dev.py中注册app，运行报错，报错原因是找不到user这么模块 -原来直接写app名字不报错--》原因是app就在项目根路径下(模块的查找)--》由于项目的根路径在环境变量中，app就在根路径下，它能直接找到 -现在的问题是apps路径不在环境变量中，它就找不到 -把apps的路径加入到环境变量中--》要在项目的启动时加--》启动入口是配置文件 -到配置文件中：写入 sys.path.append(os.path.join(BASE_DIR,&#x27;apps&#x27;)) -以后再INSTALLED_APPS中只需要写app的名字即可 #### 新建 logs文件夹，luffy_api/lib文件夹,luffy_api/utils文件夹，script文件夹### 测试阶段运行没问题，项目上线，使用uwsgi上线---》运行wsgi.py--&gt;修改如下os.environ.setdefault(&#x27;DJANGO_SETTINGS_MODULE&#x27;, &#x27;luffy_api.setting.pro&#x27;)### 国际化LANGUAGE_CODE = &#x27;zh-hans&#x27;TIME_ZONE = &#x27;Asia/Shanghai&#x27;USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False## 把 小luffy_api也就是BASE_DIR 也加入到环境变量sys.path.append(BASE_DIR)导入模块的时候，只要从环境变量的路径开始导就可以了，从小luffy_api路径开始导入即可但是pycharm爆红，但是没有错，点右键，把该路径(在环境变量中的)，做成source root即可以后再从这个路径下导包，不会报错了### 注意：以后导入包 -尽量用最短路径导入，如果从长路径导入--》路径经过的py文件都会去执行--》可能会导致循环导入的问题 -我个人推荐用相对导入 # from apps.user import models from . import models 推荐用这个 -py文件中有相对导入，这个py文件不能作为脚本运行 -django项目中，由于没有右键运行的脚本，所以都可以用相对导入### 项目目录结构&quot;&quot;&quot;├── luffy_api ├── logs/ # 项目运行时/开发时日志目录 - 包 ├── luffy_api/ # 项目主应用，开发时的代码保存 - 包 ├── apps/ # 开发者的代码保存目录，以模块[子应用]为目录保存 - 包 ├── libs/ # 第三方类库的保存目录[第三方组件、模块] - 包 ├── setting/ # 配置目录 - 包 ├── dev.py # 项目开发时的本地配置 └── prod.py # 项目上线时的运行配置 ├── urls.py # 总路由 └── utils/ # 多个模块[子应用]的公共函数类库[自己开发的组件] ├── manage.py # 脚本文件 └── scripts/ # 保存项目运营时的脚本文件 - 文件夹&quot;&quot;&quot; 5 luffy后台配置5.1 配置日志在配置文件中加入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859LOGGING = &#123; &#x27;version&#x27;: 1, &#x27;disable_existing_loggers&#x27;: False, &#x27;formatters&#x27;: &#123; &#x27;verbose&#x27;: &#123; &#x27;format&#x27;: &#x27;%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s&#x27; &#125;, &#x27;simple&#x27;: &#123; &#x27;format&#x27;: &#x27;%(levelname)s %(module)s %(lineno)d %(message)s&#x27; &#125;, &#125;, &#x27;filters&#x27;: &#123; &#x27;require_debug_true&#x27;: &#123; &#x27;()&#x27;: &#x27;django.utils.log.RequireDebugTrue&#x27;, &#125;, &#125;, &#x27;handlers&#x27;: &#123; &#x27;console&#x27;: &#123; # 实际开发建议使用WARNING &#x27;level&#x27;: &#x27;DEBUG&#x27;, &#x27;filters&#x27;: [&#x27;require_debug_true&#x27;], &#x27;class&#x27;: &#x27;logging.StreamHandler&#x27;, &#x27;formatter&#x27;: &#x27;simple&#x27; &#125;, &#x27;file&#x27;: &#123; # 实际开发建议使用ERROR &#x27;level&#x27;: &#x27;INFO&#x27;, &#x27;class&#x27;: &#x27;logging.handlers.RotatingFileHandler&#x27;, # 日志位置,日志文件名,日志保存目录必须手动创建，注：这里的文件路径要注意BASE_DIR代表的是小luffyapi &#x27;filename&#x27;: os.path.join(os.path.dirname(BASE_DIR), &quot;logs&quot;, &quot;luffy.log&quot;), # 日志文件的最大值,这里我们设置300M &#x27;maxBytes&#x27;: 300 * 1024 * 1024, # 日志文件的数量,设置最大日志数量为10 &#x27;backupCount&#x27;: 10, # 日志格式:详细格式 &#x27;formatter&#x27;: &#x27;verbose&#x27;, # 文件内容编码 &#x27;encoding&#x27;: &#x27;utf-8&#x27; &#125;, &#125;, # 日志对象 &#x27;loggers&#x27;: &#123; &#x27;django&#x27;: &#123; &#x27;handlers&#x27;: [&#x27;console&#x27;, &#x27;file&#x27;], &#x27;propagate&#x27;: True, # 是否让日志信息继续冒泡给其他的日志处理系统 &#125;, &#125;&#125;### 在utils下简历logging.pyimport logging# 创造一个logger对象，使用的是配置文件中的django这个logger = logging.getLogger(&#x27;django&#x27;)## 以后使用，导入直接用--》打印到控制台和记录到文件中from utils.logging import loggerlogger.info(&quot;我执行了一下&quot;) 5.2 处理全局异常utils&#x2F;excepiton.py 1234567891011121314151617181920## 全局异常捕获from rest_framework.views import exception_handler # 默认没有配置，出了异常会走它from rest_framework.response import Responsefrom utils.logging import loggerdef common_exception_handler(exc, context): res = exception_handler(exc, context) if res: res = Response(data=&#123;&#x27;code&#x27;: 998, &#x27;msg&#x27;: res.data.get(&#x27;detail&#x27;, &#x27;服务器异常，请联系系统管理员&#x27;)&#125;) else: res = Response(data=&#123;&#x27;code&#x27;: 999, &#x27;msg&#x27;: str(exc)&#125;) request = context.get(&#x27;request&#x27;) view = context.get(&#x27;view&#x27;) logger.error(&#x27;错误原因：%s,错误视图类：%s,请求地址：%s,请求方式：%s&#x27; % (str(exc), str(view), request.path, request.method)) return res dev.py中 123REST_FRAMEWORK = &#123; &#x27;EXCEPTION_HANDLER&#x27;: &#x27;utils.exception.common_exception_handler&#x27; # 再出异常，会执行这个函数&#125; 1讲到哪写到哪","categories":[],"tags":[{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"}]},{"title":"05、vue-cli脚手架（创建项目、目录介绍、运行项目、es6语法之导入导出、定义并使用组件、继承bootstrap、jQuery、elementui、与后端交互）","slug":"vue_day05","date":"2021-06-28T06:04:05.000Z","updated":"2022-05-14T05:04:38.867Z","comments":true,"path":"2021/06/28/vue_day05/","link":"","permalink":"https://chenxiao0629.github.io/2021/06/28/vue_day05/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031# 1 计算属性 -computed---&gt;把方法变成属性---》延缓计算 -在页面中直接使用函数，页面只要刷新，函数就会重新运行，使用计算属性--》只有当前函数使用的变量发生变化时，才重新运算 # 2 监听属性 -watch:属性----》只要这个变量发生变化，就会执行方法 # 3 组件化开发 -局部组件:写在组件内部：Vue.components -全局组件：Vue.component() -组件有自己的html，css，js，相互不影响 -template 一定要放在一个标签中 -data必须是函数data()&#123;retrun &#123;&#125; &#125; -各级组件的data数据是不共享的 # 4 组件间通信 -通过自定义属性：父传子---》自定义的属性写在自定义的组件上---》props:[&#x27;自定义属性名&#x27;] -通过自定义事件：子传父---》子中调用this.$emit(&#x27;自定义事件名&#x27;,参数，参数)--》触发写在定义组件上的 @自定义事件名=&#x27;函数&#x27;---》函数执行(父组件) -ref属性： 放在普通标签---》通过this.$refs.属性值---》原生dom 放在组件上---》通过this.$refs.属性值---》当前组价对象---》拿到组件中的值，执行组件中的方法 # 5 动态组件 -多个组件切换，通过动态组件的is来决定显示哪个组件 -keep-alive：组件切换的时候不销毁 # 6 插槽 -&lt;组件&gt;写内容&lt;/组件&gt;---》如果定义了插槽---》替换到插槽中 -具名插槽---》给插槽名名字---》使用的时候，指定替换哪个插槽的内容 1 vue-cli创建项目12345678910111213141516# 单文件组件--&gt;一个文件,以 xx.vue 命名，就是一个组件# vue-cli创建项目，webpack构建---》nodejs环境 -nodejs是一门后端语言--》javascript解释型语言，只能运行在解释器中---》浏览器中集成了js的解释器---》javascript只能运行在浏览器中---》谷歌浏览器的v8引擎---》运行在操作系统之上---》os，网络通信的模块，文件处理---》nodejs的解释器 -http://nodejs.cn/---》一路下一步---》cmd命令窗口下---》node命令(python)，npm命令(pip) -以往版本：https://nodejs.org/zh-cn/download/releases/ # 在nodejs的环境上装vue-cli：vue脚手架 -npm install -g cnpm --registry=https://registry.npm.taobao.org -以后使用cnpm替换掉npm即可：下载速度快 -cnpm install -g @vue/cli # 速度慢，淘宝写了工具 cnpm，完全替换npm的功能，使用cnpm回去淘宝镜像站下载，速度快 # 创建项目---》git上拉取 -方式一：命令行方式 -vue create myfirstvue -方式二：图形化界面 -vue ui # 会启动一个服务，用浏览器访问创建vue项目 12345# GUI ：图形化界面， GUI编程---》图形化界面编程# C#做win平台的图形化界面# python写图形化界面：Tkinter# pyqt: qt是个平台，可以使用c语言，使用python在平台写代码---》做图形化界面 2 vue项目目录介绍运行项目1234567891011121314151617181920212223242526272829303132# 运行项目方式一 在项目路径下:npm run serve # 使用pycharm运行 -点击绿色箭头运行# 目录介绍 -myfirstvue # 项目名字 -node_modules # 放着当前项目所有的依赖，可以删除，删除项目运行不了了,npm install 把该项目的依赖再装上，把项目发给别人，提交到git上，文件夹要删掉 -public # 文件夹 -favicon.icon # 小图标 -index.html # 单页面开发，整个项目就这一个页面，以后不要动 -src # 以后咱们都是在这里面写东西 -assets # 放静态资源，图片，js，css -components # 组件，xx.vue组件，小组件，给页面组件用 -HelloWorld # 提供的默认组件，示例 -router # vue-router就会有这个文件夹 -index.js # vue-router的js代码 -store # vuex 就会有这个文件夹 -index.js # vuex 的js代码 -views # 组件，页面组件 -About -Home # 默认提供了示例组件 -App.vue # 根组件 -main.js # 项目的入口于 -.gitignore # git的忽略文件 -babel.config.js # babel配置 -package.json # 项目的所有依赖，类似于 requirements.txt,不要删，npm install根据这个文件下载第三方模块 -vue.config.js # vue的配置 3 es6语法之导入导出123456789101112131415161718192021222324252627# js 模块化开发--》模块，包的概念# 写了一个包，在其他js中导入使用# 导入# import 起个名字 from &#x27;路径&#x27;# import Vue from &#x27;vue&#x27; # 起了个名字叫Vue，vue在node_modules中了，直接写名字即可// 演示代码--》导入使用--》拿到的就是导出的对象import settings from &#x27;../assets/js/settings&#x27;console.log(settings.name)console.log(settings.printName())# 导出# export default 对象let name = &#x27;lqz&#x27;function printName() &#123; console.log(name)&#125;// 把对象导出export default &#123;name:name,printName:printName&#125;# 包的导出---》文件夹下新建index.js # 包导入的时候，导到文件夹这一层即可import lqz from &#x27;../lqz&#x27;console.log(lqz.name) 4 定义并使用组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 新建一个 xx.vue,内部包含三块 -&lt;template&gt;&lt;/template&gt; # 写原来模板字符串`` html内容 -&lt;script&gt; export default &#123; data()&#123;retrun &#123; name:&#x27;lqz&#x27; &#125;&#125;, methods:&#123;&#125;, &#125; &lt;/script&gt; -&lt;style scoped&gt; # scoped 样式只在当前组件中生效 &lt;/style&gt; # 自定义组件&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;handleC&quot;&gt;点我看美女&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Lqz&quot;, data()&#123; return &#123; name:&quot;lqz is nb&quot; &#125; &#125;, methods:&#123; handleC()&#123; alert(&#x27;美女&#x27;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;h1 &#123; background: pink; font-size: 60px; text-align: center;&#125;&lt;/style&gt; 5 集成bootstrap，jQuery，elementui1234567891011121314151617181920212223242526272829# bootstrap---》ui---》后期一般不用bootstap -第一步：下载 -cnpm install bootstrap@3 -S # -S表示把当前模块加入到package.json文件中 -cnpm install jquery -第二步在main.js中配置 // bootstrap的配置 import &#x27;bootstrap&#x27; import &#x27;bootstrap/dist/css/bootstrap.min.css&#x27; -第三步:vue.config.js中 const &#123;defineConfig&#125; = require(&#x27;@vue/cli-service&#x27;) const webpack = require(&quot;webpack&quot;); module.exports = defineConfig(&#123; transpileDependencies: true, configureWebpack: &#123; plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot;, &quot;window.$&quot;: &quot;jquery&quot;, Popper: [&quot;popper.js&quot;, &quot;default&quot;] &#125;) ] &#125;, &#125;) 5.2 elementui12345678910# 专门给vue的ui库--》写ui尽量用它第一步：下载cnpm install element-ui -S第二步：main.js 配置import ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;Vue.use(ElementUI); 6 与后端交互1234567891011121314151617第一步：安装cnpm install axios -S第二步：main.js 配置import axios from &#x27;axios&#x27;Vue.prototype.$axios = axios;第三步：使用# 在任意组件中# this.$axios 就是axios对象this.$axios.get().then(res=&gt;&#123;&#125;)第三步：如果没有第二步的配置# 在任意组件中import axios from &#x27;axios&#x27;axios.get(&#x27;&#x27;).then(res=&gt;&#123;&#125;) 12# 后端起个flask项目，django(解决跨域)# 写个电影的显示---》elemenui的样式做好看一些","categories":[],"tags":[{"name":"8、vue笔记","slug":"8、vue笔记","permalink":"https://chenxiao0629.github.io/tags/8%E3%80%81vue%E7%AC%94%E8%AE%B0/"}]},{"title":"04、计算属性、侦听属性、局部组件与全局组件、组件通信（父传子自定义属性、子传父自定义事件（冒泡）、ref属性、动态组件与keep-alive、插槽（普通插槽、具名插槽））","slug":"vue_day04","date":"2021-06-28T06:04:04.000Z","updated":"2022-05-14T05:02:40.235Z","comments":true,"path":"2021/06/28/vue_day04/","link":"","permalink":"https://chenxiao0629.github.io/2021/06/28/vue_day04/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728# 1 购物车--》checkbox多选 -数组，选中了什么，value值就会放到数组中 -&#123;&#123;函数()&#125;&#125;---&gt;页面更新函数执行 -计算总价格--》for 循环checkbox的数组---&gt;4种循环 -js：迭代循环，索引循环 -python：迭代循环， rang， 没有索引循环# 2 全选和全不选 -checkbox的单选---》布尔 -change事件---》上面checkbox多选的数组放满，置空 -给每条标签加了个change事件 # 3 购物车数量加减 -button---&gt;加事件 -减---》函数--》限制不能少于1 # 4 生命周期钩子函数 8个 -根组件，自定义组件---》生命周期 -create:向后端发请求拿数据 -mounted：设置定时器 -destoryed：清空定时器 -setTimeout，setInterval---&gt;箭头函数 # 5 跟后端交互（axios） -jquery的ajax方法 -fetch---》不易用 -axios--》引入---》get，post---》res.data 才是真正的数据 1 计算属性123# 插值的普通函数，只要页面一刷新，函数就会重写计算，跟函数没关的值的变化，函数也会重写计算# 把函数当成属性来用---》只有这个函数使用的属性(变量)变化，函数才重写运算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;mytest2&quot;&gt;--&gt;&#123;&#123;mytest2&#125;&#125; &lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;mytext&quot;&gt;---&gt;&#123;&#123;mytext.substring(0,1).toUpperCase()+mytext.substring(1)&#125;&#125; &lt;br&gt; 函数方式：&#123;&#123;getName()&#125;&#125; &lt;br&gt; 计算属性:&#123;&#123;getName2&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; mytext: &#x27;&#x27;, mytest2: &#x27;&#x27;, &#125;, methods:&#123; getName()&#123; console.log(&quot;我执行了&quot;) return this.mytext.substring(0,1).toUpperCase()+this.mytext.substring(1) &#125; &#125;, // 8生命周期 computed:&#123; getName2()&#123; console.log(&quot;计算属性我执行了&quot;) return this.mytext.substring(0,1).toUpperCase()+this.mytext.substring(1) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 1.1 通过计算属性，重写过滤案例123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;过滤案例&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.12/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;box&quot;&gt; &lt;p&gt;&lt;input type=&quot;text&quot; v-model=&quot;myText&quot; placeholder=&quot;请输入要筛选的内容:&quot;&gt;&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;data in newList&quot;&gt;&#123;&#123;data&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#box&#x27;, data: &#123; myText: &#x27;&#x27;, dataList: [&#x27;a&#x27;, &#x27;at&#x27;, &#x27;atom&#x27;, &#x27;be&#x27;, &#x27;beyond&#x27;, &#x27;cs&#x27;, &#x27;csrf&#x27;], &#125;, computed:&#123; newList()&#123; console.log(&#x27;我执行了&#x27;) var datalist2 = this.dataList.filter(item =&gt; &#123; return item.indexOf(this.myText) &gt; -1 &#125;) return datalist2 &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 2 侦听属性只要变量发生变化，就会执行监听属性中的方法 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;mytext&quot;&gt;---&gt;&#123;&#123;mytext&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; mytext: &#x27;&#x27;, &#125;, watch: &#123; // 只要mytext发生变化，就会执行该函数 mytext: function () &#123; console.log(&#x27;我变化了，执行&#x27;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 3 局部组件和全局组件123456789101112# 扩展 HTML 元素，封装可重用的代码，目的是复用 -例如：有一个轮播，可以在很多页面中使用，一个轮播有js，css，html -组件把js，css，html放到一起，有逻辑，有样式，有html # 局部组件，全局组件 -# 注意事项1 自定义组件需要有一个root element，一般包裹在一个div中2 父子组件的data是无法共享3 组件可以有data，methods,computed....,但是data 必须是一个函数 3.1 局部组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;Top&gt;&lt;/Top&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;Bottom&gt;&lt;/Bottom&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; // el data methods watch computed 8个 el: &#x27;#app&#x27;, data: &#123;&#125;, // 定义再这里面的叫局部组件，只能再局部使用，只能再id为app的标签内使用 components: &#123; &#x27;Top&#x27;: &#123; template: ` &lt;div&gt; &lt;h1 style=&quot;background: pink;font-size: 60px;text-align: center&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;button @click=&quot;handleC&quot;&gt;点我看美女&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; name: &quot;我是头部&quot; &#125; &#125;, methods: &#123; handleC() &#123; alert(&#x27;美女&#x27;) &#125; &#125;, &#125;, &#x27;Bottom&#x27;: &#123; template: ` &lt;div&gt; &lt;hr&gt; &lt;h1 style=&quot;background: green;font-size: 60px;text-align: center&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; `, data() &#123; return &#123; name: &quot;我是尾部&quot; &#125; &#125;, &#125;, &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 3.2 全局组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;top&gt;&lt;/top&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 定义全局组件---&gt;任意位置都可以用 Vue.component(&#x27;top&#x27;, &#123; template: ` &lt;div&gt; &lt;h1 style=&quot;background: pink;font-size: 60px;text-align: center&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;button @click=&quot;handleC&quot;&gt;点我看美女&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; name: &quot;我是头部&quot; &#125; &#125;, methods: &#123; handleC() &#123; alert(&#x27;美女&#x27;) &#125; &#125;, &#125;,) var vm = new Vue(&#123; // el data methods watch computed 8个 el: &#x27;#app&#x27;, data: &#123;&#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 4 组件通信之父传子12345# 组件间data数据不同享，数据传递 -从父组件传到子组件 -自定义属性 -从子组件传到父组件 -自定义事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;!--通过自定义属性：myheader--&gt; &lt;top :myheader=&quot;headerName&quot;&gt;&lt;/top&gt; &#123;&#123;headerName&#125;&#125; &lt;input type=&quot;text&quot; v-model=&quot;headerName&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 定义全局组件---&gt;任意位置都可以用 Vue.component(&#x27;top&#x27;, &#123; template: ` &lt;div&gt; &lt;h1 style=&quot;background: pink;font-size: 60px;text-align: center&quot;&gt;&#123;&#123;myheader&#125;&#125;&lt;/h1&gt; &lt;/div&gt; `, data() &#123; return &#123; name: &quot;我是头部&quot; &#125; &#125;, // 必须叫props，数组内放自定义属性的名字 // props:[&#x27;myheader&#x27;,], // 属性验证 props:&#123; myheader:String, // key是自定义属性名，value是类型名，如果是别的类型就报错 &#125;, &#125;,) var vm = new Vue(&#123; // el data methods watch computed 8个 el: &#x27;#app&#x27;, data: &#123; headerName:999 &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 5 组件通信之子传父1# 通过自定义事件实现子传父 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;!-- 自定义了一个myevent事件 --&gt; &lt;top @myevent=&quot;handelRecv&quot;&gt;&lt;/top&gt; &lt;hr&gt; 接收到子组件的数据是：&#123;&#123;childText&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 定义全局组件---&gt;任意位置都可以用 Vue.component(&#x27;top&#x27;, &#123; template: ` &lt;div&gt; &lt;h1 style=&quot;background: pink;font-size: 60px;text-align: center&quot;&gt;&#123;&#123;myheader&#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt; &lt;button @click=&quot;handleSend&quot;&gt;点我传出去&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; myheader: &quot;我是头部&quot;, text: &#x27;&#x27;, &#125; &#125;, methods:&#123; handleSend()&#123; // 触发绑定在该组件上的事件，myevent---》父组件中会执行事件对应的函数handelRecv--》 this.$emit(&#x27;myevent&#x27;,this.text) &#125; &#125; &#125;,) var vm = new Vue(&#123; // el data methods watch computed 8个 el: &#x27;#app&#x27;, data: &#123; childText: &#x27;&#x27; &#125;, methods:&#123; handelRecv(text)&#123; // 接收一个参数，赋值给父组件的childText this.childText=text &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 6 ref属性（组件间通信）–》事件总线(不讲)12# ref属性，如果放在普通标签上，就是普通标签的原生html，操作，设置# ref属性，如果放在组件上，就是当前组件对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;top ref=&quot;top&quot;&gt;&lt;/top&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot; ref=&quot;myinput&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;&quot; ref=&quot;myimg&quot; height=&quot;80px&quot; width=&quot;80px&quot;&gt; &lt;hr&gt; &lt;button @click=&quot;handleC&quot;&gt;点我&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 定义全局组件---&gt;任意位置都可以用 Vue.component(&#x27;top&#x27;, &#123; template: ` &lt;div&gt; &lt;h1&gt;&#123;&#123;myheader&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;handleC&quot;&gt;点我看美女&lt;/button&gt; &lt;hr&gt; &lt;/div&gt; `, data() &#123; return &#123; myheader: &quot;我是头部&quot;, &#125; &#125;, methods:&#123; handleC()&#123; alert(&quot;美女&quot;) &#125; &#125; &#125;,) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; text:&#x27;&#x27; &#125;, methods:&#123; handleC()&#123; console.log(&#x27;我被点了&#x27;) //把所有有ref属性的标签 弄到 一个对象中 console.log(this.$refs) // 是所有标签写了ref属性的对象&#123;myinput:真正的标签，myimg:真正的标签&#125; //111111 放在普通标签上示例 // 取到input的value值 // console.log(this.$refs.myinput.value) // this.$refs.myinput.value=&#x27;lqz is nb&#x27; // this.$refs.myimg.src=&#x27;https://tva1.sinaimg.cn/large/00831rSTly1gd1u0jw182j30u00u043b.jpg&#x27; //222222 放在组件上示例 // console.log(this.$refs.top) // 既然能够拿到组件对象，组件中的data中的值也可以拿到，组件中的方法也可调用 console.log(this.$refs.top.myheader) // 父组件中拿到了子组件的值 // 不区分是子传父还是父传子了 // 想子传父--》下面就是子传父 // console.log(this.$refs.top.myheader) // this.text=this.$refs.top.myheader // 想父传子 // this.$refs.top.myheader=&#x27;刘清政 is nb&#x27; // this.$refs.top.myheader=this.text // 还可以调用组件的方法 this.$refs.top.handleC() //如果有参数，是不是也可以传到子组件中 &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 7 动态组件和keep-alivekeep-alive：组件不销毁 component：有个is属性，指定显示的组件是哪个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;ul&gt; &lt;li @click=&quot;changeC(&#x27;index&#x27;)&quot;&gt;首页&lt;/li&gt; &lt;li @click=&quot;changeC(&#x27;order&#x27;)&quot;&gt;订单&lt;/li&gt; &lt;li @click=&quot;changeC(&#x27;good&#x27;)&quot;&gt;商品&lt;/li&gt;&lt;/ul&gt;&lt;!-- 笨办法--&gt;&lt;!--&lt;index v-if=&quot;index_show&quot;&gt;&lt;/index&gt;--&gt;&lt;!--&lt;order v-if=&quot;order_show&quot;&gt;&lt;/order&gt;--&gt;&lt;!--&lt;good v-if=&quot;good_show&quot;&gt;&lt;/good&gt;--&gt;&lt;keep-alive&gt; &lt;component :is=&#x27;who&#x27;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 定义全局组件---&gt;任意位置都可以用 Vue.component(&#x27;index&#x27;, &#123; template: ` &lt;div&gt; &lt;h1&gt;我是首页&lt;/h1&gt; &lt;/div&gt; `, &#125;,) Vue.component(&#x27;order&#x27;, &#123; template: ` &lt;div&gt; &lt;h1&gt;我是订单&lt;/h1&gt; 请输入要查询的订单：&lt;input type=&quot;text&quot;&gt; &lt;/div&gt; `, &#125;,) Vue.component(&#x27;good&#x27;, &#123; template: ` &lt;div&gt; &lt;h1&gt;我是商品&lt;/h1&gt; &lt;/div&gt; `, &#125;,) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // index_show:true, // order_show:false, // good_show:false, who:&#x27;index&#x27; &#125;, methods:&#123; changeC(i)&#123; this.who=i &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 8 插槽8.1普通插槽1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;index&gt; &lt;div&gt; 用户名：&lt;input type=&quot;text&quot;&gt; 密码：&lt;input type=&quot;text&quot;&gt; &lt;/div&gt;&lt;/index&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component(&#x27;index&#x27;, &#123; template: ` &lt;div&gt; &lt;h1&gt;我是首页&lt;/h1&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `, &#125;,) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; &#125;, methods:&#123; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 8.2 具名插槽123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;index&gt; &lt;p slot=&quot;a&quot;&gt;pppp&lt;/p&gt; &lt;div slot=&quot;b&quot;&gt; div--div &lt;/div&gt; &lt;/index&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component(&#x27;index&#x27;, &#123; template: ` &lt;div&gt; &lt;slot name=&quot;a&quot;&gt;&lt;/slot&gt; &lt;h1&gt;我是首页&lt;/h1&gt; &lt;slot name=&quot;b&quot;&gt;&lt;/slot&gt; &lt;/div&gt; `, &#125;,) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 补充123456789101112131415161718192021222324# 编辑器的选择 -java：IDEA(主流)，eclipse，myeclipse -python：pycharm(主流)，Jupyter(数据分析) -go： goland(主流)，vscode（微软出的，免费） -前端：webstorm，vscode，sublime-text，Hbuilder -安卓开发：AndrioStudio -ios：Xcode，只能装在mac ---》必须要有mac系统，普通PC机不好装mac系统，黑苹果--》驱动支持不好 # 总结：Jetbrains公司，出了所有开发语言可以用的编辑器，Jetbrains全家桶，最开始Jetbrains只有一款编辑器，就是idea，出插件，安装了插件后，可以开发其它语言，每个语言有个编辑器 # 由于咱们用pycharm比较习惯，建议以后选择jet的全家桶，使用习惯完全一致，只是换了个语法写代码 # AndrioStudio：谷歌公司推出的，谷歌买了Jetbrains公司版权，自己定制的ADT--》AndrioStudio # vscode：免费，占内存小 # jetbrains收费---》价格不低--》组织：699刀一年 # 正常途径：学生--》学生邮箱申请 开源软件作者---&gt;申请# pycharm过期问题 -淘宝购买 -IDE Eval Reset ---》全家桶---》任意一款jetbrains的ide都行 -30天免费试用--》用了29天，删除pycharm的配置文件---》重新是30天 -最新版的pycharm不支持：远程认证，不让试用了---》老版本--》2020版本 12345678910# 在这nodejs(python 解释器)---》后端语言，安装在操作系统上 -http://nodejs.cn/---》一路下一步 -node：python，解释器命令 -npm： pip命令，用来安装模块的# vue脚手架---》vue-cli安装完 npm install -g @vue/cli # vue命令 # 等同于 pip install django---》 djangoadmin# 创建一个vue项目 -vue create 项目名 ---》创建出一个vue项目，使用pycharm打开 # 搜着创建","categories":[],"tags":[{"name":"8、vue笔记","slug":"8、vue笔记","permalink":"https://chenxiao0629.github.io/tags/8%E3%80%81vue%E7%AC%94%E8%AE%B0/"}]},{"title":"03、购物车案例（基本购物车、全选、全不选、增加减少）、生命周期钩子函数、与后端交互","slug":"vue_day03","date":"2021-06-28T06:04:03.000Z","updated":"2022-05-14T04:59:56.123Z","comments":true,"path":"2021/06/28/vue_day03/","link":"","permalink":"https://chenxiao0629.github.io/2021/06/28/vue_day03/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 1 属性指令 v-bind:属性=&#x27;变量&#x27; :属性=&#x27;变量&#x27;# 2 class和style -class:字符串，数组(推荐)，对象 -style：字符串，数组，对象(推荐)，aa-bb---&gt;aaBb# 3 条件渲染 v-if v-else-if v-else # 4 列表渲染 -v-for -购物车商品显示 -key值的解释---》虚拟dom，diff算法 -数组的检测与更新：数据变了，页面没变---》Vue.set(数组,索引,值) # 5 v-model数据双向绑定---》input# 6 事件处理 -input事件 -change事件 -blur事件 -过滤案例：input事件 -v-for：newdatalist -数组.filter(function (item)&#123; retrun true 保留 retrun false 不保留 &#125;) -字符串.indexOf(&#x27;子字符串&#x27;) &gt;-1 说明子字符串在 -es6的新语法 -1 字符串格式 `` -2 箭头函数--》没有自己的this var a=function ()&#123;&#125; var a =()=&gt;&#123;&#125; var a = name=&gt;&#123;&#125; # 一个参数，括号可以省略 -3 对象的表示 // var o =&#123;&#x27;name&#x27;:name,&#x27;age&#x27;:age&#125; // var o =&#123;name:name,age:age&#125; var o =&#123;name,age&#125; -4 函数在对象中 var o = &#123; name, age, gender() &#123; return &#x27;男&#x27; &#125; &#125; -事件修饰符 -stop：阻止事件冒泡 -self：只执行自己的，不执行冒泡上来的 -prevent：阻止a标签跳转，加逻辑--》locations.href=&#x27;地址&#x27; -once：只执行一次 -按键修饰符 v-on:keyup：键盘被弹起，触发 @keyup v-on:keydown：键盘被按下，触发@keydown 京东，输入搜索商品，敲回车才去搜索 @keyup.enter=&#x27;函数&#x27; -表单控制 -checkbox单选：true或false -radio单选：字符串---》value值 -checkbox多选：数组--》选中的value值都放到数组中 -v-model进阶 -lazy -number -trim 1 购物车案例1.1 基本购物车1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-offset-3 col-md-6&quot; style=&quot;margin-top: 20px&quot;&gt; &lt;h1&gt;购物车案例&lt;/h1&gt; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;tr&gt; &lt;td&gt;商品名字&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;数量&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;data in dataList&quot;&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.price&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.number&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;checkGroup&quot; :value=&quot;data&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; 选中的商品：&#123;&#123;checkGroup&#125;&#125; &lt;br&gt; 总价格:&#123;&#123;getPrice()&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dataList: [ &#123;name: &#x27;今瓶没&#x27;, price: 99, number: 2&#125;, &#123;name: &#x27;西柚记&#x27;, price: 59, number: 1&#125;, &#123;name: &#x27;水壶转&#x27;, price: 89, number: 5&#125;, ], checkGroup: [], &#125;, methods: &#123; getPrice() &#123; var total = 0 //方式一： i是索引,循环选中的商品，基于迭代的循环 // for (i in this.checkGroup) &#123; // total += this.checkGroup[i].price * this.checkGroup[i].number // &#125; //方式二： 基于索引的循环 // for (var i=0;i&lt;this.checkGroup.length;i++) &#123; // total += this.checkGroup[i].price * this.checkGroup[i].number // &#125; //方式三： 基于迭代 for of // for (v of this.checkGroup) &#123; // total += v.price * v.number // &#125; // 方式四：forEach 可迭代对象(数组)的方法 this.checkGroup.forEach((v,i)=&gt; &#123; total += v.price * v.number &#125;) return total &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 1.2 全选全不选1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-offset-3 col-md-6&quot; style=&quot;margin-top: 20px&quot;&gt; &lt;h1&gt;购物车案例&lt;/h1&gt; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;tr&gt; &lt;td&gt;商品名字&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;数量&lt;/td&gt; &lt;td&gt;全选/全不选 &lt;input type=&quot;checkbox&quot; v-model=&quot;allCheck&quot; @change=&quot;handleAll&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;data in dataList&quot;&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.price&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.number&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;checkGroup&quot; :value=&quot;data&quot; @change=&quot;checkOne&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; 选中的商品：&#123;&#123;checkGroup&#125;&#125; &lt;br&gt; 总价格:&#123;&#123;getPrice()&#125;&#125; &lt;br&gt; 是否全选:&#123;&#123;allCheck&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dataList: [ &#123;name: &#x27;今瓶没&#x27;, price: 99, number: 2&#125;, &#123;name: &#x27;西柚记&#x27;, price: 59, number: 1&#125;, &#123;name: &#x27;水壶转&#x27;, price: 89, number: 5&#125;, ], checkGroup: [], allCheck:false &#125;, methods: &#123; getPrice() &#123; var total = 0 this.checkGroup.forEach((v, i) =&gt; &#123; total += v.price * v.number &#125;) return total &#125;, handleAll()&#123; if(this.allCheck)&#123; this.checkGroup=this.dataList &#125;else &#123; this.checkGroup=[] &#125; &#125;, checkOne()&#123; // if(this.checkGroup.length==this.dataList.length)&#123; // this.allCheck=true // &#125;else &#123; // this.allCheck=false // &#125; // js中 == 和 === 区别：==比较的是值，===值和类型 this.allCheck=(this.checkGroup.length===this.dataList.length) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 1.3 增加减少12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-offset-3 col-md-6&quot; style=&quot;margin-top: 20px&quot;&gt; &lt;h1&gt;购物车案例&lt;/h1&gt; &lt;table class=&quot;table table-bordered&quot;&gt; &lt;tr&gt; &lt;td&gt;商品名字&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;数量&lt;/td&gt; &lt;td&gt;全选/全不选 &lt;input type=&quot;checkbox&quot; v-model=&quot;allCheck&quot; @change=&quot;handleAll&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;data in dataList&quot;&gt; &lt;td&gt;&#123;&#123;data.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;data.price&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;button @click=&quot;handleCount(data)&quot;&gt;-&lt;/button&gt; &#123;&#123;data.number&#125;&#125; &lt;button @click=&quot;data.number++&quot;&gt;+&lt;/button&gt; &lt;/td&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;checkGroup&quot; :value=&quot;data&quot; @change=&quot;checkOne&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; 选中的商品：&#123;&#123;checkGroup&#125;&#125; &lt;br&gt; 总价格:&#123;&#123;getPrice()&#125;&#125; &lt;br&gt; 是否全选:&#123;&#123;allCheck&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dataList: [ &#123;name: &#x27;今瓶没&#x27;, price: 99, number: 2&#125;, &#123;name: &#x27;西柚记&#x27;, price: 59, number: 1&#125;, &#123;name: &#x27;水壶转&#x27;, price: 89, number: 5&#125;, ], checkGroup: [], allCheck: false &#125;, methods: &#123; getPrice() &#123; var total = 0 this.checkGroup.forEach((v, i) =&gt; &#123; total += v.price * v.number &#125;) return total &#125;, handleAll() &#123; if (this.allCheck) &#123; this.checkGroup = this.dataList &#125; else &#123; this.checkGroup = [] &#125; &#125;, checkOne() &#123; // if(this.checkGroup.length==this.dataList.length)&#123; // this.allCheck=true // &#125;else &#123; // this.allCheck=false // &#125; // js中 == 和 === 区别：==比较的是值，===值和类型 this.allCheck = (this.checkGroup.length === this.dataList.length) &#125;, handleCount(item) &#123; if (item.number == 1) &#123; alert(&quot;不能再少了，受不了了&quot;) &#125; else &#123; item.number-- &#125; &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 2 生命周期钩子函数1234567891011121314151617181920212223242526272829# new Vue这个对象---》管理一个标签---》把数据，渲染到页面上# 组件---》对象管理某一个html片段# 生命周期--》8个声明周期钩子函数---》执行到某个地方，就会执行某个函数 钩子函数 描述 beforeCreate 创建Vue实例之前调用，data空的 created 创建Vue实例成功后调用 beforeMount 渲染DOM之前调用 mounted 渲染DOM之后调用---》看到页面了，插值已经进去了 beforeUpdate 重新渲染之前调用（数据更新等操作时，控制DOM重新渲染） updated 重新渲染完成之后调用 beforeDestroy 销毁之前调用 destroyed 销毁之后调用 # 有用的： created：向后端发请求拿数据，发送ajax请求 mounted：定时任务，延迟任务 js中 beforeDestroy：定时任务关闭，销毁一些操作 # 定时器的开启与关闭 this.t = setInterval(() =&gt; &#123; console.log(&#x27;daada&#x27;) &#125;, 3000) clearInterval(this.t)this.t = null 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;handleC&quot;&gt;点我显示组件&lt;/button&gt; &lt;child v-if=&quot;is_show&quot;&gt;&lt;/child&gt; &lt;hr&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 1 定义个组件---》生命周期 Vue.component(&#x27;child&#x27;, &#123; template: ` &lt;div&gt; &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;handleC&quot;&gt;点我弹窗&lt;/button&gt; &lt;/div&gt;`, data() &#123; return &#123; name: &quot;lqz&quot;, t:&#x27;&#x27;, &#125; &#125;, methods: &#123; handleC() &#123; this.name = &quot;彭于晏&quot; alert(this.name) &#125; &#125;, // 生命周期钩子函数8个 beforeCreate() &#123; console.log(&#x27;当前状态：beforeCreate&#x27;) console.log(&#x27;当前el状态：&#x27;, this.$el) console.log(&#x27;当前data状态：&#x27;, this.$data) console.log(&#x27;当前name状态：&#x27;, this.name) &#125;, created() &#123; // 向后端加载数据 console.log(&#x27;当前状态：created&#x27;) console.log(&#x27;当前el状态：&#x27;, this.$el) console.log(&#x27;当前data状态：&#x27;, this.$data) console.log(&#x27;当前name状态：&#x27;, this.name) &#125;, beforeMount() &#123; console.log(&#x27;当前状态：beforeMount&#x27;) console.log(&#x27;当前el状态：&#x27;, this.$el) console.log(&#x27;当前data状态：&#x27;, this.$data) console.log(&#x27;当前name状态：&#x27;, this.name) &#125;, mounted() &#123; console.log(&#x27;当前状态：mounted&#x27;) console.log(&#x27;当前el状态：&#x27;, this.$el) console.log(&#x27;当前data状态：&#x27;, this.$data) console.log(&#x27;当前name状 态：&#x27;, this.name) //用的最多，向后端加载数据，创建定时器等 // setTimeout:延迟执行 // setInterval：定时执行,每三秒钟打印一下daada this.t = setInterval(() =&gt; &#123; console.log(&#x27;daada&#x27;) &#125;, 3000) &#125;, beforeUpdate() &#123; console.log(&#x27;当前状态：beforeUpdate&#x27;) console.log(&#x27;当前el状态：&#x27;, this.$el) console.log(&#x27;当前data状态：&#x27;, this.$data) console.log(&#x27;当前name状态：&#x27;, this.name) &#125;, updated() &#123; console.log(&#x27;当前状态：updated&#x27;) console.log(&#x27;当前el状态：&#x27;, this.$el) console.log(&#x27;当前data状态：&#x27;, this.$data) console.log(&#x27;当前name状态：&#x27;, this.name) &#125;, beforeDestroy() &#123; console.log(&#x27;当前状态：beforeDestroy&#x27;) console.log(&#x27;当前el状态：&#x27;, this.$el) console.log(&#x27;当前data状态：&#x27;, this.$data) console.log(&#x27;当前name状态：&#x27;, this.name) &#125;, destroyed() &#123; console.log(&#x27;当前状态：destroyed&#x27;) console.log(&#x27;当前el状态：&#x27;, this.$el) console.log(&#x27;当前data状态：&#x27;, this.$data) console.log(&#x27;当前name状态：&#x27;, this.name) //组件销毁，清理定时器 clearInterval(this.t) this.t = null // console.log(&#x27;destoryed&#x27;) &#125;, &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; is_show: false &#125;, methods: &#123; handleC() &#123; this.is_show = !this.is_show &#125; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 3 与后端交互12345678910# ajax:异步的xml请求，前后端交互就是xml格式，随着json格式发展，目前都是使用json格式# jquery的ajax方法 $.ajax() 方法---》只是方法名正好叫ajax# js原生可以写ajax请求，非常麻烦，考虑兼容性---》jquery# 方式一：jquery的ajax方法发送请求(基本不用了)# 方式二：js官方提供的fetch方法(XMLHttpRequest)（官方的，用的也少）# 方式三：axios第三方，做ajax请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;http://code.jquery.com/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt;--&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; text: &#x27;&#x27;, &#125;, created() &#123; // 方式一: //向后端发请求，拿数据，拿回来赋值给text // $.ajax(&#123; // url:&#x27;http://127.0.0.1:5000/&#x27;, // type:&#x27;get&#x27;, // success:(data) =&gt;&#123; // console.log(data) // this.text=data // &#125; // &#125;) // 方式二：js原生的fetch // fetch(&#x27;http://127.0.0.1:5000/&#x27;).then(res =&gt; res.json()).then(res =&gt; &#123; // console.log(res) // this.text=res.name // // &#125;) // 方式三 axios axios.get(&#x27;http://127.0.0.1:5000&#x27;).then(data =&gt; &#123; console.log(data.data) this.text=data.data.name &#125;) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 3.1 案例123456789101112131415161718192021from flask import Flask,make_response,jsonifyapp=Flask(__name__)@app.route(&#x27;/&#x27;)def index(): # 跨域问题 obj=make_response(jsonify(&#123;&#x27;name&#x27;:&#x27;lqz is handsome&#x27;,&#x27;age&#x27;:19&#125;)) obj.headers[&#x27;Access-Control-Allow-Origin&#x27;]=&#x27;*&#x27; return obj@app.route(&#x27;/films&#x27;)def films(): # 跨域问题 import json with open(&#x27;./res.json&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as f: res=json.load(f) obj = make_response(jsonify(res)) obj.headers[&#x27;Access-Control-Allow-Origin&#x27;]=&#x27;*&#x27; return objif __name__ == &#x27;__main__&#x27;: app.run() 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;film in films_list&quot;&gt; &lt;p&gt;电影名字是：&#123;&#123;film.name&#125;&#125;&lt;/p&gt; &lt;img :src=&quot;film.poster&quot; alt=&quot;&quot; width=&quot;100px&quot; height=&quot;150px&quot;&gt; &lt;p&gt;电影介绍：&#123;&#123;film.synopsis&#125;&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; films_list:[] &#125;, created() &#123; // 方式三 axios axios.get(&#x27;http://127.0.0.1:5000/films&#x27;).then(res =&gt; &#123; console.log(res.data) this.films_list=res.data.data.films &#125;) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 12345678910111213# jdk jre jvm javase javaee# 安卓应用：java写的---》字节码文件---》虚拟机：pc机上jvm---》sun被oracle收购了---》安卓手机上的虚拟机运行java编译后的字节码---》虚拟机吃内存ios：object C 苹果的一个员工，发明了语言：swift----》跳槽去了facebook -一个应用市场，所有的app，必须从这下，垃圾应用，审核不通过，上不了架，软件安全安卓：java：当你java用的人最多，如果谷歌开一个新语言写安卓应用，导致没人写--》选择了java---》kotlin安卓开发---》不温不火---》所有语言排行榜，kotlin排名有时候比 go 高，安卓---》应用市场，google，国内不能访问谷歌，谷歌应用市场用不了，国内市场：小米市场，华为市场，应用宝，豌豆荚，xx.apk---&gt;安卓的恶意软件很多正规软件，保证进程永远不死，你看到你关了，后台进程一直跑微信，qq，迅雷：上传：默默的自己就启动了# pycharm用java开发的","categories":[],"tags":[{"name":"8、vue笔记","slug":"8、vue笔记","permalink":"https://chenxiao0629.github.io/tags/8%E3%80%81vue%E7%AC%94%E8%AE%B0/"}]},{"title":"02、style和class、条件渲染、列表渲染、事件处理、数据双向绑定、表单控制、v-model进阶","slug":"vue_day02","date":"2021-06-28T06:04:02.000Z","updated":"2022-05-14T04:58:58.534Z","comments":true,"path":"2021/06/28/vue_day02/","link":"","permalink":"https://chenxiao0629.github.io/2021/06/28/vue_day02/","excerpt":"","text":"复习1234567891011121314151617181920212223242526272829# 1 vue :js框架，1w多行，压缩后20kb大小 -版本：2.x 3.x -生产环境，测试环境 -渐进式框架：项目中局部，全局使用 -mvvm架构：m:model数据js v：视图，html，css vm：viewmodel中间，中转 -本质也是dom操作，只是咱么不需要dom操作---》jquery：方便dom操作，vue中基本不用 -单页面开发，组件化开发 -整个项目都可以使用vue，就一个index.html，页面中的变化都是组件的切换 -页面组件，头部组件，尾部组件---》复用 # 2 vue 的快速使用 -cdn引入 -本地引入：源代码下载放到本地 # 3 插值语法 -&#123;&#123;变量，js三目运算符&#125;&#125; -条件:是?否--》if(条件)&#123;retrun 是&#125;else&#123;return 否&#125; -js中 []:数组 &#123;key:value&#125;:对象 # 4 指令：v-xx 都是vue的指令---》提供了很多# 5 文本指令：处理文本 -v-text：把变量内容写到标签中 类似于直接用插值 -v-html:把字符串渲染成标签格式 -v-show：控制标签是否显示 在页面中存在 -v-if：显示不显示 如果不显示，删除 # 6 事件指令 v-on:事件名=&quot;函数&quot;---》简写成@事件名=&quot;函数&quot; 1 style和class1234# 属性指令中比较特殊的有style和class# class 可以对应字符串，数组(推荐)，对象# style 可以对应字符串，数组，对象(推荐) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .red &#123; background: red; &#125; .font&#123; font-size: 60px; text-align: center; &#125; .green &#123; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1 :class=&quot;h1_class&quot;&gt;我是class的h1&lt;/h1&gt; &lt;h1 :style=&quot;h1_style&quot;&gt;我是style的h1&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; // class 可以对应字符串，数组(推荐)，对象 // h1_class:&#x27;green font&#x27;, // h1_class:[&#x27;green&#x27;] //在控制台给h1_class添加一个元素 h1_class:&#123;&#x27;green&#x27;:true,&#x27;font&#x27;:false&#125;, // style 可以对应字符串，数组，对象(推荐) // h1_style:&#x27;background: pink;font-size:80px&#x27; // h1_style:[&#123;background:&#x27;pink&#x27;&#125;,&#123;&#x27;font-size&#x27;:&#x27;100px&#x27;&#125;], // h1_style:[&#123;background:&#x27;pink&#x27;&#125;,&#123;fontSize:&#x27;200px&#x27;&#125;], // 不用引号，就要使用驼峰 // h1_style:&#123;background:&#x27;red&#x27;,&#x27;font-size&#x27;:&#x27;40px&#x27;&#125;, h1_style:&#123;background:&#x27;red&#x27;,fontSize:&#x27;40px&#x27;&#125;, &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 2 条件渲染1v-if----v-else-if ---v-else的使用 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h2&gt;您的成绩是：&lt;/h2&gt; &lt;p v-if=&quot;score&gt;90&quot;&gt;优秀&lt;/p&gt; &lt;p v-else-if=&quot;score&gt;80&quot;&gt;良好&lt;/p&gt; &lt;p v-else-if=&quot;score&gt;60&quot;&gt;及格&lt;/p&gt; &lt;p v-else&gt;不及格&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; score:99, &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 3 列表渲染123# for循环--》v-for# v-for：可以遍历数组，对象，数字 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;h1&gt;购物车如下&lt;/h1&gt; &lt;div v-if=&quot;good_list.length&gt;0&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;商品名字&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;good in good_list&quot;&gt; &lt;td&gt;&#123;&#123;good.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;good.price&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div v-else&gt; 购物车空空如也 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; good_list:[&#123;name:&quot;特斯拉&quot;,price:100203&#125;,&#123;name:&quot;鸡蛋&quot;,price:2&#125;,&#123;name:&quot;猪肉&quot;,price:35&#125;] &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;h1&gt;购物车如下&lt;/h1&gt; &lt;div v-if=&quot;good_list.length&gt;0&quot;&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;商品名字&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;/tr&gt; &lt;tr v-for=&quot;good in good_list&quot;&gt; &lt;td&gt;&#123;&#123;good.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;good.price&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;div v-else&gt; 购物车空空如也 &lt;/div&gt; &lt;hr&gt; &lt;h1&gt;遍历对象（第一个是value，第二个是key）&lt;/h1&gt; &lt;p v-for=&quot;item in info&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;hr&gt; &lt;p v-for=&quot;(v,k) in info&quot;&gt;key值是：&#123;&#123;k&#125;&#125;--value值是：&#123;&#123;v&#125;&#125;&lt;/p&gt; &lt;h1&gt;遍历数组&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;girl in girls&quot;&gt;&#123;&#123;girl&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;ul&gt; &lt;li v-for=&quot;(v,i) in girls&quot;&gt;第&#123;&#123;i&#125;&#125;个女孩是：&#123;&#123;v&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;h1&gt;遍历数字,从1开始&lt;/h1&gt; &lt;p v-for=&quot;i in 5&quot;&gt;第&#123;&#123;i&#125;&#125;个数字&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; good_list:[&#123;name:&quot;特斯拉&quot;,price:100203&#125;,&#123;name:&quot;鸡蛋&quot;,price:2&#125;,&#123;name:&quot;猪肉&quot;,price:35&#125;], info:&#123;name:&#x27;lqz&#x27;,age:19,gender:&#x27;男&#x27;&#125;, girls:[&#x27;迪丽热巴&#x27;,&#x27;刘亦菲&#x27;,&#x27;杨颖&#x27;,&#x27;糖宝&#x27;] &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 3.1 注意1234567891011121314151617181920212223242526272829303132333435363738394041424344# 注意！在Vue中： 数组的index和value是反的 对象的key和value也是反的 # key值的解释 看到被人代码在循环时，写在标签中 :key=&#x27;值&#x27; key:一般咱么在循环的时候，都要加 :key=&#x27;值&#x27;，值不要是固定的vue中使用的是虚拟DOM，会和原生的DOM进行比较，然后进行数据的更新，提高数据的刷新速度（虚拟DOM用了diff算法）在v-for循环数组、对象时，建议在控件/组件/标签写1个key属性，属性值唯一页面更新之后，会加速DOM的替换（渲染）:key=&quot;变量&quot; # key可以加速页面的替换--》key加上，效率高# 数组更新与检测# 数组追加一个值，页面里面跟着变----》 #可以检测到变动的数组操作：push：最后位置添加pop：最后位置删除shift：第一个位置删除unshift：第一个位置添加splice：切片sort：排序reverse：反转# 检测不到变动的数组操作： 页面不会变filter()：过滤concat()：追加另一个数组slice()：map()：原因：作者重写了相关方法（只重写了一部分方法，但是还有另一部分没有重写）】数组变了，但页面没变---》解决方案// 方法1：通过 索引值 更新数组（数据会更新，但是页面不会发生改变）vm.arrayList[0]&quot;Alan&quot;vm.arrayList[0]=&#x27;Darker&#x27;&quot;Darker&quot;// 方法2：通过 Vue.set(对象, index/key, value) 更新数组（数据会更新，页面也会发生改变）Vue.set(vm.arrayList, 0, &#x27;Darker&#x27;) 4 事件处理1234# 指input的事件input 当输入框进行输入的时候 触发的事件change 当元素的值发生改变时 触发的事件blur 当输入框失去焦点的时候 触发的事件 4.1 过滤案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot; @input=&quot;handleInput&quot;&gt;---》&#123;&#123;text&#125;&#125; &lt;ul&gt; &lt;li v-for=&quot;data in newdataList&quot;&gt;&#123;&#123;data&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 补充 filter // var newdataList= [&#x27;a&#x27;, &#x27;at&#x27;, &#x27;atom&#x27;, &#x27;be&#x27;, &#x27;beyond&#x27;, &#x27;cs&#x27;, &#x27;csrf&#x27;] // var l=newdataList.filter(function (item) &#123; // if(item.length&gt;2)&#123; // return true // &#125;else &#123; // return false // &#125; // // &#125;) // console.log(l) // 补充：判断一个字符串是否在另一个字符串中 // var text = &#x27;at&#x27; // var newdataList = [&#x27;a&#x27;, &#x27;at&#x27;, &#x27;atom&#x27;, &#x27;be&#x27;, &#x27;beyond&#x27;, &#x27;cs&#x27;, &#x27;csrf&#x27;] // var l=newdataList.filter(function (item) &#123; // var i=item.indexOf(text) // if (i&gt;=0)&#123; // return true // &#125;else &#123; // return false // &#125; // &#125;) // var l = newdataList.filter(function (item) &#123; // return item.indexOf(text) &gt;= 0 // &#125;) // console.log(l) // 箭头函数 -es6 // var a= function (name) &#123; // console.log(name) // &#125; // a(&#x27;lqz&#x27;) // 箭头函数没有自己的this // var a =(name)=&gt;&#123; // console.log(name) // &#125; // a(&quot;lqz&quot;) var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; text: &#x27;&#x27;, dataList: [&#x27;a&#x27;, &#x27;at&#x27;, &#x27;atom&#x27;, &#x27;be&#x27;, &#x27;beyond&#x27;, &#x27;cs&#x27;, &#x27;csrf&#x27;], newdataList: [&#x27;a&#x27;, &#x27;at&#x27;, &#x27;atom&#x27;, &#x27;be&#x27;, &#x27;beyond&#x27;, &#x27;cs&#x27;, &#x27;csrf&#x27;], &#125;, methods: &#123; handleInput() &#123; console.log(this) // var _this=this // // 只要text发生变化，newdataList就变化，就过滤 // this.newdataList = this.dataList.filter(function (item) &#123; // // js 中this指向的问题 // console.log(this) // return item.indexOf(_this.text) &gt;= 0 // &#125;) // es6 处理this指向，箭头函数 this.newdataList = this.dataList.filter((item)=&gt; &#123; // js 中this指向的问题 console.log(this) return item.indexOf(this.text) &gt;= 0 &#125;) &#125;, &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 4.2 事件修饰符123456# .stop 只处理自己的事件，父控件冒泡的事件不处理（阻止事件冒泡）# .self 只处理自己的事件，子控件冒泡的事件不处理# .prevent 阻止a链接的跳转# .once 事件只会触发一次（适用于抽奖页面）# 事件冒泡：子标签的点击事件，传到了父标签上 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul @click.self=&quot;handleUl&quot;&gt; &lt;li @click.stop=&quot;handleC(&#x27;刘亦非&#x27;)&quot;&gt;刘亦菲&lt;/li&gt; &lt;li @click=&quot;handleC(&#x27;杨颖&#x27;)&quot;&gt;杨颖&lt;/li&gt; &lt;li&gt;迪丽热巴&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;handleA&quot;&gt;点我看美女&lt;/a&gt; &lt;hr&gt; &lt;button @click.once=&quot;handleSubmit&quot;&gt;点我秒杀&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123;&#125;, methods: &#123; handleUl() &#123; console.log(&#x27;ul被点解了&#x27;) &#125;, handleC(name) &#123; console.log(name, &#x27;被点击了&#x27;) &#125;, handleA() &#123; // 允许跳，不允许跳 console.log(&#x27;a被点击了&#x27;) // location.href=&#x27;http://www.baidu.com&#x27; &#125;, handleSubmit() &#123; console.log(&#x27;秒杀按钮被点击了&#x27;) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 4.3 按键修饰符12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;!-- &lt;input type=&quot;text&quot; v-model=&quot;mytext&quot; v-on:keyup=&quot;handleKeyUp&quot;&gt;-&amp;ndash;&amp;gt;&#123;&#123;mytext&#125;&#125;--&gt; &lt;input type=&quot;text&quot; v-model=&quot;mytext&quot; @keyup=&quot;handleKeyUp($event)&quot;&gt;---&gt;&#123;&#123;mytext&#125;&#125; &lt;hr&gt; &lt;input type=&quot;text&quot; v-model=&quot;mytext&quot; @keyup.enter=&quot;handleKeyUp2($event)&quot;&gt;---&gt;&#123;&#123;mytext&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; mytext:&#x27;&#x27;, &#125;, methods: &#123; handleKeyUp(event)&#123; console.log(event) console.log(event.key,&#x27;被按下谈起了&#x27;) if(event.key==&#x27;Enter&#x27;)&#123; alert(&#x27;美女你好&#x27;) &#125; &#125;, handleKeyUp2(event)&#123; console.log(event.key,&#x27;被按下谈起了&#x27;) &#125;, &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 5 数据的双向绑定1# input标签---》跟js变量绑定 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt;---&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; text:&#x27;&#x27; &#125;, &#125;)&lt;/script&gt;&lt;/html&gt; 6 表单控制1# input,checkbox,radio控制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;checkbox单选&lt;/h1&gt; &lt;p&gt;用户名：&lt;input type=&quot;text&quot; v-model=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; v-model=&quot;password&quot;&gt;&lt;/p&gt; &lt;p&gt;记住密码：&lt;input type=&quot;checkbox&quot; v-model=&quot;remember&quot;&gt;&lt;/p&gt; &lt;hr&gt; &#123;&#123;username&#125;&#125;---&#123;&#123;password&#125;&#125;--&#123;&#123;remember&#125;&#125; &lt;br&gt; &lt;h1&gt;radio单选&lt;/h1&gt; &lt;input type=&quot;radio&quot; v-model=&quot;radio&quot; value=&quot;1&quot;&gt;男 &lt;input type=&quot;radio&quot; v-model=&quot;radio&quot; value=&quot;2&quot;&gt;女 &lt;input type=&quot;radio&quot; v-model=&quot;radio&quot; value=&quot;0&quot;&gt;保密 &lt;br&gt;&lt;br&gt;您选择的性别：&#123;&#123;radio&#125;&#125; &lt;hr&gt; &lt;h1&gt;checkbox多选&lt;/h1&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;many&quot; value=&quot;篮球&quot;&gt;篮球 &lt;input type=&quot;checkbox&quot; v-model=&quot;many&quot; value=&quot;足球&quot;&gt;足球 &lt;input type=&quot;checkbox&quot; v-model=&quot;many&quot; value=&quot;棒球&quot;&gt;棒球 &lt;input type=&quot;checkbox&quot; v-model=&quot;many&quot; value=&quot;桌球&quot;&gt;桌球 &lt;br&gt;&lt;br&gt;您喜欢的球类：&#123;&#123;many&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; username: &#x27;&#x27;, password: &#x27;&#x27;, remember: true, // checkbox单选，布尔 radio: &#x27;&#x27;, // redio的单选字符串，对应选中的value值 many:[], //checkbox多选---》数组 &#125;, methods: &#123;&#125; &#125;)&lt;/script&gt;&lt;/html&gt; 7 v-model进阶123lazy：等待input框的数据绑定时区焦点之后再变化number：数字开头，只保留数字，后面的字母不保留；字母开头，都保留trim：去除首位的空格 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; lazy: &lt;input type=&quot;text&quot; v-model.lazy=&quot;username&quot;&gt;---&gt;&#123;&#123;username&#125;&#125; &lt;br&gt; number:&lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt;---&gt;&#123;&#123;age&#125;&#125; &lt;br&gt; trim:&lt;input type=&quot;text&quot; v-model.trim=&quot;info&quot;&gt;---&gt;&#123;&#123;info&#125;&#125; &lt;br&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; username: &#x27;&#x27;, age: &#x27;&#x27;, info: &#x27;&#x27;, &#125;, methods: &#123;&#125; &#125;)&lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"8、vue笔记","slug":"8、vue笔记","permalink":"https://chenxiao0629.github.io/tags/8%E3%80%81vue%E7%AC%94%E8%AE%B0/"}]},{"title":"01、前端介绍、vue（介绍、快速使用、模板语法之插值、指令系统（文本、事件、属性指令））","slug":"vue_day01","date":"2021-06-28T06:04:01.000Z","updated":"2022-05-14T04:57:02.919Z","comments":true,"path":"2021/06/28/vue_day01/","link":"","permalink":"https://chenxiao0629.github.io/2021/06/28/vue_day01/","excerpt":"","text":"drf复习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# 1 drf入门 -前后端开发模式：混合（模板中套模板语法），分离（后端只写接口） -API接口---》前后端交互的一种模式---》接口 -postman：接口测试工具 -restful规范：10条 -drf：django的一个app，方便我们快速写接口# 2 drf的序列化组件 -可以序列化：把模型类---》字典--》通过Response返回 -可以反序列化：把前端传入的json格式，报错到数据库中 -数据校验：字段自己的，局部，全局 -Serializer：在类中写要序列化的字段，重写create，update -ModelSerializer：继承了Serializer，写了create，update，一般不需要重写 -class Meta models fields exclude depth extra_kwargs -重写字段 -局部和全局钩子跟原来一样 -局部，全局钩子源码:#is_valid----&gt;self.run_validation-(执行Serializer的run_validation)--&gt;self.to_internal_value(data)---（执行Serializer的run_validation：485行） -序列化类源码分析：many=True，生成的对象是ListSerializer类的对象， __new__控制了对象的生成：ListSerializer[ser对象，ser对象] -面试常考题：__init__和__new__区别 -字段类，字段参数：read_only，write_only -视图类和序列化类沟通的桥梁：context -serializer = AccountSerializer(account, context=&#123;&#x27;request&#x27;: request&#125;) -序列化类中：self.context.get(&#x27;request&#x27;) -视图类中：serializer.context.get(&#x27;xxx&#x27;)# 3 请求与相应 -Request类的对象--》APIView以后的request对象都是新的 -request.data -request.query_params -重写了__getattr__:对象.属性 不存在的时候触发 -可以解析的请求编码 -urlencoded，formdate，json -django默认只能解析urlencoded，formdate -drf解析三种，三个类控制 -局部使用，全局使用（一般不配置） -Response类的对象 -data：给前端的 -header：相应头 -status：相应状态码 -响应格式，局部和全局配置# 4 视图类 -两个视图基类 APIView:类属性authentication_classes，permission_classes GenericAPIView：方法和类属性 -5个视图扩展类 -9个视图子类 -视图集： ViewSetMixin, ViewSet, GenericViewSet, ModelViewSet, ReadOnlyModelViewSet# 5 路由 -三种写法 -基本写法 -视图类继承ViewSetMixin写法 as_view中传字典 -自动生成路由 -SimpleRouter，DefaultRouter -action装饰器，视图类中方法上的 # 6 认证，权限，频率 -登陆认证 -登陆成后用没用权限访问 -普通的权限控制 -rbac权限控制 -访问频率 -局部使用全局使用，局部禁用 # 7 过滤，排序，分页--》GenericAPIView -过滤 -自带的 -第三方 -自定义的 -排序 -内置的 -分页：三种分页方式 -全局异常：写一个函数，配置一下，处理过后统一返回格式# 8 接口文档编写 -自动生成 -手写 -录入第三方# 9 jwt认证 -原理是什么 -base64编码和专门 -django中如何使用jwt -快速签发和认证 -基于auth的user表签发，可以指定返回格式 -认证类，权限类 -基于自己的user表签发和认证 -自己写登录方法 -自己写认证类# 10 混合的后台管理---》快速的写出一个符合rbac权限的管理系统 -admin---》美化---》simpleui # 11 rbac权限# 考试题---》参照笔记---》如果能写出来，一点问题都没有# 面试常考题：__init__和__new__区别 -__init__:对对象进行初始化 对象= 类(name=lqz)--》触发__init__的执行完成初始化，self.name=name--&gt;在执行__init__之前，对象已经产生了，对象什么时候产生的？ -__new__：创建出空对象，在__init__之前完成的 -重写它，使得构造的对象不是眼看到的对象 # 面试常考题：魔法方法---》一类中：__名字__方法---》不需要主动触发，在某种情况下会调用 -非常非常多：https://www.cnblogs.com/liuqingzheng/articles/9949568.html __str__:print(对象)， __inti__:类(), __setattr__ __getattr__ __setitem__ __call__:对象()触发 1 前端介绍123456789101112131415# 1 HTML(5)、CSS(3)、JavaScript(ES5、ES6)：编写一个个的页面 -&gt; 给后端(PHP、Python、Go、Java) -&gt; 后端嵌入模板语法 -&gt; 后端渲染完数据 -&gt; 返回数据给前端 -&gt; 在浏览器中查看# javascript=ecmascript+dom+bom 2015年es6--》格式化字符串 ``# 2 Ajax的出现 -&gt; 后台发送异步请求，Render+Ajax混合# 3 单用Ajax（加载数据，DOM渲染页面）：前后端分离的雏形# 4.Angular框架的出现（1个JS框架）：出现了“前端工程化”的概念（前端也是1个工程、1个项目）# 5 React、Vue框架：当下最火的2个前端框架（Vue：国人喜欢用，React：外国人喜欢用）# 6 移动开发（Android+IOS） + Web（Web+微信小程序+支付宝小程序） + 桌面开发（Windows桌面）：前端 -&gt; 大前端# 移动端混合开发：原生+页面---》支付宝--》口碑# 7 一套代码在各个平台运行（大前端）：谷歌Flutter（Dart语言：和Java很像）可以运行在IOS、Android、PC端# 8 在Vue框架的基础性上 uni-app：一套编码 编到10个平台https://uniapp.dcloud.io/case.html# 9 在不久的将来 ，前端框架可能会一统天下# html css（less，sass） js jq，bootstrap es6 webpack vue react 小程序开发 node git mongodb 2 vue介绍特性介绍1234567891011121314151617181920212223# vue介绍Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合可以一点一点地使用它，只用一部分，也可以整个工程都使用它js的框架，跟jq是一类东西bootstrap：ui框架不是js框架（css样式）vue中使用ui可以引入bootstrap，elementui(饿了么团队出的)，Vant(移动端ui：有赞)，ant-design-vue（ant-design本身是react的ui库）# 版本： -主流：2.x -最新：3.x# 官方有教程：https://cn.vuejs.org/v2/guide/# M-V-VM思想 ----》mvc，mtv，mvp：安卓分层架构Model ：vue对象的data属性里面的数据，这里的数据要显示到页面中，js中变量View ：vue中数据要显示的HTML页面，在vue中，也称之为“视图模板” （HTML+CSS）ViewModel：vue中编写代码时的vm对象，它是vue.js的核心，负责连接 View 和 Model数据的中转，保证视图和数据的一致性，所以前面代码中，data里面的数据被显示中p标签中就是vm对象自动完成的（双向数据绑定：JS中变量变了，HTML中数据也跟着改变）以后不需要显示的使用dom操作，jquery的作用就不大了# 组件化开发，单页面开发 -vue项目---》index.html页面---》看到的变化，都是组件的切换 -页面组件--》放了小组件 -在index.html中替换 组件，就实现页面的变化 3 快速使用vue1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;--&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; class=&quot;div_cls&quot;&gt;&lt;h1&gt;我的名字是：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt; &lt;hr&gt; &#123;&#123;text&#125;&#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; // div(不一定是div) 被vue托管了，在div内部，就可以使用vue的语法：模板，指令系统 var vm =new Vue(&#123; // el:&quot;#app&quot;, el:&quot;.div_cls&quot;, data:&#123; name:&quot;lqz&quot;, text:&quot;&quot; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 1# 在浏览器中打开调试---》console---》vm._data[&#x27;name&#x27;]=&quot;xxx&quot;---&gt;页面跟着变了 4 模板语法之插值1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;--&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;用两个大括号包裹的叫插值,可以写js代码&lt;/h1&gt;&lt;h3&gt;&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;age&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;list1&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;list1[0]&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;obj1.name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;link1&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;1==1&#125;&#125;&lt;/h3&gt; &lt;h3&gt;三目运算符：&#123;&#123;10&gt;20?&#x27;是&#x27;:&#x27;否&#x27;&#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm =new Vue(&#123; el:&quot;#app&quot;, data:&#123; name:&quot;lqz&quot;, age: 18, // 数值 list1: [1,2,3,4], // 数组 obj1: &#123;name: &#x27;lqz&#x27;, age: 19&#125;, // 对象 link1: &#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度一下 你就知道&lt;/a&gt;&#x27; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 1# 插值可以放变量和少量js代码 5 指令系统之文本指令v-xx属性都是vue的指令系统 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;文本指令--v-html--&gt;会把变量的值渲染到标签中,如果字符串是标签，显示标签的样子&lt;/h1&gt; &lt;p v-html=&quot;name&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;link1&quot;&gt;&lt;/p&gt; &lt;h1&gt;文本指令--v-text--&gt;会把变量的值渲染到标签中,如果字符串是标签，不会是标签，字符串原样显示&lt;/h1&gt; &lt;p v-text=&quot;name&quot;&gt;&lt;/p&gt; &lt;p v-text=&quot;link1&quot;&gt;&lt;/p&gt; &lt;h1&gt;文本指令--v-show--&gt;控制标签是否显示:true和false，其实在页面中，但是不现实display:none&lt;/h1&gt; &lt;div v-show=&quot;show&quot;&gt; 我是div &lt;/div&gt; &lt;h1&gt;文本指令--v-if--&gt;控制标签是否显示:true和false，真正的标签不存在了，dom操作，性能低&lt;/h1&gt; &lt;div v-if=&quot;show1&quot;&gt; 我是div222 &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm =new Vue(&#123; el:&quot;#app&quot;, data:&#123; name:&#x27;lqz&#x27;, link1: &#x27;&lt;a href=&quot;https://www.baidu.com&quot;&gt;百度一下 你就知道&lt;/a&gt;&#x27;, show:true, show1:true, &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 6 指令系统之事件指令12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;!-- &lt;button v-on:click=&quot;handleClick&quot;&gt;点我显示隐藏下面的div&lt;/button&gt;--&gt; &lt;button @click=&quot;handleClick&quot;&gt;点我显示隐藏下面的div&lt;/button&gt; &lt;div v-if=&quot;is_show&quot;&gt; 我是div &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; is_show: true, &#125;, methods: &#123; handleClick() &#123; // 把show的值取反,this代指vue对象，vm对象 this.is_show = !this.is_show &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 12v-on:click=&#x27;xx&#x27;v-on: 可以简写成 @ 以后使用这个多 7 指令系统之属性指令12# v-bind:属性=&#x27;js的变量&#x27;# 简写成 :属性=&#x27;js的变量&#x27; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .red &#123; background: red; &#125; .green &#123; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;changeBac&quot;&gt;点我变色&lt;/button&gt; &lt;!-- &lt;p v-bind:class=&quot;p_class&quot; class=&quot;&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;--&gt; &lt;p :class=&quot;p_class&quot; class=&quot;&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;changePhoto&quot;&gt;点我切换美女&lt;/button&gt; &lt;div&gt; &lt;img :src=&quot;url&quot; alt=&quot;&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; name: &#x27;彭于晏&#x27;, p_class: &#x27;red&#x27;, url: &#x27;https://tva1.sinaimg.cn/large/00831rSTly1gd1u0jw182j30u00u043b.jpg&#x27; &#125;, methods: &#123; changeBac() &#123; this.p_class = &#x27;green&#x27; &#125;, changePhoto() &#123; this.url = &#x27;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2F09%2F3a%2Fbc%2F093abce7b31f4c8ffdbf345375ff4abb.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652321528&amp;t=3709d1c880107a53d265f936022f0d53&#x27; &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"8、vue笔记","slug":"8、vue笔记","permalink":"https://chenxiao0629.github.io/tags/8%E3%80%81vue%E7%AC%94%E8%AE%B0/"}]},{"title":"04、scrapy：（架构、目录介绍、解析数据、setting配置、全站爬取cnblogs文章、存储数据、爬虫中间件、下载中间件、加代理、加header、集成selenium）","slug":"crawl_day05","date":"2020-01-13T06:04:04.000Z","updated":"2022-05-14T06:24:15.502Z","comments":true,"path":"2020/01/13/crawl_day05/","link":"","permalink":"https://chenxiao0629.github.io/2020/01/13/crawl_day05/","excerpt":"","text":"1 scrapy架构和目录介绍12345# pip3 install scrapy# 创建项目：scrapy startproject cnblogs_spider 等同于django创建项目# 创建爬虫：scrapy genspider cnblogs www.cnblogs.com 等同于创建app -本质就是在spiders文件夹下创建一个py文件，写入一些代码# 运行爬虫：scrapy crawl 爬虫名 1.1 项目目录介绍12345678910111213cnblogs_spider # 项目名字 -cnblogs_spider # 文件夹 -spiders # 文件夹，下面放了一个个爬虫文件 -cnblogs.py # 一个个的爬虫文件 items.py # 模型类写了一些字段---》类似于django的models middlewares.py # 中间件：爬虫中间件和下载中间件 pipelines.py # 管道：存储数据的代码写在这 settings.py # 项目的配置文件 scrapy.cfg # 项目上线需要用到，不用管 # 重点：咱们以后主要是在cnblogs.py爬虫文件中写爬取和解析的逻辑，pipelines写存储 1.2 scrapy架构123456789101112131415161718192021# 引擎(EGINE)--&gt;大总管，负责全部的数据流向--》内置的，咱们不需要写引擎负责控制系统所有组件之间的数据流，并在某些动作发生时触发事件。# 调度器(SCHEDULER)---》对要爬取的地址进行排队，去重用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL的优先级队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址# 下载器(DOWLOADER)--》真正负责下载---》高效的异步模型用于下载网页内容, 并将网页内容返回给EGINE，下载器是建立在twisted这个高效的异步模型上的# 爬虫(SPIDERS)--》咱们重点写的地方，解析响应，从响应中提取要保存的数据和下一次爬取的地址SPIDERS是开发人员自定义的类，用来解析responses，并且提取items，或者发送新的请求# 项目管道(ITEM PIPLINES)---》存储数据的逻辑---》可以存到文件，redis，mysql。。。在items被提取后负责处理它们，主要包括清理、验证、持久化（比如存到数据库）等操作# 下载器中间件(Downloader Middlewares)--》用的多位于Scrapy引擎和下载器之间，主要用来处理从EGINE传到DOWLOADER的请求request(加请求头，加cookie，加代理)，已经从DOWNLOADER传到EGINE的响应response进行一些处理# 爬虫中间件(Spider Middlewares)---》用的少位于EGINE和SPIDERS之间，主要工作是处理SPIDERS的输入（即responses）和输出（即requests） 1.3 py文件直接运行爬虫123456# 右键运行它就可以运行爬虫，不需要每次都敲命令from scrapy import cmdline# cmdline.execute([&#x27;scrapy&#x27;, &#x27;crawl&#x27; ,&#x27;cnblogs&#x27;,&#x27;--nolog&#x27;])cmdline.execute([&#x27;scrapy&#x27;, &#x27;crawl&#x27; ,&#x27;cnblogs&#x27;]) 2 scrapy解析数据12345678910111213141516################################### 重点1 response对象有css方法和xpath方法 -css中写css选择器 -xpath中写xpath选择2 重点1： -xpath取文本内容 &#x27;.//a[contains(@class,&quot;link-title&quot;)]/text()&#x27; -xpath取属性 &#x27;.//a[contains(@class,&quot;link-title&quot;)]/@href&#x27; -css取文本 &#x27;a.link-title::text&#x27; -css取属性 &#x27;img.image-scale::attr(src)&#x27;3 重点2： .extract_first() 取一个 .extract() 取所有 3 setting中相关配置3.1 基本配置1234567891011# 两套配置，内置一套，用户一套ROBOTSTXT_OBEY = False # 是否遵循爬虫协议，如果写了它，一般网站都不让爬，基本写成falseUSER_AGENT = &#x27;浏览器头&#x27; # 爬虫请求头中USER_AGENT是什么，做成浏览器的样子LOG_LEVEL=&#x27;ERROR&#x27; # 日志级别改成ERROR，以后错误日志会打印，普通日志不打印#---------#####-------SPIDER_MIDDLEWARES=[] # 爬虫中间件，可以写多个DOWNLOADER_MIDDLEWARES=[] # 下载中间件类，配置在这，可以配多个ITEM_PIPELINES=[] # 保存数据，会执行到的类，类内部写保存逻辑 3.2 提高爬虫效率1234567891011#1 增加并发：默认scrapy开启的并发线程为32个，可以适当进行增加。在settings配置文件中修改CONCURRENT_REQUESTS = 100值为100,并发设置成了为100。#2 降低日志级别：在运行scrapy时，会有大量日志信息的输出，为了减少CPU的使用率。可以设置log输出信息为INFO或者ERROR即可。在配置文件中编写：LOG_LEVEL = &#x27;INFO&#x27;# 3 禁止cookie：如果不是真的需要cookie，则在scrapy爬取数据时可以禁止cookie从而减少CPU的使用率，提升爬取效率。在配置文件中编写：COOKIES_ENABLED = False# 4 禁止重试：对失败的HTTP进行重新请求（重试）会减慢爬取速度，因此可以禁止重试。在配置文件中编写：RETRY_ENABLED = False# 5 减少下载超时：如果对一个非常慢的链接进行爬取，减少下载超时可以能让卡住的链接快速被放弃，从而提升效率。在配置文件中进行编写：DOWNLOAD_TIMEOUT = 10 超时时间为10s 4 全站爬取cnblgos文章12# 只爬了首页---》下一页，文章详情页没有爬取# 文章--》文章对象(标题，作者，摘要，详情。。。)---》把整站都爬取完成 4.1 request和response对象传递参数12345# 在request中通过meta传递 yield Request(url=article_url,callback=self.parse_detail,meta=&#123;&#x27;item&#x27;:item&#125;)# 在response中通过meta取出 item=response.meta.get(&#x27;item&#x27;) 4.2 解析出下一页地址并继续爬取123# 使用yield Request(url=article_url,callback=self.parse_detail,meta=&#123;&#x27;item&#x27;:item&#125;)yield Request(url=next_url) 5 存储数据1234# 关于mysql出现Data too long for column的解决方案 打开my.ini，将其中sql-mode节中的STRICT_TRANS_TABLES这个属性去掉； 6 爬虫中间件和下载中间件12345671 爬虫和下载中间件要使用，需要在配置文件中SPIDER_MIDDLEWARES = &#123; &#x27;crawl_cnblogs.middlewares.CrawlCnblogsSpiderMiddleware&#x27;: 5,&#125;DOWNLOADER_MIDDLEWARES = &#123; &#x27;crawl_cnblogs.middlewares.CrawlCnblogsDownloaderMiddleware&#x27;: 5,&#125; 7 加代理，加header，集成selenium123456789101112131415161718190 在下载中间件的process_reqeust方法中1 加cookie # request.cookies[&#x27;name&#x27;]=&#x27;lqz&#x27; # request.cookies= &#123;&#125;2 修改header # request.headers[&#x27;Auth&#x27;]=&#x27;asdfasdfasdfasdf&#x27; # request.headers[&#x27;USER-AGENT&#x27;]=&#x27;ssss&#x27;3 加代理 request.meta[&#x27;proxy&#x27;]=&#x27;http://103.130.172.34:8080&#x27; 4 fake_useragent模块，可以随机生成user-aget from fake_useragent import UserAgent ua = UserAgent() print(ua.ie) #随机打印ie浏览器任意版本 print(ua.firefox) #随机打印firefox浏览器任意版本 print(ua.chrome) #随机打印chrome浏览器任意版本 print(ua.random) #随机打印任意厂家的浏览器","categories":[],"tags":[{"name":"10、爬虫","slug":"10、爬虫","permalink":"https://chenxiao0629.github.io/tags/10%E3%80%81%E7%88%AC%E8%99%AB/"}]},{"title":"03、selenium：基本使用、无头浏览器、获取元素（位置、属性、大小）、等待元素被加载、元素操作、执行js、切换选项卡、模拟前进后退、异常处理、登录cnblogs获取cookie、抽屉半自动点赞  扫码频台使用、爬取京东商品信息、scrapy介绍与安装","slug":"crawl_day04","date":"2020-01-13T06:04:03.000Z","updated":"2022-05-14T06:01:07.215Z","comments":true,"path":"2020/01/13/crawl_day04/","link":"","permalink":"https://chenxiao0629.github.io/2020/01/13/crawl_day04/","excerpt":"","text":"1 selenium的使用1234567891011121314# 之前咱们学requests，可以发送http请求，但是有的页面是由render+ajax渲染完的,如果只使用requestes，它只能执行render的请求，拿回数据，执行ajax的请求，需要你再去分析，再去发请求# 使用selenium，控制浏览器，操作浏览器，完成人的行为--&gt;自动化测试工具# 本质是python通过代码，借助于浏览器驱动，操作浏览器# 真正的实现了，可见即可爬# 下载模块：pip3 install selenium # 下载相关浏览器驱动：IE,火狐，谷歌(推荐用)# 谷歌驱动：https://registry.npmmirror.com/binary.html?path=chromedriver/ -跟浏览器版本一定要对应 -101.0.4951.54----》驱动也要对应https://registry.npmmirror.com/binary.html?path=chromedriver/101.0.4951.41/ -如果没有具体版本找一个最接近的 -把驱动放在项目下 1.0 基本使用123456789101112131415161718192021222324252627from selenium import webdriverimport time# 用代码打开一个浏览器bro=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;) # mac linux# bro=webdriver.Chrome(executable_path=&#x27;chromedriver.exe&#x27;) # win# 在地址栏输入地址bro.get(&#x27;https://www.baidu.com&#x27;)# 找到输入框search=bro.find_element_by_id(&#x27;kw&#x27;)# 在输入框输入美女search.send_keys(&quot;美女&quot;)# 找到百度一下按钮button=bro.find_element_by_id(&#x27;su&#x27;)# 点击一下按钮button.click()time.sleep(2)print(bro.page_source) # 当前页面的html内容with open(&#x27;baidu.html&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f: f.write(bro.page_source) # 包含redner+ajaxbro.close() 1.1 无头浏览器12# 做爬虫，不希望显示的打开浏览器，但是selenium必须要用浏览器，让浏览器不显示，后台运行，完成爬虫 1234567891011121314151617from selenium import webdriverfrom selenium.webdriver.chrome.options import Options# 得到一个配置对象chrome_options = Options()chrome_options.add_argument(&#x27;window-size=1920x3000&#x27;) #指定浏览器分辨率chrome_options.add_argument(&#x27;--disable-gpu&#x27;) #谷歌文档提到需要加上这个属性来规避bugchrome_options.add_argument(&#x27;--hide-scrollbars&#x27;) #隐藏滚动条, 应对一些特殊页面chrome_options.add_argument(&#x27;blinfk-settings=imagesEnabled=alse&#x27;) #不加载图片, 提升速度chrome_options.add_argument(&#x27;--headless&#x27;) #浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败bro=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;,options=chrome_options)bro.get(&#x27;http://www.cnblogs.com&#x27;)print(bro.page_source)bro.close() 1.2 获取元素位置，属性，大小123456789101112# 一般验证码破解上## 补充：标签位置和大小:size和location# 一般用来扣验证码图片：可能会由于分辨率问题导致扣出的图不一致---》通过修改分辨率--》实现正确抠图# 验证码是img---》src--》自己加载就能拿到验证码，保存到本地即可(requests)--&gt;更简单print(tag.id) # id，但是不是标签的id，selenium提供的一个idprint(tag.location) # 位置print(tag.tag_name) # 标签名print(tag.size) # 标签的大小 12345678910111213141516171819202122232425262728293031323334353637383940from selenium import webdriverimport timefrom PIL import Imagebro=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;) # mac linux# 在地址栏输入地址bro.get(&#x27;https://www.jd.com/&#x27;)# 找到图片img=bro.find_element_by_css_selector(&#x27;a.logo_tit_lk&#x27;)# print(img.location) # 图片位置 &#123;&#x27;x&#x27;: 105, &#x27;y&#x27;: 41&#125;# print(img.size) # 图片大小 通过位置和大小可以唯一确定这张图，通过截图可以把图截出来# print(img.id) # selenium提供的id号，忽略# print(img.tag_name) # alocation=img.locationsize=img.sizebro.save_screenshot(&#x27;./main.png&#x27;) # 把整个页面保存成图片# pillow抠图，把图标抠出来# 第一个参数 开始截图的x坐标# 第二个参数 开始截图的y坐标# 第三个参数 结束截图的x坐标# 第四个参数 结束截图的y坐标img_tu = (int(location[&#x27;x&#x27;]), int(location[&#x27;y&#x27;]), int(location[&#x27;x&#x27;] + size[&#x27;width&#x27;]), int(location[&#x27;y&#x27;] + size[&#x27;height&#x27;]))# #使用pillow打开截图img=Image.open(&#x27;./main.png&#x27;)#从截图中按照位置扣除验证码code_img=img.crop(img_tu)# 把扣出来的图，保存到本地code_img.save(&#x27;./code.png&#x27;)# 参数说明bro.close()## 补充：标签位置和大小:size和location# 一般用来扣验证码图片：可能会由于分辨率问题导致扣出的图不一致---》通过修改分辨率--》实现正确抠图# 验证码是img---》src--》自己加载就能拿到验证码，保存到本地即可(requests)--&gt;更简单 1.3 等待元素被加载12345# 代码操作，速度非常快，可能标签还没有加载出来，代码就去取标签操作，所以找不到标签，报错# 等待标签加载完成再取 -显示等待：每个标签都要写等待逻辑 -隐式等待：任何要取的标签都遵循这个逻辑，只需要写一次（推荐用） bro.implicitly_wait(10) # 取这个标签，如果取不到就等待，直到标签加载完成或10s到了 1.4 元素操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from selenium import webdriverimport timebro=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;) # mac linuxbro.get(&#x27;https://www.baidu.com/&#x27;)bro.implicitly_wait(10) # 隐式等待# 查找标签的方式：# selenium:find_element_by_xx,find_elements_by_xx# 1、find_element_by_id # 通过id找# 2、find_element_by_link_text # 通过a标签文字# 3、find_element_by_partial_link_text # 通过a标签文字模糊找# 4、find_element_by_tag_name # 通过标签名找# 5、find_element_by_class_name # 通过类名找# 6、find_element_by_name # 通过name属性找# 7、find_element_by_css_selector # css选择器# 8、find_element_by_xpath # xpath选择器# 查找a标签文本内容是登陆的login_a=bro.find_element_by_link_text(&#x27;登录&#x27;)# login_a=bro.find_element_by_link_id(&#x27;s-top-loginbtn&#x27;)# 点击a标签login_a.click()## 找到账号登陆，点击login_pwd_btn=bro.find_element_by_id(&#x27;TANGRAM__PSP_11__changePwdCodeItem&#x27;)login_pwd_btn.click()# 找到用户名的输入框和密码的输入框--》输入用户名密码username=bro.find_element_by_name(&#x27;userName&#x27;)pwd=bro.find_element_by_css_selector(&#x27;#TANGRAM__PSP_11__password&#x27;)username.send_keys(&quot;30033445@qq.com&quot;)pwd.send_keys(&#x27;lqz12345678&#x27;)time.sleep(3)username.clear()username.send_keys(&quot;lqz12345@qq.com&quot;)submit=bro.find_element_by_id(&#x27;TANGRAM__PSP_11__submit&#x27;)submit.click()# 弹出验证码识别--》可以手动点击# 登陆成功time.sleep(5)bro.close()# 登陆越来越难自动登陆---》明白登陆的目的是什么？---》# 拿到cookie发送请求，水军自动回复，投票，点赞，评论--》半自动登陆后--》# 取到cookie，搭建cookie池--》每次使用requests发送请求，自动评论，投票，携带cookie# send_keys click clear # 查找方法 1.5 执行js123# 普遍常用，在本地页面中直接执行js代码# 第一种情况，控制操作页面滑动# 第二种情况：使用当前页面中的一些变量,执行页面中的函数 123456789101112131415161718192021222324from selenium import webdriverimport timebro=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;) # mac linuxbro.get(&#x27;https://www.pearvideo.com/category_9&#x27;)bro.implicitly_wait(10) # 隐式等待# bro.execute_script(&quot;alert(&#x27;hello&#x27;)&quot;)# 第一种情况，控制操作页面滑动# bro.execute_script(&#x27;window.scrollBy(0, document.body.scrollHeight)&#x27;)# time.sleep(1)# bro.execute_script(&#x27;window.scrollBy(0, document.body.scrollHeight)&#x27;)# time.sleep(1)# bro.execute_script(&#x27;window.scrollBy(0, document.body.scrollHeight)&#x27;)# 第二种情况：使用当前页面中的一些变量,执行页面中的函数# bro.execute_script(&#x27;alert(md5_vm_test())&#x27;)time.sleep(5)bro.close() 1.6 切换选项卡12345678910111213141516import timefrom selenium import webdriverbrowser=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;)browser.get(&#x27;https://www.baidu.com&#x27;)# 打开选项卡browser.execute_script(&#x27;window.open()&#x27;)print(browser.window_handles) #获取所有的选项卡browser.switch_to.window(browser.window_handles[1])browser.get(&#x27;https://www.taobao.com&#x27;)time.sleep(2)browser.switch_to.window(browser.window_handles[0])browser.get(&#x27;https://www.sina.com.cn&#x27;)browser.close() # 关闭当前选项卡browser.quit() # 退出浏览器 1.7 模拟前进后退123456789101112import timefrom selenium import webdriverbrowser=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;)browser.get(&#x27;https://www.baidu.com&#x27;)browser.get(&#x27;https://www.taobao.com&#x27;)browser.get(&#x27;http://www.sina.com.cn/&#x27;)browser.back()time.sleep(2)browser.forward()browser.close() 1.8 异常处理1234567891011121314from selenium import webdriverfrom selenium.common.exceptions import TimeoutException,NoSuchElementException,NoSuchFrameExceptiontry: browser=webdriver.Chrome() browser.get(&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;) browser.switch_to.frame(&#x27;iframssseResult&#x27;)except TimeoutException as e: print(e)except NoSuchFrameException as e: print(e)finally: browser.close() 1.9 selenium登录cnblogs获取cookie123# 先使用selenium 半自动登录到cnblogs----》取出cookie存到本地# 下次使用selenium 访问cnblogs--》加载之前的cookie---》变成了登陆状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from selenium import webdriverimport jsonimport timebro=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;)# 登陆取cookie的过程# try:# bro.get(&#x27;http://www.cnblogs.com&#x27;)# bro.implicitly_wait(10)# submit_a=bro.find_element_by_link_text(&#x27;登录&#x27;)# submit_a.click()# username=bro.find_element_by_id(&#x27;mat-input-0&#x27;)# password=bro.find_element_by_id(&#x27;mat-input-1&#x27;)# username.send_keys(&#x27;616564099@qq.com&#x27;)# password.send_keys(&#x27;lqz123&#x27;) # 手动输入#### # submit=bro.find_element_by_class_name(&#x27;mat-button-wrapper&#x27;)# # submit.click()# input() # 手动输入密码，点击登录，验证码通过，再敲回车，继续往下走# # 弹出验证码---》不好破---&gt;手动操作---》# # 登陆成功了# # 把cookie保存到本地# # print(bro.get_cookies())## with open(&#x27;cnblogs.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:# json.dump(bro.get_cookies(),f)### except Exception as e:# print(e)# finally:# bro.close()# 访问写入cookietry: bro.get(&#x27;http://www.cnblogs.com&#x27;) bro.implicitly_wait(10) # 写入本地的cookie with open(&#x27;cnblogs.json&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as f: cookie_dic=json.load(f) # 写入到浏览器 # bro.add_cookie(cookie_dic) for item in cookie_dic: # 设置cookie必须用字典，cookie的json文件是列表，所以用循环往里放 bro.add_cookie(item) bro.refresh() # 刷新一下浏览器 time.sleep(2)except Exception as e: print(e)finally: bro.close() 1.10 抽屉半自动点赞123# (纯自动登陆，不好登)使用selenium半自动登陆---》可以登陆上很多小号---》拿到cookie保存到redis(保存到本地)# 再使用requests+cookie池中的某个cookie---》刷评论，刷赞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from selenium import webdriverimport timeimport json# 1 先登陆进去，取到cookie， 存到本地# bro=webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;)# try:# bro.get(&#x27;https://dig.chouti.com/&#x27;)# submit_btn=bro.find_element_by_id(&#x27;login_btn&#x27;)# submit_btn.click() # 如果报错，用下面这句# # bro.execute_script(&#x27;arguments[0].click();&#x27;, submit_btn) # 使用js点击## username=bro.find_element_by_name(&#x27;phone&#x27;)# pwd=bro.find_element_by_name(&#x27;password&#x27;)# username.send_keys(&#x27;18953675221&#x27;)# pwd.send_keys(&#x27;lqz123----&#x27;)## submit=bro.find_element_by_css_selector(&#x27;body &gt; div.login-dialog.dialog.animated2.scaleIn &gt; div &gt; div.login-footer &gt; div:nth-child(4) &gt; button&#x27;)## time.sleep(2)# submit.click()# # 出验证码# input()## with open(&#x27;chouti.json&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:# json.dump(bro.get_cookies(),f)## time.sleep(3)## except Exception as e:# print(e)# finally:# bro.close()# 使用requests自动点赞---》requests可以多线程，速度快的一批，如果使用selenium操作浏览器，没法多线程，吃内存很大import requestsfrom bs4 import BeautifulSoupheader = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36&#x27;&#125;res=requests.get(&#x27;https://dig.chouti.com/&#x27;,headers=header)# print(res.text)soup=BeautifulSoup(res.text,&#x27;lxml&#x27;)div_list=soup.find_all(class_=&#x27;link-item&#x27;)for div in div_list: article_id=div.attrs.get(&#x27;data-id&#x27;) print(article_id) if article_id: data = &#123; &#x27;linkId&#x27;: article_id &#125; # cookie 写入 cookie=&#123;&#125; with open(&#x27;chouti.json&#x27;, &#x27;r&#x27;) as f: res = json.load(f) for item in res: # selenium的cookie和requests模块使用的cookie不太一样，requests只要name和value cookie[item[&#x27;name&#x27;]] = item[&#x27;value&#x27;] res = requests.post(&#x27;https://dig.chouti.com/link/vote&#x27;, headers=header, data=data,cookies=cookie) print(res.text)# data = &#123;# &#x27;linkId&#x27;: &#x27;34976644&#x27;# &#125;# res = requests.post(&#x27;https://dig.chouti.com/link/vote&#x27;, headers=header, data=data)# print(res) 2 打码平台使用12345678# 验证码---》简单的数字字母验证码---》选择(选出所有草莓)---》计算类--》滑动类--》点选类---》# 第三方平台破解验证码---》花钱买服务，把图片给人家，人家帮你解开，返回来# 云打码，超级鹰# 超级鹰 -开发文档：python示例代码 -应用案例：爬虫采集技术，自动智能化、人工化(大妈破解--》传给你)多种模式兼备 -价格体系：1元=1000分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import requestsfrom hashlib import md5class ChaojiyingClient(): def __init__(self, username, password, soft_id): self.username = username password = password.encode(&#x27;utf8&#x27;) self.password = md5(password).hexdigest() self.soft_id = soft_id self.base_params = &#123; &#x27;user&#x27;: self.username, &#x27;pass2&#x27;: self.password, &#x27;softid&#x27;: self.soft_id, &#125; self.headers = &#123; &#x27;Connection&#x27;: &#x27;Keep-Alive&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0)&#x27;, &#125; def PostPic(self, im, codetype): &quot;&quot;&quot; im: 图片字节 codetype: 题目类型 参考 http://www.chaojiying.com/price.html &quot;&quot;&quot; params = &#123; &#x27;codetype&#x27;: codetype, &#125; params.update(self.base_params) files = &#123;&#x27;userfile&#x27;: (&#x27;ccc.jpg&#x27;, im)&#125; r = requests.post(&#x27;http://upload.chaojiying.net/Upload/Processing.php&#x27;, data=params, files=files, headers=self.headers) return r.json() def PostPic_base64(self, base64_str, codetype): &quot;&quot;&quot; im: 图片字节 codetype: 题目类型 参考 http://www.chaojiying.com/price.html &quot;&quot;&quot; params = &#123; &#x27;codetype&#x27;: codetype, &#x27;file_base64&#x27;:base64_str &#125; params.update(self.base_params) r = requests.post(&#x27;http://upload.chaojiying.net/Upload/Processing.php&#x27;, data=params, headers=self.headers) return r.json() def ReportError(self, im_id): &quot;&quot;&quot; im_id:报错题目的图片ID &quot;&quot;&quot; params = &#123; &#x27;id&#x27;: im_id, &#125; params.update(self.base_params) r = requests.post(&#x27;http://upload.chaojiying.net/Upload/ReportError.php&#x27;, data=params, headers=self.headers) return r.json()if __name__ == &#x27;__main__&#x27;: chaojiying = ChaojiyingClient(&#x27;306334678&#x27;, &#x27;lqz12345&#x27;, &#x27;903641&#x27;) #用户中心&gt;&gt;软件ID 生成一个替换 96001 im = open(&#x27;./b.png&#x27;, &#x27;rb&#x27;).read() #本地图片文件路径 来替换 a.jpg 有时WIN系统须要// print(chaojiying.PostPic(im, 6001)) #1902 验证码类型 官方网站&gt;&gt;价格体系 3.4+版 print 后要加() #print chaojiying.PostPic(base64_str, 1902) #此处为传入 base64代码 3 xpath使用12345678910111213141516# css 和 xpath 和自己的# xpath：XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言&#x27;&#x27;&#x27;. # 选取当前节点。.. # 选取当前节点的父节点。/ # 表示当前路径// # 表示任意路径，子子孙孙nodename # a img p 节点名字 —举例 //div # //div 在当前html的任意路径下找div /div # 只找本层的div* # 任意标签@href # 取这个标签的属性/text() # 获取标签的文本&#x27;&#x27;&#x27; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788doc=&#x27;&#x27;&#x27;&lt;html&gt; &lt;head&gt; &lt;base href=&#x27;http://example.com/&#x27; /&gt; &lt;title&gt;Example website&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#x27;images&#x27;&gt; &lt;a href=&#x27;image1.html&#x27;&gt;Name: My image 1 &lt;br /&gt;&lt;img src=&#x27;image1_thumb.jpg&#x27; /&gt;&lt;/a&gt; &lt;a href=&#x27;image2.html&#x27;&gt;Name: My image 2 &lt;br /&gt;&lt;img src=&#x27;image2_thumb.jpg&#x27; /&gt;&lt;/a&gt; &lt;a href=&#x27;image3.html&#x27;&gt;Name: My image 3 &lt;br /&gt;&lt;img src=&#x27;image3_thumb.jpg&#x27; /&gt;&lt;/a&gt; &lt;a href=&#x27;image4.html&#x27;&gt;Name: My image 4 &lt;br /&gt;&lt;img src=&#x27;image4_thumb.jpg&#x27; /&gt;&lt;/a&gt; &lt;a href=&#x27;image5.html&#x27; class=&#x27;li li-item&#x27; name=&#x27;items&#x27;&gt;Name: My image 5 &lt;br /&gt;&lt;img src=&#x27;image5_thumb.jpg&#x27; /&gt;&lt;/a&gt; &lt;a href=&#x27;image6.html&#x27; name=&#x27;items&#x27;&gt;&lt;span&gt;&lt;h5&gt;test&lt;/h5&gt;&lt;/span&gt;Name: My image 6 &lt;br /&gt;&lt;img src=&#x27;image6_thumb.jpg&#x27; /&gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&#x27;&#x27;&#x27;from lxml import etreehtml=etree.HTML(doc)# html=etree.parse(&#x27;search.html&#x27;,etree.HTMLParser())# 1 所有节点# a=html.xpath(&#x27;//*&#x27;)# 2 指定节点（结果为列表）# a=html.xpath(&#x27;//head&#x27;)# 3 子节点，子孙节点# a=html.xpath(&#x27;//div/a&#x27;)# a=html.xpath(&#x27;//body/a&#x27;) #无数据# a=html.xpath(&#x27;//body//a&#x27;)# 4 父节点# a=html.xpath(&#x27;//body//a[@href=&quot;image1.html&quot;]/..&#x27;)# a=html.xpath(&#x27;//body//a[1]/..&#x27;)# 也可以这样# a=html.xpath(&#x27;//body//a[1]/parent::*&#x27;)# 5 属性匹配# a=html.xpath(&#x27;//body//a[@href=&quot;image1.html&quot;]&#x27;)# 6 文本获取# a=html.xpath(&#x27;//body//a[@href=&quot;image1.html&quot;]/text()&#x27;)# 7 属性获取# a=html.xpath(&#x27;//body//a/@href&#x27;)# # 注意从1 开始取（不是从0）# a=html.xpath(&#x27;//body//a[1]/@href&#x27;)# 8 属性多值匹配# a 标签有多个class类，直接匹配就不可以了，需要用contains# a=html.xpath(&#x27;//body//a[@class=&quot;li&quot;]&#x27;)# a=html.xpath(&#x27;//body//a[contains(@class,&quot;li&quot;)]&#x27;)# a=html.xpath(&#x27;//body//a[contains(@class,&quot;li&quot;)]/text()&#x27;)# 9 多属性匹配# a=html.xpath(&#x27;//body//a[contains(@class,&quot;li&quot;) or @name=&quot;items&quot;]&#x27;)# a=html.xpath(&#x27;//body//a[contains(@class,&quot;li&quot;) and @name=&quot;items&quot;]/text()&#x27;)# # a=html.xpath(&#x27;//body//a[contains(@class,&quot;li&quot;)]/text()&#x27;)# 10 按序选择# a=html.xpath(&#x27;//a[2]/text()&#x27;)# a=html.xpath(&#x27;//a[2]/@href&#x27;)# 取最后一个# a=html.xpath(&#x27;//a[last()]/@href&#x27;)# 位置小于3的# a=html.xpath(&#x27;//a[position()&lt;3]/@href&#x27;)# 倒数第二个# a=html.xpath(&#x27;//a[last()-2]/@href&#x27;)# 11 节点轴选择# ancestor：祖先节点# 使用了* 获取所有祖先节点# a=html.xpath(&#x27;//a/ancestor::*&#x27;)# # 获取祖先节点中的div# a=html.xpath(&#x27;//a/ancestor::div&#x27;)# attribute：属性值# a=html.xpath(&#x27;//a[1]/attribute::*&#x27;)# child：直接子节点# a=html.xpath(&#x27;//a[1]/child::*&#x27;)# descendant：所有子孙节点# a=html.xpath(&#x27;//a[6]/descendant::*&#x27;)# following:当前节点之后所有节点# a=html.xpath(&#x27;//a[1]/following::*&#x27;)# a=html.xpath(&#x27;//a[1]/following::*[1]/@href&#x27;)# following-sibling:当前节点之后同级节点# a=html.xpath(&#x27;//a[1]/following-sibling::*&#x27;)# a=html.xpath(&#x27;//a[1]/following-sibling::a&#x27;)# a=html.xpath(&#x27;//a[1]/following-sibling::*[2]&#x27;)# a=html.xpath(&#x27;//a[1]/following-sibling::*[2]/@href&#x27;)# print(a)# 中级大招---》复制# //*[@id=&quot;maincontent&quot;]/div[5]/table/tbody/tr[2]/td[2] 4 爬取京东商品信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from selenium import webdriverfrom selenium.webdriver.common.keys import Keys # 键盘按键操作import timedef get_goods(driver): try: # 找到所有类名叫gl-item的标签 goods = driver.find_elements_by_class_name(&#x27;gl-item&#x27;) for good in goods: detail_url = good.find_element_by_tag_name(&#x27;a&#x27;).get_attribute(&#x27;href&#x27;) p_name = good.find_element_by_css_selector(&#x27;.p-name em&#x27;).text.replace(&#x27;\\n&#x27;, &#x27;&#x27;) price = good.find_element_by_css_selector(&#x27;.p-price i&#x27;).text p_commit = good.find_element_by_css_selector(&#x27;.p-commit a&#x27;).text img=good.find_element_by_css_selector(&#x27;div.p-img img&#x27;).get_attribute(&#x27;src&#x27;) if not img: img=&#x27;http:&#x27;+good.find_element_by_css_selector(&#x27;div.p-img img&#x27;).get_attribute(&#x27;data-lazy-img&#x27;) msg = &#x27;&#x27;&#x27; 商品 : %s 链接 : %s 图片 : %s 价钱 ：%s 评论 ：%s &#x27;&#x27;&#x27; % (p_name, detail_url,img, price, p_commit) print(msg, end=&#x27;\\n\\n&#x27;) button = driver.find_element_by_partial_link_text(&#x27;下一页&#x27;) button.click() time.sleep(1) get_goods(driver) except Exception: passdef spider(url, keyword): driver = webdriver.Chrome(executable_path=&#x27;./chromedriver&#x27;) driver.get(url) driver.implicitly_wait(3) # 使用隐式等待 try: input_tag = driver.find_element_by_id(&#x27;key&#x27;) input_tag.send_keys(keyword) input_tag.send_keys(Keys.ENTER) # 敲回车 get_goods(driver) finally: driver.close()if __name__ == &#x27;__main__&#x27;: spider(&#x27;https://www.jd.com/&#x27;, keyword=&#x27;精品内衣&#x27;) 5 scrapy 介绍和安装123456789101112131415161718192021222324252627# 之前学的requests，bs4，selenium 都叫模块# scrapy ：框架 类似于djagno框架，在固定的位置写固定的代码即可# 基于这个框架写一个爬虫项目# 安装： pip3 install scrapy # mac linux 上没问题# win上可能装不上（90%都能装上）---》其实是因为twisted装不上 1、pip3 install wheel # 装了它，以后支持直接使用whl文件安装 #安装后，便支持通过wheel文件安装软件，wheel文件官网：https://www.lfd.uci.edu/~gohlke/pythonlibs 3、pip3 install lxml 4、pip3 install pyopenssl 5、下载并安装pywin32：https://sourceforge.net/projects/pywin32/files/pywin32/ 6、下载twisted的wheel文件：http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted 7、执行pip3 install 下载目录\\Twisted-17.9.0-cp36-cp36m-win_amd64.whl 8、pip3 install scrapy # 装完后，就会有个scrapy 可执行文件 等同于django-admin# 创建scrapy项目 等同于django-admin scrapy startproject myfirst# 使用pycharm打开# 创建爬虫 等同于django 创建app# scrapy genspider 爬虫名 爬虫地址scrapy genspider cnblogs www.cnblogs.com# 运行爬虫 scrapy crawl cnblogs","categories":[],"tags":[{"name":"10、爬虫","slug":"10、爬虫","permalink":"https://chenxiao0629.github.io/tags/10%E3%80%81%E7%88%AC%E8%99%AB/"}]},{"title":"02、使用requests爬取梨视频、requests+bs4爬取汽车之家、bs4（遍历文档树、搜索文档树、css选择器）","slug":"crawl_day03","date":"2020-01-13T06:04:02.000Z","updated":"2022-05-14T05:58:36.222Z","comments":true,"path":"2020/01/13/crawl_day03/","link":"","permalink":"https://chenxiao0629.github.io/2020/01/13/crawl_day03/","excerpt":"","text":"1 使用requests爬取梨视频12345678910# 模拟发送http请求的库：requests---》只能发送http请求----》没有解析库--》re、bs4、lxml# requests-html：发送请求+解析xml# 视频m3u8格式，分段---》会员试看6分钟---》之加载了6分钟# 收费视频：视频解析# 视频去水印--》fmmpeg--》加水印，拼接裁剪，抠图，转码。。。# 装上使用python来调用处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# re 解析想要的数据# import requests# res=requests.get(&quot;https://www.pearvideo.com/&quot;)# print(res.text)# https://www.pearvideo.com/category_loading.jsp?reqType=5&amp;categoryId=8&amp;start=24import requestsimport reres=requests.get(&#x27;https://www.pearvideo.com/category_loading.jsp?reqType=5&amp;categoryId=8&amp;start=24&#x27;)# print(res.text)# 解析出页面中所有的视频地址video_list=re.findall(&#x27;&lt;a href=&quot;(.*?)&quot; class=&quot;vervideo-lilink actplay&quot;&gt;&#x27;,res.text)# print(video_list)for video in video_list: video_url=&#x27;https://www.pearvideo.com/&#x27;+video video_id=video_url.split(&#x27;_&#x27;)[-1] header=&#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36&#x27;, &#x27;Referer&#x27;: video_url &#125; # 第一层反扒是加refer res_video=requests.get(&#x27;https://www.pearvideo.com/videoStatus.jsp?contId=%s&amp;mrd=0.7113776105084832&#x27;%video_id,headers=header) mp4_url=res_video.json()[&#x27;videoInfo&#x27;][&#x27;videos&#x27;][&#x27;srcUrl&#x27;] # 第二层反扒是把不能播放地址变成能播放地址 mp4_url = mp4_url.replace(mp4_url.split(&#x27;/&#x27;)[-1].split(&#x27;-&#x27;)[0], &#x27;cont-%s&#x27; % video_id) print(mp4_url) # 下载到本地 res_video_detail=requests.get(mp4_url) with open(&#x27;./video/%s.mp4&#x27;%video_id,&#x27;wb&#x27;) as f: for line in res_video_detail.iter_content(1024): f.write(line)# 单线程下载，速度不快，全是io操作，开启多线程能够显著提高速度---》使用多线程全站下载视频# 线程池整站爬取# 不能播放的地址# https://video.pearvideo.com/mp4/third/20220314/1652060493892-10097838-231626-hd.mp4# https://video.pearvideo.com/mp4/third/20220314/ cont-1754713 -10097838-231626-hd.mp4# mp4_url=&#x27;https://video.pearvideo.com/mp4/third/20220314/ 1652060493892 -10097838-231626-hd.mp4&#x27;# mp4_url=mp4_url.replace(mp4_url.split(&#x27;/&#x27;)[-1].split(&#x27;-&#x27;)[0],&#x27;cont-%s&#x27;%video_id) 2 requests+bs4爬取汽车之家123456789101112131415161718192021222324252627282930313233343536373839import requests# pip3 install beautifulsoup4from bs4 import BeautifulSoupres = requests.get(&#x27;https://www.autohome.com.cn/news/1/#liststart&#x27;)# print(res.text)# html.parser bs4默认的解析库soup = BeautifulSoup(res.text, &#x27;html.parser&#x27;)# 使用bs4的查找ul_list = soup.find_all(name=&#x27;ul&#x27;, class_=&#x27;article&#x27;)# print(len(ul_list))for ul in ul_list: # 找ul标签下所有的li标签 li_list = ul.find_all(name=&#x27;li&#x27;) for li in li_list: h3 = li.find(name=&#x27;h3&#x27;) if h3: title = h3.text # 获取h3标签的文本内容 desc = li.find(name=&#x27;p&#x27;).text img = li.find(name=&#x27;img&#x27;)[&#x27;src&#x27;] if not img.startswith(&#x27;http&#x27;): img=&#x27;https:&#x27;+img url = &#x27;https:&#x27; + li.find(&#x27;a&#x27;)[&#x27;href&#x27;] print(&#x27;&#x27;&#x27; 新闻标题：%s 新闻摘要：%s 新闻图片：%s 新闻地址：%s &#x27;&#x27;&#x27; % (title, desc, img, url)) # 把图片保存到本地 res_img=requests.get(img) img_name=img.split(&#x27;/&#x27;)[-1] with open(&#x27;./img/%s&#x27;%img_name,&#x27;wb&#x27;) as f: for line in res_img.iter_content(1024): f.write(line) # 把数据存到数据库 pymysql写入数据库--》建库建表--》cursor.exec(insert ..)--&gt;commit 3 bs4遍历文档树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from bs4 import BeautifulSouphtml_doc = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; id=&quot;id_p&quot;&gt;lqz&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;# html.parser 内置的，速度一般,容错能力强# lxml 第三方，速度快,容错能力强# soup=BeautifulSoup(html_doc,&#x27;html.parser&#x27;)# pip3 install lxmlsoup=BeautifulSoup(html_doc,&#x27;lxml&#x27;)# print(soup.prettify()) # 对html进行美化#1 遍历文档树之 . 遍历 速度快# print(soup.title)# print(soup.body.p)# print(soup.body.p.b)#2、获取标签的名称# print(soup.title.name)# print(soup.body.name)#3、获取标签的属性# print(soup.body.p)# print(soup.p[&#x27;class&#x27;]) # 因为class可能有多个，所以是列表# print(soup.p[&#x27;id&#x27;])# print(soup.p.attrs) # 所有属性放到字典中#4、获取标签的内容--文本内容# print(soup.p.text) # 当前标签和子子孙的文本内容拼到一起# print(soup.p.string) # 当前标签只有文本或只有一个子有文本才拿出来，如果有多个子子孙孙，返回None# print(list(soup.p.strings)) # 把子子孙孙的文本内容放到generator#5、嵌套选择# 可以连续点嵌套选择# print(soup.head.title.string)#6、子节点、子孙节点# print(soup.p.contents) #p下所有子节点，放到列表中# print(list(soup.p.children)) #得到一个迭代器,包含p下所有子节点,跟contents本质一样，只是节约内存# print(list(soup.p.descendants)) #获取子孙节点,p下所有的标签都会选择出来 子子孙孙# for i,child in enumerate(soup.p.children):# print(i,child)# for i,child in enumerate(soup.p.descendants):# print(i,child)#7、父节点、祖先节点# print(soup.a.parent) #获取a标签的父节点# print(list(soup.a.parents)) #找到a标签所有的祖先节点，父亲的父亲，父亲的父亲的父亲...#8、兄弟节点print(soup.a.next_sibling) #下一个兄弟print(soup.a.previous_sibling) #上一个兄弟print(list(soup.a.next_siblings)) #下面的兄弟们=&gt;生成器对象print(soup.a.previous_siblings) #上面的兄弟们=&gt;生成器对象# . 遍历 # 取属性 [] attrrs.get()# 取文本 text string strings 4 bs4搜索文档树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from bs4 import BeautifulSouphtml_doc = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; id=&quot;id_p&quot;&gt;lqz&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;soup = BeautifulSoup(html_doc, &#x27;lxml&#x27;)# 1、五种过滤器: 字符串、正则表达式、列表、True、方法# find：找到第一个 find_all：找所有# 字符串 ---&gt;value值是字符串# res=soup.find_all(name=&#x27;p&#x27;)# res=soup.find(id=&#x27;id_p&#x27;)# res=soup.find_all(class_=&#x27;story&#x27;)# res=soup.find_all(name=&#x27;p&#x27;,class_=&#x27;story&#x27;) # and条件# res=soup.find(name=&#x27;a&#x27;,id=&#x27;link2&#x27;).text# res=soup.find(name=&#x27;a&#x27;,id=&#x27;link2&#x27;).attrs.get(&#x27;href&#x27;)# res=soup.find(attrs=&#123;&#x27;id&#x27;:&#x27;link2&#x27;,&#x27;class&#x27;:&#x27;sister&#x27;&#125;).attrs.get(&#x27;href&#x27;)# print(res)# 正则表达式---&gt;value是正则表达式# import re## # res=soup.find_all(name=re.compile(&#x27;^b&#x27;))# # res=soup.find_all(href=re.compile(&#x27;^http&#x27;))# res=soup.find_all(class_=re.compile(&#x27;^s&#x27;))# print(res)# 列表 value值是列表# res=soup.find_all(name=[&#x27;body&#x27;,&#x27;a&#x27;])# res=soup.find_all(class_=[&#x27;sister&#x27;,&#x27;story&#x27;])# res=soup.find_all(id=[&#x27;link2&#x27;,&#x27;link3&#x27;])# print(res)# True value值是True# res=soup.find_all(name=True)# res=soup.find_all(id=True)# res=soup.find_all(href=True)# print(res)# 方法# def has_class_but_no_id(tag):# return tag.has_attr(&#x27;class&#x27;) and not tag.has_attr(&#x27;id&#x27;)## print(soup.find_all(name=has_class_but_no_id)) # 有class但是没有id的标签#1 html页面中，只要有的东西，通过bs4都可以解析出来#2 遍历文档树+搜索文档树混用# def has_class_but_no_id(tag):# return tag.has_attr(&#x27;class&#x27;) and not tag.has_attr(&#x27;id&#x27;)# print(soup.find(name=has_class_but_no_id).a.text)# 3 find_all的其他参数limit:限制取几条 recursive：是否递归查找# def has_class_but_no_id(tag):# return tag.has_attr(&#x27;class&#x27;) and not tag.has_attr(&#x27;id&#x27;)# res=soup.find_all(name=has_class_but_no_id,limit=1)## print(res)## res=soup.find_all(name=&#x27;a&#x27;,recursive=False) #不递归查找,速度快，只找一层# print(res) 5 css选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445### css，xpath选择器是通用的---》基本所有的解析库(bs4,lxml,pyquery,selenium的解析库)---&gt;都支持css选择器--&gt;css在前端通用from bs4 import BeautifulSouphtml_doc = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot; id=&quot;id_p&quot;&gt;lqz&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;soup = BeautifulSoup(html_doc, &#x27;lxml&#x27;)# soup.select() # 找所有# soup.select_one() # 找一个&#x27;&#x27;&#x27;div 找div标签div&gt;a 找div下的紧邻的adiv a 找div下的子子孙孙的a.sister 找类名为sister的标签#id_p 找id为id_p的标签&#x27;&#x27;&#x27;# res=soup.select(&#x27;#id_p&#x27;)# res=soup.select(&#x27;.sister&#x27;)# res=soup.select_one(&#x27;.story&gt;a&#x27;).attrs.get(&#x27;href&#x27;)# print(res)# 终极大招import requestsresponse=requests.get(&#x27;https://www.runoob.com/cssref/css-selectors.html&#x27;)soup=BeautifulSoup(response.text,&#x27;lxml&#x27;)res=soup.select_one(&#x27;#content &gt; table &gt; tbody &gt; tr:nth-child(2) &gt; td:nth-child(3)&#x27;).textprint(res)# 只要页面中有的通过bs4都能解析出来 12# 多线程爬取梨视频+代理池# 汽车之家存到mysql中","categories":[],"tags":[{"name":"10、爬虫","slug":"10、爬虫","permalink":"https://chenxiao0629.github.io/tags/10%E3%80%81%E7%88%AC%E8%99%AB/"}]},{"title":"01、爬虫介绍、requests模块：介绍、发送get请求、携带请求头、携带cookie、发送post请求模拟登录、响应对象、编码问题、获取二进制数据、解析json、ssl认证、搭建代理、超时设置、异常处理、上传文件","slug":"crawl_day01","date":"2020-01-13T06:04:01.000Z","updated":"2022-05-14T05:54:44.954Z","comments":true,"path":"2020/01/13/crawl_day01/","link":"","permalink":"https://chenxiao0629.github.io/2020/01/13/crawl_day01/","excerpt":"","text":"1 爬虫介绍1234567891011121314# 写后台---&gt;前端展示数据---》浏览器发送http请求，从后端服务器获取的--》只能从浏览器中看---》看到好看的东西---》保存到本地---》存到我们自己库中----》爬虫# 百度本质就是一个大爬虫(搜索)，在输入框中输入搜索内容，实际是从百度的数据库搜索出来的---》# 百度数据库的数据是从互联网爬下来的--》百度这个爬虫一刻不停的在互联网爬数据--》爬完就存到它的库里（seo优化--》优化我们的网站能够被搜索引擎先搜到，排的很靠前）---&gt;尽可能被百度爬虫，并且容易搜索到----&gt;seo(免费的)和sem(充钱，把你放前面)---》莆田系医院----&gt;百度快照---》当时爬虫爬取这个网页这一刻，网页的样子---》保留这个网页地址---》当你点击标题--》跳转到这个网页--》完成了你的搜索 伪静态# 爬虫的本质----》模拟发送http请求(浏览器携带什么，我们也要携带什么)----&gt;服务器返回数据---》对数据进行清洗---》入库 后续操作是别的---》分析数据--》数据分析# 爬虫协议：君子协议---》大家遵循这个协议，就不违法--》规定了我的网站，什么能爬，什么不能爬https://www.baidu.com/robots.txthttps://www.cnblogs.com/robots.txt# 爬虫本质跟用浏览器访问没什么区别 2 requests模块介绍，发送get请求1234567891011# 所有语言都可以做爬虫---》python简单一些---》库多# 模拟发送http请求的库，requests库----》大佬基于python内置库 urllib(麻烦) 封装--》requests# 安装pip3 install requests# 模拟发送get请求import requestsres=requests.get(&#x27;https://www.cnblogs.com/liuqingzheng/p/16005866.html&#x27;)print(res.text) # 响应体的内容打印出来了 3 get地址中携带参数123456789101112131415161718192021222324252627## 2 get 请求中携带参数# res=requests.get(&#x27;https://www.cnblogs.com/liuqingzheng/p/16005866.html&#x27;,# params=&#123;&#x27;name&#x27;:&#x27;lqz&#x27;,&#x27;age&#x27;:18&#125;# )# # ?name=lqz&amp;age=18拼到路径后面# print(res.text) # 响应体的内容打印出来了# url编码和解码# https://www.baidu.com/baidu?wd=python%20url%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81# 把字段中文编码后转成 name=%E5%88%98%E6%B8%85%E6%94%BF&amp;age=18# from urllib.parse import urlencode# d=&#123;&#x27;name&#x27;:&#x27;刘清政&#x27;,&#x27;age&#x27;:18&#125;# res=urlencode(d)# print(res)# 只想单独对中文编码和解码from urllib.parse import quote, unquote# 编码# name=&#x27;刘清政&#x27;# res=quote(name)# print(res)# 解码# s=&#x27;python%20url%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81&#x27;# print(unquote(s)) 4 携带请求头123456789101112131415# 3 携带请求头# 携带请求头--&gt;重要的key:# User-Agent:客户端浏览器的类型版本信息，操作系统版本---》django中如何取出请求头--》META---》中间件--》存到数据库--》饼形图--》统计你们网站近一个月客户端类型# referer:图片防盗链 Referer: https://www.lagou.com/wn/zhaopin# 记录的是上一个访问的地址---》反扒：如果上一个访问的地址不是自己的地址，认为不是正常请求就禁止# header = &#123;# &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36&#x27;,# # &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;,# &#125;# res = requests.get(&#x27;https://dig.chouti.com/&#x27;,headers=header)# with open(&#x27;chouti.html&#x27;,&#x27;wb&#x27;) as f:# f.write(res.content)# print(res.text) 5 携带cookie123456789101112## 本身cookie是请求头中的值，那么就可以执行放在请求头中，但是cookie经常用，也可以单独是一个参数# 模拟点赞header = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36&#x27;, # &#x27;Cookie&#x27;: &quot;&quot;&#125;data=&#123; &#x27;linkId&#x27;: &#x27;34934736&#x27;&#125;# res = requests.post(&#x27;https://dig.chouti.com/link/vote&#x27;,data=data,headers=header)res = requests.post(&#x27;https://dig.chouti.com/link/vote&#x27;,data=data,headers=header,cookies=&#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;)print(res.text) 6 发送post请求模拟登陆12345678910111213141516171819202122232425262728293031323334#5 模拟登陆某网站# data = &#123;# &#x27;username&#x27;: &#x27;616564099@qq.com&#x27;,# &#x27;password&#x27;: &#x27;lqz123&#x27;,# &#x27;captcha&#x27;: &#x27;kyca&#x27;,# &#x27;remember&#x27;: 1,# &#x27;ref&#x27;: &#x27;http://www.aa7a.cn/&#x27;,# &#x27;act&#x27;: &#x27;act_login&#x27;,# &#125;# res = requests.post(&#x27;http://www.aa7a.cn/user.php&#x27;,data=data)# print(res.text)# print(res.cookies) # 登陆成功返回的cookie，这个cookie是登陆过后的，以后拿着这个cookie就可以模拟登陆后操作## res2=requests.get(&#x27;http://www.aa7a.cn/&#x27;,cookies=res.cookies)# print(&#x27;616564099@qq.com&#x27; in res2.text)# 每次都要手动携带cookie，麻烦，使用requests提供的session 方法# session=requests.session()# # 以后需所有请求都用session对象发送，不需要手动处理cookie# data = &#123;# &#x27;username&#x27;: &#x27;ee@qq.com&#x27;,# &#x27;password&#x27;: &#x27;lqz123&#x27;,# &#x27;captcha&#x27;: &#x27;kyca&#x27;,# &#x27;remember&#x27;: 1,# &#x27;ref&#x27;: &#x27;http://www.aa7a.cn/&#x27;,# &#x27;act&#x27;: &#x27;act_login&#x27;,# &#125;# res = session.post(&#x27;http://www.aa7a.cn/user.php&#x27;,data=data)# print(res.text)# print(res.cookies) # 登陆成功返回的cookie，这个cookie是登陆过后的，以后拿着这个cookie就可以模拟登陆后操作# # res2=session.get(&#x27;http://www.aa7a.cn/&#x27;)# print(&#x27;616564099@qq.com&#x27; in res2.text) 7 响应对象123456789101112131415161718## 6 响应对象import requestsrespone=requests.get(&#x27;http://www.jianshu.com&#x27;)# respone属性print(respone.text) # 返回响应体的文本内容print(respone.content)# 返回响应体的二进制内容print(respone.status_code)# 响应状态码print(respone.headers)# 响应头print(respone.cookies)# 响应的cookieprint(respone.cookies.get_dict())# 响应的cookie转成字典print(respone.cookies.items())print(respone.url) # 请求地址print(respone.history) # 了解---》如果有重定向，列表，放着重定向之前的地址print(respone.encoding) # 页面的编码方式：utf-8 gbk# response.iter_content() # content迭代取出content二进制内容，一般用它存文件 8 编码问题(一般不会有问题)123# 请求回来的数据，res.text 打印的时候乱码 ，因为没有指定编码，默认已utf-8编码# 解决response.encoding=&#x27;gbk&#x27; 9 获取二进制数据1234567891011# 下载图片，视频# 下载图片header=&#123; &#x27;user-agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36&#x27;&#125;res=requests.get(&#x27;https://tva1.sinaimg.cn/mw2000/9d52c073gy1h1v6lmny8nj20j60pjtdh.jpg&#x27;,headers=header)with open(&#x27;mv.jpg&#x27;,&#x27;wb&#x27;) as f: # f.write(res.content) for line in res.iter_content(100): f.write(line) 10 解析json12345678910111213141516## 8 json格式解析import jsondata = &#123; &#x27;cname&#x27;: &#x27;&#x27;, &#x27;pid&#x27;: &#x27;&#x27;, &#x27;keyword&#x27;: &#x27;上海&#x27;, &#x27;pageIndex&#x27;: 1, &#x27;pageSize&#x27;: 10,&#125;# res = requests.post(&#x27;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword&#x27;,data=data)# j = json.loads(res.text)# print(j[&#x27;Table&#x27;][0][&#x27;rowcount&#x27;])res= requests.post(&#x27;http://www.kfc.com.cn/kfccda/ashx/GetStoreList.ashx?op=keyword&#x27;,data=data).json()print(res[&#x27;Table&#x27;][0][&#x27;rowcount&#x27;]) 11 ssl认证1234567891011# 之前网站，有些没有认证过的ssl证书，我们访问需要手动携带证书# 跳过证书直接访问import requestsrespone=requests.get(&#x27;https://www.12306.cn&#x27;,verify=False) #不验证证书,报警告,返回200print(respone.status_code)# 手动携带import requestsrespone=requests.get(&#x27;https://www.12306.cn&#x27;, cert=(&#x27;/path/server.crt&#x27;, &#x27;/path/key&#x27;))print(respone.status_code) 12 使用代理123456# 爬虫，速度很快，超过频率限制---》使用代理，切换ip---》封ip封的也是代理的ip，我的ip没问题# 作业：网上有一个python开源的代理池---》自己搭建起来https://github.com/jhao104/proxy_pool# 作业：写个django，用户访问就返回用户的ip地址--》放到公网上，用manage.py跑起来---》访问# 客户端使用request加代理访问你的django，验证代理是否使用成功 123456proxies = &#123; &#x27;http&#x27;: &#x27;39.103.217.44:59886&#x27;, # http或https代理&#125;respone=requests.get(&#x27;https://www.baidu.com&#x27;,proxies=proxies)print(respone.status_code) 1234# 作业：网上有一个python开源的代理池---》自己搭建起来https://github.com/jhao104/proxy_pool# 作业：写个django，用户访问就返回用户的ip地址--》放到公网上，用manage.py跑起来---》访问# 客户端使用request加代理访问你的django，验证代理是否使用成功 13 搭建代理池123456789101112131415161718192021222324252627282930313233343536# https://github.com/jhao104/proxy_pool -python的爬虫+flask写的 -本质使用爬虫技术爬取免费的代理，验证--》requests模块验证---》存到redis中 -起一个web服务器，只要访问一个地址，他就随机给你一个ip地址 # 步骤： 第一步:git clone git@github.com:jhao104/proxy_pool.git 第二步：安装依赖：pip install -r requirements.txt 第三步： 修改代码，修改配置 # setting.py 为项目配置文件 # 配置API服务 HOST = &quot;0.0.0.0&quot; # IP PORT = 5000 # 监听端口 # 配置数据库 DB_CONN = &#x27;redis://:pwd@127.0.0.1:8888/0&#x27; # 配置 ProxyFetcher PROXY_FETCHER = [ &quot;freeProxy01&quot;, # 这里是启用的代理抓取方法名，所有fetch方法位于fetcher/proxyFetcher.py &quot;freeProxy02&quot;, # .... ] 第四步：启动爬虫 python3 proxyPool.py schedule 第五步：启动服务 # 启动webApi服务 python proxyPool.py server 1234567891011# # 代理测试import requests# http://127.0.0.1:5010/get/ip=&quot;http://&quot;+requests.get(&#x27;http://139.155.237.73:5010/get/&#x27;).json()[&#x27;proxy&#x27;]print(ip)proxies = &#123; &#x27;http&#x27;: ip,&#125;res=requests.get(&#x27;http://47.104.165.24:8001/check/&#x27;,proxies=proxies)print(res.text) 14 requests超时设置123456789import requests# http://127.0.0.1:5010/get/ip=&quot;http://&quot;+requests.get(&#x27;http://139.155.237.73:5010/get/&#x27;).json()[&#x27;proxy&#x27;]print(ip)proxies = &#123; &#x27;http&#x27;: ip,&#125;res=requests.get(&#x27;http://47.104.165.24:8001/check/&#x27;,proxies=proxies,timeout=1)print(res.text) 15 requests认证设置1234567891011# 这种很少见，极个别公司内部可能还用这种import requestsfrom requests.auth import HTTPBasicAuthr=requests.get(&#x27;xxx&#x27;,auth=HTTPBasicAuth(&#x27;user&#x27;,&#x27;password&#x27;))print(r.status_code)#HTTPBasicAuth可以简写为如下格式import requestsr=requests.get(&#x27;xxx&#x27;,auth=(&#x27;user&#x27;,&#x27;password&#x27;))print(r.status_code) 16 requests异常处理12345678910111213from requests.exceptions import * #可以查看requests.exceptions获取异常类型try: r=requests.get(&#x27;http://www.baidu.com&#x27;,timeout=0.00001)except ReadTimeout: print(&#x27;===:&#x27;)# except ConnectionError: #网络不通# print(&#x27;-----&#x27;)# except Timeout:# print(&#x27;aaaaa&#x27;)except Exception: print(&#x27;Error&#x27;) 17 requests上传文件12345678910111213# 上传文件--》爬虫一般不会用，但是咱们服务会用import requestsfiles=&#123;&#x27;file&#x27;:open(&#x27;a.jpg&#x27;,&#x27;rb&#x27;)&#125;respone=requests.post(&#x27;http://httpbin.org/post&#x27;,files=files)print(respone.status_code)# 咱们django项目 -你们公司项目，使用了第三方服务，第三放服务提供了api接口，没提供sdk -就要使用request发送请求，获取数据 # 前端提交一个长链地址 www.cnblogs.com/liuqingzheng/p/233.html---&gt;转成短链--》x.com/asdf---&gt;存到自己数据库中# 专门服务，处理长连转短链(go,java)---》接口--》post，带着地址---》返回json，短链地址","categories":[],"tags":[{"name":"10、爬虫","slug":"10、爬虫","permalink":"https://chenxiao0629.github.io/tags/10%E3%80%81%E7%88%AC%E8%99%AB/"}]},{"title":"09、自定义User表、签发token、自定义认证类、simpleui的使用、多方式登录接口介绍","slug":"drf_day09","date":"2018-10-20T06:04:09.000Z","updated":"2022-05-14T04:46:23.267Z","comments":true,"path":"2018/10/20/drf_day09/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day09/","excerpt":"","text":"复习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 自动生成接口文档 -coreapi生成---》swgger生成，其他语言用它多一些 -https://www.cnblogs.com/noteaddr/p/12971759.html# 写接口文档 -纯手写：md，word写文档---》生成pdf传到git上 -第三方平台(收费，数据在第三方平台)---》半手动录入 -公司自己开发的，自己搭建yapi----》半手动录入(swgger,postman---&gt;json---&gt;导入到接口平台) -自动生成接口文档----》地址给前端 # rbac -基于角色的访问控制 -6张表控制---》django admin默认---》django 的auth app生成的 -用户表 -角色(组，部门) -权限 -用户和角色多对多 -角色和权限多对多 -用户和权限多对多 -python适合写公司内部项目---》开发效率高，并发要求不高 -基本都会有权限管理---&gt;rbac -django的admin混合开发(美化admin) -django，drf，vue前端端分离：设计权限---》django-vue-admin -前后端分离，如何判断该用户的当次请求有没有权限 -权限类---》判断---》请求get，post，请求地址/books id type addr id permission_id group_id 1 get /book/ 1 1 1 :开发组 2 post /book/ 2 2 1 ：开发组 认证过后，request.user当前登录用户---》用户属于的组---》用户所有权限---》判断有没有权限--》如果有return True，如果没有，return False 权限表需要手动录入 菜单管理：增加权限 # python：django ：大而全---》django，flask，sanic，fastapi# java:springboot：大而全---》一统java天下---》java工程师又叫spring工程师# go:beego：大而全---》gin# jwt---&gt;重点 -Json web token：一种前后端交互的认证方式，区别于cookie和session的认证 -分三段：头 荷载 签名，每一段用. 分隔，使用base64编码 -签名是通过一种加密方式(md5,sh256..)把头和荷载加密后得到的 -登陆的时候，可以签发token -如何签发：头是固定的，荷载通过当前用户生成(用户id，用户名，过期时间..),通过加密方式生成第三端，每一段用base64编码，通过.组合起来 -访问某个接口时，如果需要登陆后方法，需要携带token(一般放在请求头中)，认证token -认证token：是否过期，是否被篡改 -如何认证？ 把三段分开，前两段再通过同样的加密方式得到第三段，比较新生成的第三段和传入的第三段是否一样，如果一样，荷载部分内容，就可以信任 # djangorestframework-jwt simplejwt：只需要写一个认证类即可 -快速签发 -默认使用auth的user表(auth的user表可以扩写--&gt;以后可以基于auth的user表作为项目用户表) -obtain_jwt_token:获取token -refresh_jwt_token：更新token，更新了荷载中的时间---》签名会变吗？ -如果要使用它，配置文件要改：&#x27;JWT_ALLOW_REFRESH&#x27;:True -verify_jwt_token：认证token -修改签发格式---》写一个函数，返回什么，格式就是什么 -快速认证 -写一个认证类，写一个权限类 -认证类源码中： -如果不携带token，它就不验证了， 直接过(retrun none),不过(抛异常) -真的要限制，只要不带，也不通过，带了就验证，加了一个权限类,加了这个权限类，可以控制没有携带token的用户，不让继续往后走 1 自定义User表，签发token12# 如果项目中的User表使用auth的user表，使用快速签发token即可# 如果自定义User表，签发token，需要手动签发---》自己写 1.1 普通写法1234567891011121314151617181920212223242526272829303132333435from rest_framework.views import APIView# class UserView(APIView):# 自动生成路由,from rest_framework.viewsets import ViewSetMixinfrom rest_framework.decorators import actionfrom rest_framework.generics import GenericAPIViewfrom .models import UserInfofrom .serializer import UserInfoSerializerfrom rest_framework.response import Responsefrom rest_framework_jwt.settings import api_settingsjwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLERjwt_encode_handler = api_settings.JWT_ENCODE_HANDLER# /user/login/---&gt;post请求# class UserView(ViewSetMixin, APIView):# @action(methods=[&#x27;POST&#x27;], detail=False)# def login(self, request):# res_dic = &#123;&#x27;code&#x27;: 100, &#x27;msg&#x27;: &#x27;成功&#x27;&#125;# username = request.data.get(&#x27;username&#x27;)# password = request.data.get(&#x27;password&#x27;)# user = UserInfo.objects.filter(username=username, password=password).first()# if user: # 登陆成功# # 签发token？如何签发？--》去jwt源码中扣# payload = jwt_payload_handler(user) # 得到荷载--》字典# print(payload)# token = jwt_encode_handler(payload) # 通过荷载得到token串# res_dic[&#x27;token&#x27;] = token# res_dic[&#x27;username&#x27;] = user.username# return Response(res_dic)# else:# res_dic[&#x27;code&#x27;] = 101# res_dic[&#x27;msg&#x27;] = &#x27;用户名或密码错误&#x27;# return Response(res_dic) 1.2 逻辑写在序列化类中123456789101112131415161718# 换种写法，写上面的登录，所有校验规则，写在序列化类中---》这种用的多class UserView(ViewSetMixin, APIView): @action(methods=[&#x27;POST&#x27;], detail=False) def login(self, request): res_dic = &#123;&#x27;code&#x27;: 100, &#x27;msg&#x27;: &#x27;成功&#x27;&#125; ser = UserInfoSerializer(data=request.data,context=&#123;&#x27;request&#x27;:request&#125;) if ser.is_valid(): # 这句话会走：字段自己的校验规则，局部钩子，全局钩子 token = ser.context.get(&#x27;token&#x27;) username = ser.context.get(&#x27;username&#x27;) # token = ser.token # username = ser.username res_dic[&#x27;token&#x27;] = token res_dic[&#x27;username&#x27;] = username else: res_dic[&#x27;code&#x27;] = 101 res_dic[&#x27;msg&#x27;] = ser.errors return Response(res_dic) 1234567891011121314151617181920212223class UserInfoSerializer(serializers.ModelSerializer): class Meta: model = UserInfo fields = [&#x27;username&#x27;, &#x27;password&#x27;] # 根据表模型中写的，字段自己有校验规则 def validate(self, attrs): # 打印请求方式？ print(self.context.get(&#x27;request&#x27;).method) # 签发token逻辑，签发生成token，放到ser.context字典中 username = attrs.get(&#x27;username&#x27;) password = attrs.get(&#x27;password&#x27;) user = UserInfo.objects.filter(username=username, password=password).first() if user: # 登陆成功 payload = jwt_payload_handler(user) # 得到荷载--》字典 token = jwt_encode_handler(payload) # 通过荷载得到token串 # serializer和视图类沟通的桥梁 self.context[&#x27;token&#x27;] = token self.context[&#x27;username&#x27;] = user.username # self.token=token # self.username=username else: raise ValidationError(&#x27;用户名或密码错误&#x27;) return attrs 2 自定义认证类123456789101112131415161718192021222324252627282930313233from rest_framework.authentication import BaseAuthenticationfrom rest_framework_jwt.settings import api_settingsfrom rest_framework.exceptions import AuthenticationFailedimport jwt# from django.utils.translation import ugettext as _from .models import UserInfojwt_decode_handler = api_settings.JWT_DECODE_HANDLERclass JWTAuthentication(BaseAuthentication): def authenticate(self, request): # 第一步:取出传入的token--》从哪去？--》咱们定的：请求地址？请求头？ # token=request.query_params.get(&#x27;token&#x27;)# 请求地址？ # http请求头中的数据，在META中,统一变成 HTTP_请求头的key大写 jwt_value=request.META.get(&#x27;HTTP_TOKEN&#x27;) if jwt_value: # 验证token：是否过期，是否被篡改--》去源码扣 try: payload = jwt_decode_handler(jwt_value) except jwt.ExpiredSignature: msg = &#x27;签名过期&#x27; raise AuthenticationFailed(msg) except jwt.DecodeError: msg = &#x27;签名被篡改&#x27; raise AuthenticationFailed(msg) except jwt.InvalidTokenError: raise AuthenticationFailed(&#x27;未知错误&#x27;) # 通过payload获得当前登录用户 user = UserInfo.objects.filter(pk=payload[&#x27;user_id&#x27;]).first() return (user, jwt_value) else: raise AuthenticationFailed(&#x27;您没有携带token&#x27;) 3 simpleui的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# django-admin混合开发--》后台管理---》美化--》simpleui# 使用步骤： -安装：pip3 install django-simpleui -注册app INSTALLED_APPS = [ &#x27;simpleui&#x27;, ] -定制左侧菜单 SIMPLEUI_CONFIG = &#123; &#x27;system_keep&#x27;: False, &#x27;menu_display&#x27;: [&#x27;监控大屏&#x27;,&#x27;应用1&#x27;, &#x27;权限认证&#x27;, &#x27;测试&#x27;, &#x27;动态菜单测试&#x27;], # 开启排序和过滤功能, 不填此字段为默认排序和全部显示, 空列表[] 为全部不显示. &#x27;dynamic&#x27;: True, # 设置是否开启动态菜单, 默认为False. 如果开启, 则会在每次用户登陆时动态展示菜单内容 &#x27;menus&#x27;: [ &#123; &#x27;name&#x27;: &#x27;监控大屏&#x27;, &#x27;icon&#x27;: &#x27;fas fa-code&#x27;, &#x27;url&#x27;: &#x27;/index/&#x27; &#125;, &#123; &#x27;app&#x27;: &#x27;app01&#x27;, &#x27;name&#x27;: &#x27;应用1&#x27;, &#x27;icon&#x27;: &#x27;fas fa-user-shield&#x27;, &#x27;models&#x27;: [ &#123; &#x27;name&#x27;: &#x27;图书&#x27;, &#x27;icon&#x27;: &#x27;fa fa-user&#x27;, &#x27;url&#x27;: &#x27;app01/book/&#x27; &#125;, &#123; &#x27;name&#x27;: &#x27;用户&#x27;, &#x27;icon&#x27;: &#x27;fa fa-user&#x27;, &#x27;url&#x27;: &#x27;app01/userinfo/&#x27; &#125; ] &#125;, &#123; &#x27;app&#x27;: &#x27;auth&#x27;, &#x27;name&#x27;: &#x27;权限认证&#x27;, &#x27;icon&#x27;: &#x27;fas fa-user-shield&#x27;, &#x27;models&#x27;: [ &#123; &#x27;name&#x27;: &#x27;用户&#x27;, &#x27;icon&#x27;: &#x27;fa fa-user&#x27;, &#x27;url&#x27;: &#x27;auth/user/&#x27; &#125;, &#123; &#x27;name&#x27;: &#x27;用户组&#x27;, &#x27;icon&#x27;: &#x27;fa fa-user&#x27;, &#x27;url&#x27;: &#x27;auth/group/&#x27; &#125; ] &#125;, &#123; # 自2021.02.01+ 支持多级菜单，models 为子菜单名 &#x27;name&#x27;: &#x27;测试&#x27;, &#x27;icon&#x27;: &#x27;fa fa-file&#x27;, # 二级菜单 &#x27;models&#x27;: [&#123; &#x27;name&#x27;: &#x27;Baidu&#x27;, &#x27;icon&#x27;: &#x27;far fa-surprise&#x27;, # 第三级菜单 ， &#x27;models&#x27;: [ &#123; &#x27;name&#x27;: &#x27;爱奇艺&#x27;, &#x27;url&#x27;: &#x27;https://www.iqiyi.com/dianshiju/&#x27; # 第四级就不支持了，element只支持了3级 &#125;, &#123; &#x27;name&#x27;: &#x27;百度问答&#x27;, &#x27;icon&#x27;: &#x27;far fa-surprise&#x27;, &#x27;url&#x27;: &#x27;https://zhidao.baidu.com/&#x27; &#125; ] &#125;, &#123; &#x27;name&#x27;: &#x27;内网穿透&#x27;, &#x27;url&#x27;: &#x27;https://www.wezoz.com&#x27;, &#x27;icon&#x27;: &#x27;fab fa-github&#x27; &#125;] &#125;, &#123; &#x27;name&#x27;: &#x27;动态菜单测试&#x27;, &#x27;icon&#x27;: &#x27;fa fa-desktop&#x27;, &#x27;models&#x27;: [&#123; &#x27;name&#x27;: time.time(), &#x27;url&#x27;: &#x27;http://baidu.com&#x27;, &#x27;icon&#x27;: &#x27;far fa-surprise&#x27; &#125;] &#125; ]&#125; -自带权限 -自定义左侧菜单的页面显示 -通过混合开发，编写路径，配置到上面即可 -更多操作见官方 4 多方式登陆接口（后面也写）12# 用户名+密码 手机号+密码 邮箱+密码---》都能登陆成功# post---&gt;&#123;&quot;username&quot;:用户名/手机号/邮箱，&quot;password&quot;:lqz12345&#125;--&gt;在后端用正则判断 1# 1 使用两种方式写多方式登陆接口（）","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"08、RBAC、自动生成接口文档、jwt（介绍、快速使用、定制返回格式、源码分析）","slug":"drf_day08","date":"2018-10-20T06:04:08.000Z","updated":"2022-05-14T04:44:06.070Z","comments":true,"path":"2018/10/20/drf_day08/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day08/","excerpt":"","text":"复习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 过滤---》获取所有接口---》继承ListModelMixin+GenericAPIView -在继承ListModelMixin内的list方法中过滤的---》调用了self.filter_queryset---&gt;GenericAPIView的方法 ### 如果继承APIView，自己写的get获取所有，过滤如何写？ -方式一： -内置的SearchFilter -视图类配置： filter_backends = [SearchFilter,] # 需要配合一个类属性,可以按name过滤 search_fields=[&#x27;name&#x27;,&#x27;author&#x27;] -查询：?search=红 # name中或者作者中带红 -方式二：第三方 -django-filter：DjangoFilterBackend -视图类配置： filter_backends = [DjangoFilterBackend,] filter_fields=[&#x27;name&#x27;,&#x27;author&#x27;] -查询：?name=红 # 精准匹配 -方式三：自定义 -写一个类，继承BaseFilterBackend，重写filter_queryset，在filter_queryset中完成过滤，返回qs对象 -配置在视图类中即可 filter_backends = [BookNameFilter,] # 可以配置多个过滤类 # 排序---》获取所有接口---》继承ListModelMixin+GenericAPIView -使用内置的即可---》OrderingFilter -配置在视图类中 filter_backends = [OrderingFilter] ordering_fields=[&#x27;price&#x27;,&#x27;id&#x27;] -查询：?ordering=price,-id&amp;search=红 # 分页---》获取所有接口---》继承ListModelMixin+GenericAPIView -三种分页方式：PageNumberPagination, LimitOffsetPagination, CursorPagination -写一个类，继承某个drf内置的分页类，重写类属性 -把分页类，配置在视图类中即可，一个视图类只能选择一种分页方式 -pagination_class = CommonCursorPagination -PC网页端的分页，app的下拉加载更多也是分页 # 全局异常---》APIView中，三大认证，视图类中出了异常，都会被捕获处理，处理后会执行一个函数，默认是配置文件中配置了：&#x27;EXCEPTION_HANDLER&#x27;: &#x27;rest_framework.views.exception_handler&#x27;# 咱们自己写一个函数，接收参数跟exception_handler一行，配置在项目的配置文件，以后出了异常，就会走咱们自己的def common_exception_handler(exc, context): res = exception_handler(exc, context) # 只处理了drf的异常：APIException及子类的对象， if res: # 是drf的异常，response对象的data中有个detail res = Response(data=&#123;&#x27;code&#x27;: 998, &#x27;msg&#x27;: res.data.get(&#x27;detail&#x27;, &#x27;服务器异常，请联系系统管理员&#x27;)&#125;) else: # django的异常 res = Response(data=&#123;&#x27;code&#x27;: 999, &#x27;msg&#x27;: str(exc)&#125;) request = context.get(&#x27;request&#x27;) view = context.get(&#x27;view&#x27;) print(&#x27;错误原因：%s,错误视图类：%s,请求地址：%s,请求方式：%s&#x27; % (str(exc), str(view), request.path, request.method)) return res 1 RBAC(重要)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# python用来做公司内部项目居多，人事系统，进销存，报销审批，自动化运维 -公司内部项目对执行效率要求不高（人少） -对开发效率要求高（越快开发出越好，成本越低越好） -知乎，豆瓣用python写的---》随着用户量增大---》切换语言# 对外的权限比较简单：普通注册用户，VIP用户，超级VIP --》优酷，网易云音乐，百度网盘# 公司内部系统：通常使用RBAC的权限控制 -公司内有部门（开发部，运维部，市场部，总裁办，人力资源部门） -权限和角色(部门)绑定 -举个例子：发工资权限，招人权限，开发代码权限---》招人权限，发工资权限给人力资源--》开发代码权限给开发部门# RBAC 是基于角色的访问控制（Role-Based Access Control ）在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。这样管理都是层级相互依赖的，权限赋予给角色，而把角色又赋予用户，这样的权限设计很清楚，管理起来很方便。# 权限赋予给角色(部门)，而把角色(部门)又赋予用户# 针对于公司内部项目，后台管理居多(运营在使用),使用rbac居多# django-vue-admin：后端用drf，前端用vue，权限管理的 脚手架---》前后端分离# django的admin---》混合的后台管理用的多---》基于django的admin二次开发# simpleui：对django admin的美化# django的admin自带rbac权限管理（表设计完成权限管理）---》6张表 -用户表 -角色表(组表，部门表) -权限表 ---------- -角色和权限多对多中间表 -用户和角色多对多中间表 -----django-admin中多了一张表----- 用户对权限多对多中间表 ### 基于django的admin做二次开发，开发出公司内部的管理系统 -纯基于原生 -使用第三方美化：xadmin(早就不维护了，弃坑了)，simpleui(国内的，主流)，国外也有很多 # 在关系型数据库的关系中：只有三种---》本质只有一种：外键关系 -一对多 -多对多 -一对一 # 前后端分离，验证码如何实现？写验证码接口 2 自动生成接口文档1234567891011121314151617181920212223242526272829303132333435363738394041424344# 顺利的写接口----》在公司里，前端和后端是两拨人写---》咱们后端接口写好了，我们知道接口怎么用127.0.0.1:8080/user/login---&gt;post---&gt;&#123;&quot;username&quot;:&#x27;lqz&#x27;,&#x27;pwd&#x27;:123&#125;---&gt;&#123;status:100,msg:登陆成功，token:dafasdf&#125; # 后端人，需要写出接口文档，给前端用，前端按照接口文档去开发# 具体格式可以参照：https://open.weibo.com/wiki/2/comments/show # 如何写？ -第一种：使用word或者md文档编写---》纯手写---》好的公司这么用 -第二种：第三方平台录入---》半手写--&gt;https://blog.csdn.net/weixin_44337261/article/details/121005675--&gt;部分公司 -第三种：公司自己开发接口平台，搭建接口平台--》数据放在公司自己--》学长公司在用 -https://zhuanlan.zhihu.com/p/366025001 -第四种：自动生成接口文档---》用的少---》自动生成+导出---》录入到yapi -coreapi，swagger # coreapi 使用步骤 -pip3 install coreapi -路由中写 from rest_framework.documentation import include_docs_urls urlpatterns = [ ... path(&#x27;docs/&#x27;, include_docs_urls(title=&#x27;站点页面标题&#x27;)) ] -写视图类，只需要加注释即可 -在配置文件中： REST_FRAMEWORK = &#123; &#x27;DEFAULT_SCHEMA_CLASS&#x27;: &#x27;rest_framework.schemas.coreapi.AutoSchema&#x27;, # 新版drf schema_class默认用的是rest_framework.schemas.openapi.AutoSchema&#125; -访问地址:http://127.0.0.1:8000/docs/ -给前端，前端按照这个接口文档开发 -基于这个，录入到第三方接口平台，自己写word文档 # 如何写好接口文档 http://www.liuqingzheng.top/article/1/02-%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/ 3 jwt介绍和快速使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# cookie，session，token的区别？https://www.cnblogs.com/liuqingzheng/articles/8990027.html# 认证：session机制:需要在后端存储数据---》之前使用的django-session# 如果登录用户很多，需要在后端存很多数据，频繁查询数据库，导致效率低---》能不能想一种方案，不在服务端存数据---》客户端存数据(数据安全)---》token认证机制# Json web token (JWT)，token是一种认证机制，用在web开发方向，叫jwt# JWT的构成---》三段式---》每一段都使用base64编码 -典型的jwt串样子，通过. 分隔成三段： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ -第一段：头：声明类型，这里是jwt，声明加密的算法，公司信息等等。。。 ---》 目前作用不大 -第二段：荷载(payload):有效信息 -用户名，用户id，登陆时间，token失效时间。。。。 -第三段：签名(signature):通过 头+荷载 使用某种加密方式加密后得到的 # base64编码和解码---》只是编码和解码，不能叫加密import base64# 编码# s = b&#x27;&#x27;&#x27;&#123;&quot;name&quot;:&quot;lqz&quot;,&quot;age&quot;:19&#125;&#x27;&#x27;&#x27;# res = base64.b64encode(s)# print(res) # eyJuYW1lIjoibHF6IiwiYWdlIjoxOX0=# 解码# s=b&#x27;eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9&#x27;# res=base64.b64decode(s)# print(res)## jwt的签发和认证---》保证安全# 签发---》登陆过程---》如果没有第三方模块帮助我们做，我们就自己做&quot;&quot;&quot;1）用基本信息公司信息存储json字典，采用base64算法得到 头字符串2）用关键信息存储json字典，采用base64算法得到 荷载字符串，过期时间，用户id，用户名3）用头、体加密字符串通过加密算法+秘钥加密得到 签名字符串拼接成token返回给前台&quot;&quot;&quot;# 认证---》访问需要登陆的接口&quot;&quot;&quot;1）将token按 . 拆分为三段字符串，第一段 头加密字符串 一般不需要做任何处理2）第二段 体加密字符串，要反解出用户主键，通过主键从User表中就能得到登录用户，过期时间是安全信息，确保token没过期3）再用 第一段 + 第二段 + 加密方式和秘钥得到一个加密串，与第三段 签名字符串 进行比较，通过后才能代表第二段校验得到的user对象就是合法的登录用户&quot;&quot;&quot;# 大部分的web框架都会有第三方模块支持----》如果没有需要自己写django中有一个django-rest-framework-jwt，咱们讲的：# https://github.com/jpadilla/django-rest-framework-jwtdjango中有一个，django-rest-framework-simplejwt，咱们不讲，公司可能会用：# https://github.com/jazzband/djangorestframework-simplejwt# 区别# https://blog.csdn.net/lady_killer9/article/details/103075076 3.1 django中快速使用jwt3.1.1 签发12345678910111213141516# 第一步：pip3 install djangorestframework-jwt# 第二步：在路由中配置from rest_framework_jwt.views import obtain_jwt_tokenurlpatterns = [ path(&#x27;login/&#x27;, obtain_jwt_token),]# 第三步：使用接口测试工具发送post请求到后端，就能基于auth的user表签发token&#123; &quot;token&quot;: &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6InB5eSIsImV4cCI6MTY0OTMxNjc3MiwiZW1haWwiOiIzMDYzMzQ2NzhAcXEuY29tIn0.YOUc9gcFIQf9FBibZJANaI3Rmpw4zfMy1e8ez1roKSI&quot;&#125;# 比session优势在不需要在后端存数据了，jwt不会在后端存数据，保证了数据安全### 会有被别人窃取的风险----》只能拿到和使用---》避免不了窃取后使用，只能避免别人篡改不了---》爬虫就是干这事，扣除token串，模拟发请求----》如果你能想一种方式，避免别人获取了token串，不能发请求---》你整个就把爬虫行业干掉了 3.1.2 认证12345678910111213141516171819# 视图类的某个方法，访问时候，需要认证通过才能访问---》写认证类--&gt;我们用了第三方模块---》第三方模块写了一个认证类# 在视图类中配置：认证类+权限类from rest_framework_jwt.authentication import JSONWebTokenAuthenticationfrom rest_framework.permissions import IsAuthenticatedclass BookView(GenericViewSet,ListModelMixin): # JSONWebTokenAuthentication :rest_framework_jwt模块写的认证类 authentication_classes = [JSONWebTokenAuthentication,] # 需要配合一个权限类 permission_classes = [IsAuthenticated,] ### 在前端使用的时候，要携带token，token携带方式：---》为什么要按这个格式？人家的认证类已经写完了，就是去请求头中取的，按固定规则取的，所以咱们需要按照这个格式## 后期咱么要自己基于自定义的User表，签发token，和自定义认证类在请求头中使用 Authorization : jwt token串 4 jwt定制返回格式1234567891011121314151617# 签发token，其实就是jwt模块基于auth的user表，帮咱们写了一个登陆功能，但是一般请求，我们登陆成功后，返回的数据更多 &#123;code:100,msg:登陆成功，token:adfadf,username:pyy&#125;# 定义签发token(登陆接口)返回格式 -第一步：写一个函数---&gt;返回什么格式，前端就能看到什么格式 def jwt_response_payload_handler(token, user=None, request=None): return &#123; &#x27;code&#x27;: 100, &#x27;msg&#x27;: &quot;登陆成功&quot;, &#x27;token&#x27;: token, &#x27;username&#x27;: user.username &#125; -第二步：在配置文件中配置 # jwt模块的配置文件，统一放在JWT_AUTH JWT_AUTH = &#123; &#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;: &#x27;app01.utils.jwt_response_payload_handler&#x27;, &#125; 5 jwt源码分析(听不懂就算了，不影响使用)123456789101112131415161718192021222324252627282930# 签发源码obtain_jwt_token---》ObtainJSONWebToken.as_view()：视图类.as_view()---&gt;ObtainJSONWebToken视图类---》登陆post请求，携带用户名密码---》视图类中有post方法# 视图类中的序列化类： serializer_class = JSONWebTokenSerializer---》全局钩子中获取当前登录用户和签发token# post方法中：serializer = self.get_serializer(data=request.data)### 你会的：obtain_jwt_token---》ObtainJSONWebToken视图类---》post方法--》通过前端传入的用户名和密码拿到了当前用户，通过当前用户签发了token---》返回给了前端# 认证源码 -认证类---》authenticate方法---》验证 def authenticate(self, request): jwt_value = self.get_jwt_value(request) # 获取真正的token，三段式 if jwt_value is None: # 如果没传token，就不认证了，直接通过，所以需要配合权限类一起用 return None try: payload = jwt_decode_handler(jwt_value)# 验证签名 except jwt.ExpiredSignature: msg = _(&#x27;Signature has expired.&#x27;) # 过期了 raise exceptions.AuthenticationFailed(msg) except jwt.DecodeError: msg = _(&#x27;Error decoding signature.&#x27;)# 被篡改了 raise exceptions.AuthenticationFailed(msg) except jwt.InvalidTokenError: raise exceptions.AuthenticationFailed()# 不知名的错误 user = self.authenticate_credentials(payload) return (user, jwt_value) 1234567891 使用django admin--&gt;测试一下权限的使用，创建用户，分配组，给组分配权限，再给用户分配权限，以用户登录，看看有没有权限2 定制固定格式，签发和认证token---》最好看一下源码-----部分人做----3 看博客cookie,session,token：https://www.cnblogs.com/liuqingzheng/articles/8990027.html 4 自己搭建一个yapi:https://zhuanlan.zhihu.com/p/366025001","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"07、过滤、排序、分页、异常处理","slug":"drf_day07","date":"2018-10-20T06:04:07.000Z","updated":"2022-05-14T04:43:09.726Z","comments":true,"path":"2018/10/20/drf_day07/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day07/","excerpt":"","text":"复习123456789101112131415161718192021222324252627282930# 继承一个父类，父类中有方法，在子类中重写方法# 鸭子类型：不需要显示继承一个类，只要多个类中有同样的属性或方法，我们把它们称之为一种类，python，go# 非鸭子类类型语言：如果要属于同一类，必须显示的继承某个基类，这样才属于基类这个类型，java# python语言建议使用鸭子类型（约定），但在实际开发中，我们经常不使用鸭子类型这种特性，出错概率低# 实际编码：要么认为约定必须有哪些方法(符合鸭子类型)，可控性低；要么强制约定有哪些方法(abc模块，使用抛异常)# java中：重写：重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变# java中：重载：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同# 认证 -写一个类，继承BaseAuthentication，重写authenticate，在方法中校验，如果登录了，返回两个值，如果没登陆，抛出异常 -全局使用 -局部使用 -局部禁用# 权限 -写一个类，继承BasePermission，重写has_permission方法，在方法中判断，如果有权限，返回True，如果没有权限，返回false -全局使用 -局部使用 -局部禁用# 频率 -写一个类，继承SimpleRateThrottle，重写get_cache_key，返回什么就以什么做频率限制，重写类属性scope = &#x27;minute_3&#x27;，在配置文件中配置：&#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123;&#x27;minute_3&#x27;: &#x27;3/m&#x27;&#125; -全局使用 -局部使用 -局部禁用 1 过滤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263queryset = self.filter_queryset(self.get_queryset())# 请求地址中带过滤条件 127.0.0.1:8080/?name=红楼梦# 5个接口中，只有获取所有需要过滤，其他都不需要# 内置的过滤类### 第一步：导入from rest_framework.filters import SearchFilter### 第二步：在视图类中写# 在视图类中# 必须继承GenericAPIView，才有这个类属性filter_backends = [SearchFilter,]# 需要配合一个类属性,可以按name过滤search_fields=[&#x27;name&#x27;,&#x27;author&#x27;]### 第三步：搜索的时候，模糊搜索http://127.0.0.1:8000/books/?search=红http://127.0.0.1:8000/books/?search=清 # 书名或者author中带清就能搜到# 第三方过滤类###第0步：安装pip3 install django-filter### 第一步：注册INSTALLED_APPS = [ 。。。 &#x27;django_filters&#x27;,]### 第二步：导入过滤类from django_filters.rest_framework import DjangoFilterBackend### 第三步：在视图类中使用class BookView(GenericViewSet,ListModelMixin): # 必须继承GenericAPIView，才有这个类属性 filter_backends = [DjangoFilterBackend,] # 需要配合一个类属性 filter_fields=[&#x27;name&#x27;,&#x27;author&#x27;]### 第四步：查询方式http://127.0.0.1:8000/books/?name=红楼梦http://127.0.0.1:8000/books/?name=红楼梦&amp;author=刘清政 # and条件http://127.0.0.1:8000/books/?author=刘清政# 自定义过滤类### 第一步：写一个类，继承BaseFilterBackend 基类，重写filter_queryset方法,返回qs对象，是过滤后的对象class BookNameFilter(BaseFilterBackend): def filter_queryset(self, request, queryset, view): query=request.query_params.get(&#x27;name&#x27;) if query: queryset=queryset.filter(name__contains=query) return queryset### 第二步：在视图类中使用from .filter import BookNameFilterclass BookView(GenericViewSet,ListModelMixin): #filter_backends = [BookNameFilter,] filter_backends = BookNameFilter ### 第四步：查询方式http://127.0.0.1:8000/books/?name=红 # 模糊匹配 ，自己定义的 #### 源码分析----》GenericAPIView----》查询所有，调用了list---》self.filter_queryset(self.get_queryset())----》查看GenericAPIView的filter_queryset方法： def filter_queryset(self, queryset): for backend in list(self.filter_backends): queryset = backend().filter_queryset(self.request, queryset, self) return queryset 2 排序12345678910111213141516171819# 按照id排序，按照年龄排序，按照价格排序# 使用内置的即可## 第一步：导入内置排序类from rest_framework.filters import OrderingFilter## 第二步：在视图类中配置(必须继承GenericAPIView)class BookView(GenericViewSet,ListModelMixin): # 支持按price排序 filter_backends = [OrderingFilter,] ordering_fields=[&#x27;price&#x27;]## 第三步：查询http://127.0.0.1:8000/books/?ordering=-price # 倒序排http://127.0.0.1:8000/books/?ordering=-price,-id # 先按价格倒序排，如果价格一样，再按id倒序排 # 过滤和排序可以同时用---&gt;因为他们本质是for循环一个个执行，所有优先使用过滤，再使用排序filter_backends = [SearchFilter,OrderingFilter]ordering_fields=[&#x27;price&#x27;,&#x27;id&#x27;]search_fields=[&#x27;name&#x27;,&#x27;author&#x27;] 3 分页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 5个接口中，只有查询所有，涉及到分页# pc端是下一个页，下一页的形式，如果在app，小程序中展现形式是下拉加载下一个# 默认提供了，三种分页方式：# PageNumberPagination：基本分页--》按照页码数，每页显示多少条#第一步：写一个类，继承PageNumberPagination，重写四个类属性 # 重写四个类属性 page_size = 3 # 每页显示条数，默认 page_query_param = &#x27;page&#x27; # 查询条件叫page --&gt; ?page=3 page_size_query_param = &#x27;size&#x27; # 每页显示的条数的查询条件 ?page=3&amp;size=9 查询第三页，第三页显示9条 max_page_size = 5 # 每页最大线上多少条，?page=3&amp;size=9，最终还是显示5条#第二步：配置在视图类上，必须继承GenericAPIView才有pagination_class = PageNumberPagination# 第三步：查询方式http://127.0.0.1:8000/books/?page=2&amp;size=8 # LimitOffsetPagination---》偏移分页#第一步：写一个类，继承LimitOffsetPagination，重写四个类属性 default_limit = 2 # 默认一页获取条数 2 条 limit_query_param = &#x27;limit&#x27; # ?limit=3 获取三条，如果不传，就用上面的默认两条 offset_query_param = &#x27;offset&#x27; # ?limit=3&amp;offset=2 从第2条开始，获取3条 ?offset=3：从第三条开始，获取2条 max_limit = 5 # 最大显示条数 5 条#第二步：配置在视图类上，必须继承GenericAPIView才有pagination_class = CommonLimitOffsetPagination# 第三步：查询方式http://127.0.0.1:8000/books/?limit=2&amp;offset=1# CursorPagination---》游标分页#第一步：写一个类，继承CursorPagination，重写四个类属性class CommonCursorPagination(CursorPagination): page_size = 2 # 每页显示2条 cursor_query_param = &#x27;cursor&#x27; # 查询条件 ?cursor=sdafdase ordering = &#x27;id&#x27; # 排序规则，使用id排序#第二步：配置在视图类上，必须继承GenericAPIView才有pagination_class = CommonCursorPagination# 第三步：查询方式http://127.0.0.1:8000/books/?cursor=cD02 #### 注意：# 跟上面两种的区别：上面两种，可以从中间位置获取某一页，Cursor方式只能上一页和下一页# 上面这两种在获取某一页的时候，都需要从开始过滤到要取的页面数的数据# 下面这种方式，先排序，内部维护了一个游标，游标只能选择往前走或往后走，在取某一页的时候，不需要过滤之前的数据# 这种分页方式特殊，只能选择上一页和下一页，不能指定某一页，但是速度快，适合大数据量的分页# 大数据量和app分页---》下拉加载下一页，不需要指定跳转到第几页 4 异常处理123456789101112131415161718192021222324252627282930313233343536373839# 之前读APIViwe源码的时候，捕获了全局异常，在执行三大认证，视图类的方法时候，如果出了异常，会被全局异常捕获# 统一返回格式，无论是否异常，返回的格式统一 ，记录日志（好排查） &#123;code:999,msg:服务器异常，请联系系统管理员&#125; &#123;code:100,msg:成功,data:[&#123;&#125;,&#123;&#125;]&#125; # 步骤： 第一步：写一个函数from rest_framework.views import exception_handler # 默认没有配置，出了异常会走它from rest_framework.response import Responsedef common_exception_handler(exc, context): # 第一步，先执行原来的exception_handler # 第一种情况，返回Response对象，这表示已经处理了异常,它只处理APIExcepiton的异常，第二种情况，返回None，表示没有处理 res = exception_handler(exc, context) if res: # exception_handler 已经处理了，暂时先不处理了 # 998:APIExcepiton # res=Response(data=&#123;&#x27;code&#x27;:998,&#x27;msg&#x27;:&#x27;服务器异常，请联系系统管理员&#x27;&#125;) res = Response(data=&#123;&#x27;code&#x27;: 998, &#x27;msg&#x27;: res.data.get(&#x27;detail&#x27;, &#x27;服务器异常，请联系系统管理员&#x27;)&#125;) else: # 999：出了APIExcepiton外的异常 # res=Response(data=&#123;&#x27;code&#x27;:999,&#x27;msg&#x27;:&#x27;服务器异常，请联系系统管理员&#x27;&#125;) res = Response(data=&#123;&#x27;code&#x27;: 999, &#x27;msg&#x27;: str(exc)&#125;) # 注意：咱们在这里，可以记录日志---》只要走到这，说明程序报错了，记录日志，以后查日志---》尽量详细 # 出错时间，错误原因，哪个视图类出了错，什么请求地址，什么请求方式出了错 request = context.get(&#x27;request&#x27;) # 这个request是当次请求的request对象 view = context.get(&#x27;view&#x27;) # 这个viewt是当次执行的视图类对象 print(&#x27;错误原因：%s,错误视图类：%s,请求地址：%s,请求方式：%s&#x27; % (str(exc), str(view), request.path, request.method)) return res 第二步：把函数配置在配置文件中 REST_FRAMEWORK = &#123; &#x27;EXCEPTION_HANDLER&#x27;: &#x27;app01.exception.common_exception_handler&#x27; # 再出异常，会执行这个函数&#125; ### 以后再出异常，都会走这个函数，后期需要记录日志，统一了返回格式 123456789101112131415161 写出查询所有图书接口，支持按name模糊匹配， ?name=红 (自定义过滤器)，支持按price排序2 写出查询所有作者接口，按三种方式分页---》三个视图类，带异常处理3 高级---》自行研究---》继承APIView，实现分页---》难class BookAPIView(APIView): book_list = models.Book.objects.all().filter(is_delete=False) page_cursor = MyPageNumberPagination() book_list = page_cursor.paginate_queryset(book_list, request, view=self) next_url = page_cursor.get_next_link() pr_url = page_cursor.get_previous_link() book_list_ser = ser.BookModelSerializer(book_list, many=True) return APIResponse(data=book_list_ser.data, url=&#123;&quot;next_url&quot;: next_url, &quot;pr_url&quot;: pr_url&#125;)","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"06、认证、频率、权限","slug":"drf_day06","date":"2018-10-20T06:04:06.000Z","updated":"2022-05-14T04:42:56.697Z","comments":true,"path":"2018/10/20/drf_day06/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day06/","excerpt":"","text":"复习123456789101112131415161718192021222324# 1 视图层 -两个视图基类：APIView，GenericAPIView(类属性和方法) -5个视图扩展类（不是视图类）---》配合GenericAPIView使用 -9个视图子类，不需要写get，post方法 -继承视图子类，重写get，post方法或者list，destory方法 -视图集： -ModelViewSet，ReadOnlyModelViewSet -ModelViewSet=ViewSetMixin+GenericAPIView+5个视图扩展类 -ReadOnlyModelViewSet=ViewSetMixin+GenericAPIView+获取所有，获取单个 -ViewSet，GenericViewSet -ViewSet：ViewSetMixin+APIView---》ViewSetMixin放在前面，重写了as_view -GenericViewSet：ViewSetMixin+GenericAPIView -原来继承APIView或GenericAPIView这种视图类，可以继承ViewSet，GenericViewSet只是路由写法变了 # 2 路由层 -第一种写法： path(&#x27;admin/&#x27;, 视图类.as_view()), -第二种写法：path(&#x27;admin/&#x27;, 视图类.as_view(&#123;&#x27;get&#x27;:&#x27;login&#x27;&#125;))---&gt;ViewSetMixin及其子类 -第三种写法：自动生成路由--》9个视图子类+ViewSetMixin -实例化得到路由对象，注册，在urlpatterns中加入 -拓展：自动生成路由，映射关系自己定---》action装饰器 detail=False:127.0.0.1:8080/publish/action装饰的函数名---&gt;get，post，delete。。。 detail=True:127.0.0.1:8080/publish/pk/action装饰的函数名---&gt;get，post，delete。。。 1 认证123456# 登陆接口---》登陆成功，只要给前端返回json格式字符串---》字符串中带一个随机字符串# 认证---》登陆认证---》判断用户是否登录了---》前后端分离---》用不到cookie---》携带随机字符串过来---》通过判断随机字符串判断这个人是否登录了# 登陆接口编写步骤 -创建表：User表，一对一UserToken表 -前端传入用户名，密码---》User表中查，如果能查到---》让他登陆成功---》在UserToken中存一条记录---》返回给前端json格式字符串---》字符串中带一个随机字符串 1.1 登陆接口123456789101112131415# class UserView(ViewSetMixin,APIView):class UserView(ViewSet): @action(methods=[&#x27;POST&#x27;], detail=False) def login(self, request): username = request.data.get(&#x27;username&#x27;) password = request.data.get(&#x27;password&#x27;) user = User.objects.filter(username=username, password=password).first() if user: # 登陆成功--》生成一个随机字符串--&gt;存到token表中(如果之前有记录，更新，如果没有新增) # uuid生成不重复的串---》理论上不重复 token = str(uuid.uuid4()) # 伪随机数生成，没有参数，重复概率，比其他的高一些 UserToken.objects.update_or_create(user=user, defaults=&#123;&#x27;token&#x27;: token&#125;) # 如果存在就更新，如果不存在就新增 return Response(&#123;&#x27;code&#x27;: 100, &#x27;msg&#x27;: &#x27;登陆成功&#x27;, &#x27;token&#x27;: token&#125;) else: return Response(&#123;&#x27;code&#x27;: 101, &#x27;msg&#x27;: &#x27;用户名或密码错误&#x27;&#125;) urls.py 123456789from app01 import viewsfrom rest_framework.routers import SimpleRouterrouter=SimpleRouter()router.register(&#x27;user&#x27;,views.UserView,&#x27;user&#x27;)urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;&#x27;, include(router.urls)),] models.py 1234567891011class User(models.Model): username = models.CharField(max_length=32) password = models.CharField(max_length=32) user_type = models.IntegerField(choices=((1, &#x27;超级管理员&#x27;), (2, &#x27;普通管理员&#x27;), (3, &#x27;普通用户&#x27;))) # gender=models.IntegerField(choices=((1,&quot;男&quot;),(2,&quot;女&quot;),(0,&quot;未知&quot;))) # 1:男 2:女 0:未知 # user对象.get_字段名_display() 快速取出gender数字对应的中文class UserToken(models.Model): user = models.OneToOneField(to=User,on_delete=models.CASCADE) token = models.CharField(max_length=32) 1.2 认证类12345678910111213141516171819# 认证类：用来校验用户是否登录，如果登录了，继续往下走，如果没有登录，直接返回# 编写步骤： -第一步：写一个类，继承BaseAuthentication,重写authenticate，在方法中做校验，校验是否登录，返回两个值，没有登录抛异常 -第二步：全局配置，局部配置 -全局配置：配置文件中 REST_FRAMEWORK=&#123; &quot;DEFAULT_AUTHENTICATION_CLASSES&quot;:[&quot;app01.auth.LoginAuth&quot;,] &#125; -局部配置：在视图类中 class UserView(ViewSet): authentication_classes = [LoginAuth] -局部禁用： class UserView(ViewSet): authentication_classes = [] # 认证类中返回的两个变量，干啥用了 -返回的第一个，给了request.user，就是当前登录用户 -返回的第二个，给了request.auth，就是token串 2 频率12345678910111213141516171819# 认证，权限都通过以后，现在某个接口的访问频率---》一般根据ip或者用户限制# 使用步骤 -第一步：写一个类，继承SimpleRateThrottle，重写类属性：scope，和get_cache_key方法 get_cache_key返回什么，就以什么做现在，scope配置文件中要用 -第二步：在配置文件中配置 &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123; &#x27;minute_3&#x27;: &#x27;3/m&#x27; # minute_3是scope的字符串，一分钟访问3次 &#x27;minute_5&#x27;：&#x27;5/m&#x27; &#125; -局部使用--》视图类中 class BookView(GenericViewSet, ListModelMixin, RetrieveModelMixin): throttle_classes = [IPThrottle] -全局使用--配置文件中 &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: ( # 全局配置频率类 &#x27;app01.auth.IPThrottle&#x27; ), 3 权限12345678910111213141516171819202122232425# 登录成功----》所有必须登录能访问---》每个视图类上加认证类# 用户是普通用户---》普通用户可以访问所有和单条# 普通管理员和超级用户可以操作所有，除了访问单条和所有的那个视图类，加上认证类# books：查看一条，和所有# booksdetail路由下有：删除，新增，修改---》权限类加在这里# book 5个接口，必须登录才能访问# 5个接口分成了俩视图写： -BookView：获取所有，获取单条 -BookDetailView：删除，修改，新增 -这俩视图都需要登录：authentication_classes = [LoginAuth, ] -BookView只要登陆就可以操作 -BookDetailView必须有权限才能，加了一个权限，permission_classes = [UserPermission, ] # 跟写认证类步骤差不多第一步：写一个类，继承BasePermission，重写has_permission，判断如果有权限，返回True，如果没有权限，返回False第二步：局部使用和全局使用 -局部使用 class BookDetailView(GenericViewSet, CreateModelMixin, DestroyModelMixin, UpdateModelMixin): permission_classes = [UserPermission, ] -全使用 REST_FRAMEWORK=&#123; &quot;DEFAULT_PERMISSION_CLASSES&quot;:[&quot;app01.auth.UserPermission&quot;,] &#125; 12345678910111213from rest_framework.permissions import BasePermissionclass UserPermission(BasePermission): def has_permission(self, request, view): self.message=&#x27;您是:%s，没有权限&#x27;%request.user.get_user_type_display() # 没有权限的提示信息 # 如果有权限，返回True,没有权限返回False # 权限类，在认证类之后，request.user有了当前登录用户 user_type = request.user.user_type if user_type &lt; 3: # 只要不是1，2，就没有权限 return True else: return False 123456789101112130 book，author，publish 对应的5个接口写完1 写一个登陆接口，写一个认证类，除了登陆接口外，所有接口都要登陆后访问2 写一个频率类，每分钟访问5次，book的所有接口，使用这个频率类3 写一个权限类，publish的所有操作需要超级用户能访问，其他的普通登陆用户就可以操作4 尝试写：频率类继承BaseThrottle，写频率限制类，重写allow_request方法，如果没有到限制，返回True，到了限制返回false---》局部和全局配置#（1）取出访问者ip#（2）判断当前ip不在访问字典里，添加进去，并且直接返回True,表示第一次访问，在字典里，继续往下走#（3）循环判断当前ip的列表，有值，并且当前时间减去列表的最后一个时间大于60s，把这种数据pop掉，这样列表中只有60s以内的访问时间，#（4）判断，当列表小于3，说明一分钟以内访问不足三次，把当前时间插入到","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"05、视图组件、路由组件","slug":"drf_day05","date":"2018-10-20T06:04:05.000Z","updated":"2022-05-14T04:42:40.831Z","comments":true,"path":"2018/10/20/drf_day05/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day05/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 0 多表的序列化和反序列化 -序列化和反序列化字段不一样---》read_only和write_only空中 -序列化字段---》自定制---》models中，序列化类中 -反序列化---》校验--》字段自己，局部，全局钩子函数,外键关联的都是id号传入 -保存，修改---》继承了ModelSerializer，一般不需要重写create和update -修改个人信息--》详情和普通信息是在一个页面一次性提交的 -name，age，telephone，addr# 1 请求对象 -request.data -request.query_params -__getattr__ -能够解析的数据格式 -局部配置在视图类中 -全局配置配置文件中 -如果不配置，会有默认配置---drf的默认配置# 2 响应对象 -response.data # 给前端响应体的内容 -response.status # 响应状态码 -response.header # 响应头 -返回给前端的样子 -浏览器中有模板的样子 -json格式 # 视图层 -APIView -GenericAPIView 继承了APIView，封装了一些属性和方法，跟数据库打交道 -queryset = None -serializer_class = None -lookup_field = &#x27;pk&#x27; # 查询单条，分组分出来的参数，转换器对象参数的名字 -filter_backends # 过滤排序功能会用它 -pagination_class # 分页功能 -get_queryset() # 获取要序列化的数据,后期可能会重写 -get_object() # 通过lookup_field查询的 -get_serializer() # 使用它序列化 -get_serializer_class() # 返回序列化类 ，后期可能重写 -5个视图扩展类--》不是视图类--》5个类，分别有一个方法--》GenericAPIView+5个视图扩展 -新增，查询单条，查询所有，修改，删除 -CreateModelMixin, -ListModelMixin, -DestroyModelMixin, -RetrieveModelMixin, -UpdateModelMixin 1 视图组件123456789101112131415# 9个视图子类---》是视图类 -CreateAPIView, ListAPIView, DestroyAPIView, RetrieveAPIView, UpdateAPIViewListCreateAPIView, RetrieveUpdateAPIView, RetrieveUpdateDestroyAPIView, \\ RetrieveDestroyAPIView # 视图集# ViewSet=APIView+ViewSetMixin# GenericViewSet=GenericAPIView+ViewSetMixin# 以后只要想自动生成路由，必须继承ViewSetMixin及其子类# 之前的写法可以沿用，只是如果要自动生成路由可以选择继承ViewSet，GenericViewSetfrom rest_framework.viewsets import ModelViewSet,ReadOnlyModelViewSetfrom rest_framework.viewsets import ViewSet,GenericViewSetfrom rest_framework.viewsets import ViewSetMixin 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 第四层：通过9个视图子类，编写视图函数# from rest_framework.generics import CreateAPIView, ListAPIView, DestroyAPIView, RetrieveAPIView, UpdateAPIView# from rest_framework.generics import ListCreateAPIView, RetrieveUpdateAPIView, RetrieveUpdateDestroyAPIView, \\# RetrieveDestroyAPIView### # class PublishView(ListCreateAPIView): # 查询所有和新增接口就有了# # class PublishView(CreateAPIView): # 新增接口就有了# class PublishView(ListAPIView): # 查询所有接口就有了# queryset = Publish.objects.all()# serializer_class = PublishSerialzier## # 有可能要重写--》get_queryset--》get_serializer_class--》perform_create--》get，post方法### class PublishDetailView(RetrieveUpdateDestroyAPIView): # 查询单条，删除，修改# # class PublishDetailView(RetrieveAPIView): # 查询单条# # class PublishDetailView(DestroyAPIView): # 删除# # class PublishDetailView(UpdateAPIView): # 修改# # class PublishDetailView(RetrieveDestroyAPIView): # 查询单条和删除# # class PublishDetailView(RetrieveUpdateAPIView): # 查询单条和更新# # class PublishDetailView(UpdateAPIView,DestroyAPIView): # 更新和删除# queryset = Publish.objects.all()# serializer_class = PublishSerialzier# 第五层：通过ViewSet写视图类# 5个接口，都用一个视图类----》路由 有两个getfrom rest_framework.viewsets import ModelViewSet,ReadOnlyModelViewSet# ViewSet=APIView+ViewSetMixin# GenericViewSet=GenericAPIView+ViewSetMixin# 以后只要想自动生成路由，必须继承ViewSetMixin及其子类# 之前的写法可以沿用，只是如果要自动生成路由可以选择继承ViewSet，GenericViewSetfrom rest_framework.viewsets import ViewSet,GenericViewSetfrom rest_framework.viewsets import ViewSetMixin# 集成了5个视图扩展类+GenericViewSet(ViewSetMixin, generics.GenericAPIView)# ViewSetMixin--&gt;控制了路由写法变了# class PublishView(ModelViewSet): # 修改路由,5个接口class PublishView(ReadOnlyModelViewSet): # 修改路由,只读，查所有，查单个 queryset = Publish.objects.all() serializer_class = PublishSerialzier 2 路由组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 只要继承ViewSetMixin 及其子类，路由写法就变了# 视图类：继承ViewSetMixin，路由写法变了---&gt;而且视图类中的方法不一定写成get，post..,可以随意命名，只不过定义路由时写法变成了path(&#x27;test/&#x27;, views.TestView.as_view(&#123;&#x27;get&#x27;: &#x27;login&#x27;&#125;))，get请求执行login方法 # 到底如何执行的？ # ViewSetMixin必须写在前面 ViewSetMixin--》as_view---&gt;类的查找顺序---》actions就是传入的字典---》view闭包函数 def view(request, *args, **kwargs): # get login for method, action in actions.items(): # 把login方法的内存地址给了handler handler = getattr(self, action) # 通过反射，设置给get---》对应login---》get请求执行get方法，现在get方法变成了login方法 setattr(self, method, handler) return self.dispatch(request, *args, **kwargs)# 跟之前一样了 # 视图类，继承ModelViewSet，路由写法 path(&#x27;publish/&#x27;, views.PublishView.as_view(&#123;&#x27;get&#x27;:&#x27;list&#x27;,&#x27;post&#x27;:&#x27;create&#x27;&#125;)), path(&#x27;publish/&lt;int:pk&gt;&#x27;, views.PublishView.as_view(&#123;&#x27;get&#x27;:&#x27;retrieve&#x27;,&#x27;put&#x27;:&#x27;update&#x27;,&#x27;delete&#x27;:&#x27;destroy&#x27;&#125;)) # 到现在，咱们有了一种方式，可以在一个视图类中写很多方法，通过路由的配置，实现一个视图函数对应很多路由 # 上面的两个路由，可以自动生成---&gt;生成上面那两条地址 第一步：导入drf提供的路由类 from rest_framework.routers import SimpleRouter 第二步：实例化得到对象 router = SimpleRouter() 第三步：注册路由 router.register(&#x27;地址&#x27;, 视图类, &#x27;别名&#x27;) router.register(&#x27;publish&#x27;, views.PublishView, &#x27;publish&#x27;) 第四步：在urlpatterns加入（两种方式） path(&#x27;/api/v1&#x27;, include(router.urls)) urlpatterns+=router.urls # SimpleRouter和DefaultRouter 用法完全一样，只是生成的路由不一样DefaultRouter比SimpleRouter多一条根地址，一般咱么就用SimpleRouter就可以 # 如果使用自动生成路由，必须继承谁及其子类？ GenericViewSet+5个视图扩展类至少之一---》才能自动生成 ModelViewSet ReadOnlyModelViewSet # action装饰器 -只要是继承ViewSetMixin视图类中方法，都可以加action装饰器，只要加了，自动生成路由会多生成--》127.0.0.1:8080/test/login：get或post都能触发 @action(methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],detail=False) def login(self,request): # 如果写法如下，生成的路径是127.0.0.1:8080/test/数字/login @action(methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],detail=True) def login(self,request): 123456789101112131415161718192021222324252627# 以后路由写法有三种 path(&#x27;books/&lt;int:pk&gt;&#x27;, views.BookDetailView.as_view()), # 继承了ViewSetMixin path(&#x27;publish/&#x27;, views.PublishView.as_view(&#123;&#x27;get&#x27;:&#x27;list&#x27;,&#x27;post&#x27;:&#x27;create&#x27;&#125;)) # 自动生成路由 from rest_framework.routers import SimpleRouter,DefaultRouter router = SimpleRouter() router.register(&#x27;publish&#x27;, views.PublishView, &#x27;publish&#x27;) # 路由注册，两种方式 path(&#x27;api/v1/&#x27;, include(router.urls)), urlpatterns+=router.urls # 路由类，有连个SimpleRouter，DefaultRouter，DefaultRouter自动生成的路由更多 # action装饰器---》只要继承ViewSetMixin都能自动生成路由 # methods=请求方法，列表, # detail=是否带id, # url_path=地址如果不写，默认已方法名为地址, # url_name=别名 # 写成如下，自动生成路由会生成一条路径：127.0.0.1:8080/test/login --&gt;get，post都会触发 @action(methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],detail=True) def login(self,request): # 如果写法如下，生成的路径是127.0.0.1:8080/test/数字/login @action(methods=[&#x27;GET&#x27;,&#x27;POST&#x27;],detail=True) def login(self,request): # 通过action，怎么通过action判断，重写get_queryset，get_serializer_class 12345678910111213141516171 把视图层中所有的类列出来，然后写好他们的继承关系，每个类中比较重要的方法或属性都列出来 学长做的图--》发出来 2 登陆接口，只要用户登录，在token表中插入一条记录，随机(uuid)生成一个token--&gt;继承ViewSet，自动生成路由 -用户表，token表 class User(models.Model): username=models.CharField(max_length=32) password=models.CharField(max_length=32) user_type=models.IntegerField(choices=((1,&#x27;超级用户&#x27;),(2,&#x27;普通用户&#x27;),(3,&#x27;二笔用户&#x27;)))class UserToken(models.Model): user=models.OneToOneField(to=&#x27;User&#x27;) token=models.CharField(max_length=64) - username：lqz，password：123---》User查到了，表示可以登陆，返回登录成功&#123;username:lqz,token:xdasfads&#125;----&gt;下次只要携带token，我就认为它登陆了-登陆时，判断token有没有，如果有更新，如果没有，新增","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"04、序列化多表操作（models、serializer、views、urls）、请求与响应（请求、响应）、视图组件","slug":"drf_day04","date":"2018-10-20T06:04:04.000Z","updated":"2022-05-14T04:35:26.525Z","comments":true,"path":"2018/10/20/drf_day04/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day04/","excerpt":"","text":"复习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 1 序列化器----》drf的类# 2 能够完成的事 序列化:把模型对象(qs,单个对象)---》转成字典---》Response--》json格式字符串 -json格式字符串：字符串---》转换成不同语言的数据结构--》格式 必须是&quot;&quot; 反序列化：把json格式字符串---》模型对象保存(新增，修改) 数据校验：字段自己的校验，局部钩子校验,全局钩子 -就是一个方法，只要写了，就会执行，只要没写，就不执行 -写在序列化类中，validate_字段名的方法，只要写了，就会执行，会把字段对应的数据传入，如果校验失败，抛ValidationError异常，如果校验通过，返回该字段 for 循环每一个字段 func=getattr(序列化类对象,&#x27;validate_%s&#x27;%字段名) func()# 3 Serializer类---》继承它及其子类(ModelSerializer) -第一步：写一个类继承 -第二步：在类中写字段---》字段类型 ，字段参数，---》read_only write_only -第三步：序列化 -ser=序列化类(instance=模型对象,many=True) #many=True ser对象不是序列化类的对象 ListSerializer的对象，里面套了一个个序列化类对象，many=False，ser就是序列化类的对象 -ser.data # 字典 反序列化 -ser=序列化类(data=request.data) # 新增 -ser=序列化类(data=request.data,instance=修改的对象) # 修改 -ser.is_validate() # 校验数据----》走字段自己的校验规则，局部钩子，全局钩子 -ser.save() # 无论是修改还是新增，都是save，一定要重写create和update# 4 序列化定制字段 -在序列化类中写 -表模型中写# 5 反序列化的局部全局钩子写法# 6 ModelSerializer--》继承了Serializer---》create update class Meta: model=Book #fields=&#x27;__all__&#x27; #fields=[&#x27;name&#x27;,&#x27;id&#x27;,&#x27;name_info&#x27;] extra_kwargs=&#123; &#x27;name&#x27;:&#123;read_only:True&#125;, &#x27;id&#x27;:&#123;&#125; &#125; # 重写字段 name_info = serializer.CharField(max_length=32) # 局部钩子全局钩子 # 断言 assert a==10, (&#x27;`create()` did not return an object instance.&#x27;) if a==10: pass else: raise Exception(&#x27;`create()` did not return an object instance.&#x27;) 1 序列化多表操作1# book 系列那几个表 1.1 models123456789101112131415161718192021222324252627282930313233343536373839404142434445from django.db import models# 4张表class Book(models.Model): name = models.CharField(max_length=32) price = models.DecimalField(max_digits=5, decimal_places=2) publish = models.ForeignKey(to=&#x27;Publish&#x27;, on_delete=models.CASCADE) authors = models.ManyToManyField(to=&#x27;Author&#x27;) def __str__(self): return self.name @property def publish_detail(self): return &#123;&#x27;name&#x27;: self.publish.name, &#x27;addr&#x27;: self.publish.city&#125; @property def author_list(self): l = [] print(self.authors.all()) for author in self.authors.all(): print(author.author_detail) l.append(&#123;&#x27;name&#x27;: author.name,&#x27;age&#x27;:author.age,&#x27;addr&#x27;:author.author_detail.addr&#125;) return lclass Author(models.Model): name = models.CharField(max_length=32) age = models.IntegerField() author_detail = models.OneToOneField(to=&#x27;AuthorDatail&#x27;, on_delete=models.CASCADE) # OneToOneField 就是ForeignKey+unique=Trueclass AuthorDatail(models.Model): telephone = models.BigIntegerField() # birthday = models.DateField() addr = models.CharField(max_length=64)class Publish(models.Model): name = models.CharField(max_length=32) city = models.CharField(max_length=32) email = models.EmailField() 1.2 serializer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from .models import *from rest_framework import serializersclass BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = &#x27;__all__&#x27;class AuthorSerialzier(serializers.ModelSerializer): class Meta: model = Author fields = &#x27;__all__&#x27;from .models import *from rest_framework import serializersclass BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;price&#x27;, &#x27;authors&#x27;, &#x27;publish&#x27;, &#x27;publish_detail&#x27;, &#x27;author_list&#x27;] # depth=1 # 尽量不要用，关联表一层全部取出来 extra_kwargs = &#123; &#x27;publish&#x27;: &#123;&#x27;write_only&#x27;: True&#125;, &#x27;authors&#x27;: &#123;&#x27;write_only&#x27;: True&#125;, &#125; # 定制序列化的字段（2种）--》表模型中class AuthorSerialzier(serializers.ModelSerializer): class Meta: model = Author fields = &#x27;__all__&#x27;class AuthorDetailSerialzier(serializers.ModelSerializer): class Meta: model = AuthorDatail fields = &#x27;__all__&#x27;class PublishSerialzier(serializers.ModelSerializer): class Meta: model = Publish fields = &#x27;__all__&#x27;class AuthorDetailSerialzier(serializers.ModelSerializer): class Meta: model = AuthorDatail fields = &#x27;__all__&#x27;class PublishSerialzier(serializers.ModelSerializer): class Meta: model = Publish fields = &#x27;__all__&#x27; 1.3 views123456789101112131415161718192021222324252627282930313233class BookView(APIView): def get(self, request): book_list = Book.objects.all() ser = BookSerializer(instance=book_list, many=True) return Response(ser.data) def post(self, request): ser = BookSerializer(data=request.data) if ser.is_valid(): ser.save() return Response(&#123;&quot;code&quot;: 100, &#x27;msg&#x27;: &#x27;新增成功&#x27;, &#x27;data&#x27;: ser.data&#125;) return Response(&#123;&quot;code&quot;: 101, &#x27;msg&#x27;: &#x27;新增出错&#x27;, &#x27;err&#x27;: ser.errors&#125;)class BookDetailView(APIView): def get(self, request, pk): book = Book.objects.all().filter(pk=pk).first() ser = BookSerializer(instance=book) return Response(ser.data) def put(self, request, pk): book = Book.objects.all().filter(pk=pk).first() ser = BookSerializer(instance=book, data=request.data) if ser.is_valid(): ser.save() return Response(&#123;&quot;code&quot;: 100, &#x27;msg&#x27;: &#x27;修改成功&#x27;, &#x27;data&#x27;: ser.data&#125;) return Response(&#123;&quot;code&quot;: 101, &#x27;msg&#x27;: &#x27;修改出错&#x27;, &#x27;err&#x27;: ser.errors&#125;) def delete(self, request, pk): Book.objects.filter(pk=pk).delete() return Response(&#123;&quot;code&quot;: 100, &#x27;msg&#x27;: &#x27;删除成功&#x27;&#125;) 1.4 urls12345urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;books/&#x27;, views.BookView.as_view()), path(&#x27;books/&lt;int:pk&gt;&#x27;, views.BookDetailView.as_view()),] 2 请求与响应2.1 请求1234567891011121314151617181920212223242526272829303132333435363738394041# Request 类的对象---》新的request对象from rest_framework.request import Request# 记住的 __getattr__ request.data request.query_parmas---&gt;self._request.GET--&gt;restful规范里，请求地址中带过滤(查询)条件---》get请求地址中提交的数据在GET中，---》query_parmas：查询参数 # 了解---&gt;默认情况下，可以解析 urlencoded，formdata，json -如果我们写了一个接口，想只能处理json格式，或者只能处理formdata # 局部配置from rest_framework.parsers import JSONParser,FormParser,MultiPartParserclass PublishView(APIView): # 局部使用，只针对当前视图类有效，只想处理json格式 parser_classes = [JSONParser]# 全局配置---》配置文件---&gt;所有接口都只能解析json格式REST_FRAMEWORK = &#123; &#x27;DEFAULT_PARSER_CLASSES&#x27;: [ &#x27;rest_framework.parsers.JSONParser&#x27;, ],&#125;# 全局配置解析json，局部某个视图函数想能解析formdata格式视图类中配置一下即可---》局部配置-如果局部配置如下，会怎么样parser_classes = [] # 所有格式都补不能解析了# 使用顺序：我们没有配置，也有默认配置：3个都能解析 drf有默认配置(最后)----》项目配置文件的配置(其次)----》视图类中配的(优先用) drf的默认配置：from rest_framework import settings # 总结：一般情况下，都使用默认即可，不用配置 2.2 响应1234567891011121314151617181920212223242526272829303132Respone:from rest_framework.response import Response# 属性data=None, # 字符串，字典，列表--》给http响应body体中内容--&gt;response对象中取出处理status=None, # 响应状态码：1xx，2xx，3xx，默认是200from rest_framework.status import HTTP_201_CREATEDResponse(ser.data,status=HTTP_201_CREATED)headers=None, # 响应头 字典 ---了解---template_name=None, # 模板名字(不用)，用浏览器访问时，可以改exception=False, # 异常处理content_type=None # 响应编码格式# 响应格式---》跟解析格式# 局部设置from rest_framework.renderers import JSONRenderer,BrowsableAPIRendererclass BookDetailView(APIView): renderer_classes = [JSONRenderer,]# 全局设置REST_FRAMEWORK = &#123; &#x27;DEFAULT_RENDERER_CLASSES&#x27;: ( # 默认响应渲染类 &#x27;rest_framework.renderers.JSONRenderer&#x27;, # json渲染器 &#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;, # 浏览API渲染器 )&#125; 3 视图组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# APIView from rest_framework.views import APIView -类属性 -renderer_classes,parser_classes。。。 -get方法，post方法，delete方法写法跟之前的View一样，只不过request对象变成了新的request丢下 -比之前的View多了三大认证和全局异常处理 # GenericAPIView 继承了APIView ，多了属性和方法 from rest_framework.generics import GenericAPIView -属性(先记两个) -queryset = None -serializer_class = None -方法 -get_queryset -get_object -get_serializer # 5个视图扩展类(不是视图类，没有集成APIView，需要配合GenericAPIView) from rest_framework.mixins CreateModelMixin, ListModelMixin, DestroyModelMixin, RetrieveModelMixin, UpdateModelMixin # 9个视图子类 from rest_framework.generics CreateAPIView, ListAPIView, DestroyAPIView, RetrieveAPIView, UpdateAPIView ListCreateAPIView, RetrieveUpdateAPIView, RetrieveUpdateDestroyAPIView, RetrieveDestroyAPIView# 视图集 from rest_framework.viewsets # 两个视图类 ModelViewSet,ReadOnlyModelViewSet # 视图类 ViewSet,GenericViewSet, # 魔法类 ViewSetMixin 作业 12345671 通过GenericAPIView 把book的4个表的5个接口都写完2 通过GenericAPIView+5个视图扩展类 把book的4个表的5个接口都写完3 通过自己GenericAPIView+其中一个(几个)视图扩展类封装---》9个视图子类--》把5个接口写完4 通过一个视图类，实现5个接口 (尝试一下)---》ModelViewSet","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"03、drf之序列化器（介绍、Serializer使用、反序列化（新增、修改）、ModelSerializer（使用、额外添加参数extra_kwargs））","slug":"drf_day03","date":"2018-10-20T06:04:03.000Z","updated":"2022-05-14T04:34:21.718Z","comments":true,"path":"2018/10/20/drf_day03/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day03/","excerpt":"","text":"复习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 1 restful规范--10条# 2 restful快速使用---》快速演示--》5个接口--》所有接口，都是5个的变形 -查询所有---》get /books/ -查询单个---》get /books/5/ -修改一个---》put,patch /books/5/ ---&gt;需要在body体中带数据---》编码格式 -新增一个---》post----》/books/----》body体中带数据 -删除一个---》delete---&gt;/books/5/---》前端看到这条数据---》删除# 3 cbv源码分析 -路由---》视图类.as_view()---》as_view执行结果是一个函数内存地址---》view闭包函数---》当请求来了，路由匹配成功，执行view(request)---&gt;view闭包函数：self.dispatch---》dispatch---&gt;通过请求方式 使用反射去视图类的对象中反射出跟请求方式同名的方法执行 -as_view类的绑定方法----》装饰器---》classmethod---》绑定给类的，类来调用，自动把类传入---》对象调用？ # 4 什么是闭包函数？---》跟语言无关 -1 定义在函数内容部---》内层函数 -2 对外部作用域有引用--》引用，如果外层变了，闭包函数引用的值，也变了 -闭包是多了一种函数传参的方式---》写在括号中，使用实参传入函数中----》包到函数中，使用外包作用域的变量(引用) # 5 APIView的执行流程---》继承了View---》重写了as_view(csrf禁用了)和dispatch(在执行视图函类的方法之前干了好多事) -比之前cbv执行流程多了 -1 把老的request对象封装成了新的drf的Request对象 -在视图函数中使用的request都是新的 -老的request在新的request._request -视图函数对象.request 就是新的request -新的request使用起来跟老的一模一样，当老的使用即可 -新的request多了个data (方法包装成数据属性)--》body体中的数据都在data中 -request.data---&gt;是哪个类的对象？ -urlencoded，formdata：QueryDict -json：字典对象 -看看QueryDict的源码---》type这个对象---》找到它属于哪个类---》导入类，点进去看 print(type(request.POST)) # 老的POST from django.http.request import QueryDict MultiValueDict--》MultiValueDict(&#123;&#x27;name&#x27;: [&#x27;Adrian&#x27;, &#x27;Simon&#x27;], &#x27;position&#x27;: [&#x27;Developer&#x27;]&#125;)----》form表单提交数据多个重名数据---》request.POST.get(&#x27;user&#x27;)---&gt;只能获取到1个，向全取出来使用getlist -2 在执行视图函数之前---》三大认证 -认证 -权限 -频率 -3 处理了全局异常 -视图类中，三大认证过程中---》出了异常，我们都能处理----》处理全局异常 # 6 新的Request类源码 -request.data -重写了 __getattr__----》. 拦截魔法方法---》对象.属性如果属性不存在，就会触发__getattr__执行 -新的request.method---》通过反射，去request._request中反射出method属性 -算但不是---》本意是隐藏起来不让外部用---》只用了一个_ __才叫隐藏属性---》约定俗称，你们公司里 属性，方法 _属性/方法 1 序列化器介绍123456789101112# 序列化器：类，作用1. 序列化,序列化器会把模型对象(qs，book)转换成字典,经过response以后变成json字符串2. 反序列化,把客户端发(前端)送过来的数据,经过request以后变成字典(data),序列化器可以把字典转成模型--&gt;存到数据库中3. 反序列化,完成数据校验功能---》前端传入的数据是否合法，长度够不够。。。数据校验# 使用方式 -第一步：写一个类：必须继承drf中的Serializer及其子类 -第二步：在类中写要序列化的字段--&gt;要序列化哪些，就写哪些，不序列化的不写 -第三步：使用序列化类，视图类中用 -得到序列化类对象 对象.data,通过Response返回给前端 2 Serializer的使用2.1 基本使用–序列化序列化类 12345678from rest_framework import serializersfrom .models import Bookclass BookSerializer(serializers.Serializer): # max_length=32,min_length=3 反序列化保存校验数据的时候用 name = serializers.CharField(max_length=8, min_length=3) price=serializers.CharField() # models中使用了DecimalField，这个位置使用了CharField会把小数类型转成字符串 author = serializers.CharField() 视图类 123456789class BookView(APIView): def get(self,request): # 查出来的数据做序列化 book_list=Book.objects.all() # instance:要序列化的对象 qs，单个对象 # many:如果是qs对象，many=True，如果是单个对象many=False ser=BookSerializer(instance=book_list,many=True) # 传入初始化的参数instance=None, data=empty # ser.data使用模型类对象序列化后的字典 return Response(ser.data) # 字典，列表，字符串都行 路由 12345from app01 import viewsurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;books/&#x27;, views.BookView.as_view()),] 模型类 1234class Book(models.Model): name = models.CharField(max_length=32) price = models.DecimalField(decimal_places=2, max_digits=5) author = models.CharField(max_length=32) 2.2 字段类型123456789101112131415# models中CharField，DecimalField.....# 记住的： CharField IntegerField FloatField DecimalField DateTimeField DateField# 知道--》models中没有的---》反序列化的时候，前端传入的&#123;name:lqz,age:19,hobby:[篮球,足球],wife:&#123;name:lyf,age:38&#125;&#125; ListField DictField 字段 字段构造方式 BooleanField BooleanField() NullBooleanField NullBooleanField() CharField CharField(max_length&#x3D;None, min_length&#x3D;None, allow_blank&#x3D;False, trim_whitespace&#x3D;True) EmailField EmailField(max_length&#x3D;None, min_length&#x3D;None, allow_blank&#x3D;False) RegexField RegexField(regex, max_length&#x3D;None, min_length&#x3D;None, allow_blank&#x3D;False) SlugField SlugField(maxlength&#x3D;50, min_length&#x3D;None, allow_blank&#x3D;False) 正则字段，验证正则模式 [a-zA-Z0-9-]+ URLField URLField(max_length&#x3D;200, min_length&#x3D;None, allow_blank&#x3D;False) UUIDField UUIDField(format&#x3D;’hex_verbose’) format: 1) &#39;hex_verbose&#39; 如&quot;5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot; 2） &#39;hex&#39; 如 &quot;5ce0e9a55ffa654bcee01238041fb31a&quot; 3）&#39;int&#39; - 如: &quot;123456789012312313134124512351145145114&quot; 4）&#39;urn&#39; 如: &quot;urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot; IPAddressField IPAddressField(protocol&#x3D;’both’, unpack_ipv4&#x3D;False, **options) IntegerField IntegerField(max_value&#x3D;None, min_value&#x3D;None) FloatField FloatField(max_value&#x3D;None, min_value&#x3D;None) DecimalField DecimalField(max_digits, decimal_places, coerce_to_string&#x3D;None, max_value&#x3D;None, min_value&#x3D;None) max_digits: 最多位数 decimal_palces: 小数点位置 DateTimeField DateTimeField(format&#x3D;api_settings.DATETIME_FORMAT, input_formats&#x3D;None) DateField DateField(format&#x3D;api_settings.DATE_FORMAT, input_formats&#x3D;None) TimeField TimeField(format&#x3D;api_settings.TIME_FORMAT, input_formats&#x3D;None) DurationField DurationField() ChoiceField ChoiceField(choices) choices与Django的用法相同 MultipleChoiceField MultipleChoiceField(choices) FileField FileField(max_length&#x3D;None, allow_empty_file&#x3D;False, use_url&#x3D;UPLOADED_FILES_USE_URL) ImageField ImageField(max_length&#x3D;None, allow_empty_file&#x3D;False, use_url&#x3D;UPLOADED_FILES_USE_URL) ListField ListField(child&#x3D;, min_length&#x3D;None, max_length&#x3D;None) DictField DictField(child&#x3D;) 2.3 字段参数123456789101112131415161718192021# 写在字段类中的参数--》如：max_length。。。# 重点：read_only:表明该字段仅用于序列化输出，默认False -如果read_only=True，这个字段只用来做序列化---》把对象---》json给前端write_only:表明该字段仅用于反序列化输入，默认False -如果read_only=write_only，这个字段只用来做反序列化---》前端json---》存到数据库 # 举例 name=serializers.CharField(max_length=32,min_length=3) price=serializers.CharField(write_only=True,read_only=True) author=serializers.CharField(write_only=True) # 什么都不写，表示既序列化，又反序列化 # 序列化给前端，前端看到的字段样子---》只能看到name # 反序列化，前端需要传什么过来name,price,author都传 # write_only=True,read_only=True 逻辑矛盾 选项参数： 参数名称 作用 max_length 最大长度（CharField） min_lenght 最小长度（CharField） allow_blank 是否允许为空（CharField） trim_whitespace 是否截断空白字符（CharField） max_value 最小值 （IntegerField） min_value 最大值（IntegerField） 通用参数： 参数名称 说明 read_only 表明该字段仅用于序列化输出，默认False write_only 表明该字段仅用于反序列化输入，默认False required 表明该字段在反序列化时必须输入，默认True default 反序列化时使用的默认值 allow_null 表明该字段是否允许传入None，默认False validators 该字段使用的验证器(不太用) error_messages 包含错误编号与错误信息的字典 label 用于HTML展示API页面时，显示的字段名称 help_text 用于HTML展示API页面时，显示的字段帮助提示信息 2.4 序列化时，定制序列化的字段12345678910111213141516### 两种方案# 作用？比如author关联了外键，想取出作者详情# author_info = serializers.SerializerMethodField()# def get_author_info(self,obj):# return &#123;&#x27;name&#x27;:obj.author.name,&#x27;age&#x27;:obj.author.age&#125;# 第一种：在序列化类中写# price_info = serializers.SerializerMethodField() # 必须配合一个方法,方法名get_字段名# def get_price_info(self, obj): # 方法返回什么，字段就是什么，obj是当前序列化到的单个对象# return &quot;价格是：&quot;+str(obj.price) # python是动态强类型语言--》强类型是：不同类型之间不允许直接运算# 第二种方案：在models中写方法,这里字段名就是models的方法名，price_info方法返回什么，这个字段就是什么# price_info=serializers.CharField()authors=serializers.ListField() 序列化类中写 123price_info = serializers.SerializerMethodField() # 必须配合一个方法,方法名get_字段名def get_price_info(self, obj): # 方法返回什么，字段就是什么，obj是当前序列化到的单个对象 return &quot;价格是：&quot;+str(obj.price) # python是动态强类型语言--》强类型是：不同类型之间不允许直接运算 表模型中写 12345678# 表模型中写方法@property # 把方法包装成数据属性def price_info(self): return &quot;价格是：&quot; + str(self.price) # 序列化类中使用price_info=serializers.CharField(read_only=True) # 只用来做序列化# authors=serializers.ListField() 3 反序列化之新增1234567# 反序列化 第一步：把前端传入的数据，放到Serializer对象中:ser=BookSerializer(data=request.data) 第二步：校验数据：ser.is_valid(): 第三步：保存，ser.save()---》必须重写create，在序列化类中 def create(self, validated_data): book=Book.objects.create(**validated_data) return book 视图类12345678910class BookView(APIView): def post(self,request): # 反序列化,保存---》使用data参数 ser=BookSerializer(data=request.data) # # 校验数据 if ser.is_valid(): # 如果是true表示数据校验通过，通过，就保存 # 如果instance为None，调用save本质会调用create--》父类create直接抛异常，所以我们要重写 ser.save() # 就会保存,重写create方法，如果不重写，我们不知道存到哪个表中 return Response(ser.data) return Response(&#123;&#x27;code&#x27;:101,&#x27;msg&#x27;:&#x27;数据校验失败&#x27;,&#x27;err&#x27;:ser.errors&#125;) 序列化类1234567891011121314151617from rest_framework import serializersfrom .models import Book# drf提供的类：Serializerclass BookSerializer(serializers.Serializer): name = serializers.CharField(max_length=8, min_length=3) price=serializers.CharField() author = serializers.CharField() price_info=serializers.CharField(read_only=True) # 只用来做序列化 def create(self, validated_data): # validated_data校验过后的数据 # 手动存到book表中 book=Book.objects.create(**validated_data) # book=Book.objects.create(name=validated_data.get(&#x27;name&#x27;)) return book # 不要忘记返回book对象 补充国际化123456# 配置文件中改LANGUAGE_CODE = &#x27;zh-hans&#x27;TIME_ZONE = &#x27;Asia/Shanghai&#x27;USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False 4 反序列化之修改序列化类 1234567891011121314151617181920212223242526272829303132class BookSerializer(serializers.Serializer): id = serializers.CharField(read_only=True) # max_length=32,min_length=3 反序列化保存校验数据的时候用 name = serializers.CharField(max_length=8, min_length=3) price = serializers.CharField(required=False) # models中使用了DecimalField，这个位置使用了CharField会把小数类型转成字符串 author = serializers.CharField(required=False) def create(self, validated_data): # validated_data校验过后的数据 # 手动存到book表中 book = Book.objects.create(**validated_data) # book=Book.objects.create(name=validated_data.get(&#x27;name&#x27;)) return book # 不要忘记返回book对象 def update(self, instance, validated_data): # validated_data校验过后的数据,instance 是要修改的对象 instance.name = validated_data.get(&#x27;name&#x27;) instance.price = validated_data.get(&#x27;price&#x27;) instance.author = validated_data.get(&#x27;author&#x27;) instance.save() # 模型对象自带的save，保存到数据库中 return instance # 要忘记返回instance对象 # 局部钩子 # 字段有自己的校验：max_length .... ,再校验，就可以写局部钩子 def validate_name(self, attr): # attr就是前端传入的数据 # 名字不能以sb开头 if attr.startswith(&#x27;sb&#x27;): raise ValidationError(&quot;名字不能以sb开头&quot;) else: return attr # 没有问题，正常返回 视图类 123456789101112131415161718192021222324class BookDetailView(APIView): def get(self, request, pk): book = Book.objects.filter(pk=pk).first() ser = BookSerializer(instance=book) # 如果是单条记录，many不传，就是false return Response(ser.data) def delete(self, request, pk): res = Book.objects.filter(pk=pk).delete() print(res) if res[0] &gt; 0: return Response(&#123;&#x27;code&#x27;: 100, &#x27;msg&#x27;: &#x27;删除成功&#x27;&#125;) else: return Response(&#123;&#x27;code&#x27;: 103, &#x27;msg&#x27;: &#x27;数据不存在&#x27;&#125;) def put(self, request, pk): # 修改：用什么数据，修改哪个对象？ book = Book.objects.filter(pk=pk).first() # 既有instance，又有data，表示修改 ser = BookSerializer(instance=book, data=request.data) if ser.is_valid(): # 重写update方法 ser.save() # 调用save---》内部根据instance判断是触发create还是update return Response(ser.data) return Response(&#123;&#x27;code&#x27;: 102, &#x27;msg&#x27;: &#x27;修改出错&#x27;, &#x27;err&#x27;: ser.errors&#125;) 路由 12345urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;books/&#x27;, views.BookView.as_view()), path(&#x27;books/&lt;int:pk&gt;&#x27;, views.BookDetailView.as_view()),] 4.1 反序列化之局部和全局钩子123456789101112131415161718# 局部钩子# 字段有自己的校验：max_length .... ,再校验，就可以写局部钩子def validate_name(self, attr): # attr就是前端传入的数据 # 名字不能以sb开头 if attr.startswith(&#x27;sb&#x27;): raise ValidationError(&quot;名字不能以sb开头&quot;) else: return attr # 没有问题，正常返回# 先走字段自己规则，再走局部钩子，再走全局钩子# 全局钩子def validate(self, attrs): # attrs校验过后的数据 if attrs.get(&#x27;name&#x27;) == attrs.get(&#x27;author&#x27;): raise ValidationError(&#x27;作者名不能等于书名&#x27;) else: return attrs 4 ModelSerializer模型类序列化器12345678910111213141516# 以后使用ModelSerializer跟表模型做绑定,以后这个用的多，不需要重写update和create方法了class BookSerializer2(serializers.ModelSerializer): class Meta: model = Book # 跟那个表有关系 # fields=&#x27;__all__&#x27; # 所有字段 # id是从表模型中映射过来的，auto，它会不要求你传 # price_info：它不是数据库中字段 # 即便扩写的字段，也要在fields中注册 fields = [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;price&#x27;, &#x27;author&#x27;, &#x27;price_info&#x27;] # 原来的字段参数，通过extra_kwargs传进去 extra_kwargs = &#123; &#x27;name&#x27;: &#123;&#x27;write_only&#x27;: True, &#x27;max_length&#x27;: 8, &#x27;min_length&#x27;: 3&#125; &#125; # 重写字段 # 局部和全局钩子跟之前一样 5 额外添加参数1234567# class BookSerializer2(serializers.ModelSerializer): class Meta: # 原来的字段参数，通过extra_kwargs传进去 extra_kwargs = &#123; &#x27;name&#x27;: &#123;&#x27;write_only&#x27;: True, &#x27;max_length&#x27;: 8, &#x27;min_length&#x27;: 3&#125; &#125; 123451 author单表的5个接口与使用 Serializer和ModelSerializer实现2 book 关联表---》author，publish关联，实现book的5个接口","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"02、序列化与反序列化、drf（介绍、快速使用、CBV源码分析、APIView和Request对象分析）","slug":"drf_day02","date":"2018-10-20T06:04:02.000Z","updated":"2022-05-14T04:31:04.107Z","comments":true,"path":"2018/10/20/drf_day02/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day02/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 前后端开发模式 -混合开发(前后端不分离)--》bbs---》页面渲染是使用模板语法(dtl,jsp--&gt;模板语法,php)--&gt;后端执行--&gt;把页面渲染成纯粹的html，css，js---》直接返回给前端---》浏览器中展示 -项目前端用php写的，后端用python写的---》严重错误 -看到过在html中写php语法--》在后端运行，等同于 dtl -对后端压力比较大---》每次都要在后端渲染完成 -后端人员需要写前端东西 -考你一个问题：写在js中 var name =&#x27;&#123;&#123;cx&#125;&#125;&#x27; 等同于var name = cx 没加引号所以报错 应该是var name = &quot;cx&quot; -前后端分离 -页面渲染前端完成----&gt;js语法--》js的dom操作---》jq就是js的一个库 -前端专门写前端---》html，css，js -后端专门写后端---&gt;java,python,go.... -前端的形式可以是：PC端浏览器，小程序，app---》前后端交互使用json格式 # API接口 -前后端交互的媒介 -咱们自己写的一些后端接口 -第三方服务对外提供的一些接口----》腾讯发送短信---》使用了第三方的API接口 -http地址 # 后端人员要测试接口---》不能只用浏览器---》浏览器只能发送get请求(除非用ajax)--》postman -模拟发送http请求--》指定请求方式，请求地址，请求参数，请求体。。。 HTTP协议： -请求协议 -请求首行（请求方法、请求的url、http协议版本号） 请求头（user-agent、refer、） \\r\\n 请求体（三种方式、urlencoded、formdata、json） -响应协议 响应首行（http协议版本号、状态码、状态码文本描述） 响应头（cookie） \\r\\n 响应体（在浏览器中看到的） # restful规范 -规范前后端交互api接口 -10条---》不同公司有公司自己的一些自由规范 -https -api -v1 -都是用名词，可以复数 -请求方法决定具体操作：get获取数据，delete删除数据 -请求地址中带过滤 ?name=xx -返回中带状态码 http，自定制状态码 -返回中带错误信息 msg err -返回数据中带连接 -返回符合规范：获取所有数据返回列表，单个数据字典，新增返回新增完的，删除返回空文档 1 序列化和反序列化123456789101112api接口开发，最核心最常见的一个过程就是序列化，所谓序列化就是把数据转换格式，序列化可以分两个阶段：# 序列化： 把我们语言识别的数据转换成指定的格式提供给别人。 字典，列表，对象------》json/xml/prop,massagepack---&gt;提供给别人(前端或其他服务)# 反序列化：把别人提供的数据转换/还原成我们需要的格式我们在django中获取到的数据默认是模型对象（qs对象），但是模型对象数据无法直接提供给前端或别的平台使用，所以我们需要把数据进行序列化，变成字符串或者json数据，提供给别人----》序列化过程前端传入到后台的数据---》json格式字符串---》后端存到数据库中，需要转成python中的对象---》把json格式字符串转成python对象存到数据库的过程称为反序列化 2 drf介绍和快速使用12345678910111213141516171819# 原生django，不使用任何其他模块，也可以写出符合resful规范的接口---》写起来麻烦一些# 查询所有图书 地址：127.0.0.1:8080/books 路由：path(&#x27;/books&#x27;,views.books) 视图函数中：通过orm查出所有图书(qs)---&gt;序列化(for循环自己拼成列表套字典[&#123;name:西游记，price:99&#125;,&#123;name:红楼梦，price:99&#125;])----&gt;JsonResponse返回给前端 # drf是django的一个app--》帮助咱们快速在django上写符合restful规范的接口# 安装： pip3 install djangorestframework 注意：django版本 4.x 一般用升级到3.x 或者 2.x drf的最新版本最低支持django 3.x以上---》出一个小问题---》装django 2.x---》当你pip3 install的时候，由于低于2.2不支持最新的drf---》把你老版本的django卸载---》给你装上最新版---》原来写的django项目可能有问题，运行不了 2.2一下---&gt;drf降降版本 3.x----&gt;drf使用最新 Python (3.6, 3.7, 3.8, 3.9, 3.10)Django (2.2, 3.0, 3.1, 3.2, 4.0) 2.1 快速使用12345678910111213# 针对于一个表，需要写那些接口---》5个--》以后看到的所有接口都是这5个的变形 -查询所有---》get-&gt;http://127.0.0.1:8000/books/ -查询一个---》get-&gt;http://127.0.0.1:8000/books/1/ -新增一个---》post-&gt;http://127.0.0.1:8000/books/ body中带数据 -修改-----》put，patch---&gt;实际编码中，基本都用put http://127.0.0.1:8000/books/1/ body体中传入修改的数据 -删除一个---》delete--&gt;http://127.0.0.1:8000/books/1/ # 登陆接口---》本质其实是查询一个# 注册接口----》本质是新增一个# postman测试，地址要严格，斜杠有和没有是有区别的 视图1234567from rest_framework.viewsets import ModelViewSetfrom .models import Book # 模块导入使用相对导入# from app01.models import Book # 使用绝对导入from .serializer import BookSerializerclass BookView(ModelViewSet): queryset = Book.objects.all() serializer_class = BookSerializer 路由123456789from rest_framework.routers import SimpleRouterfrom app01 import viewsrouter = SimpleRouter()router.register(&#x27;books&#x27;, views.BookView, &#x27;books&#x27;)urlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls),]urlpatterns += router.urls 序列化类1234567from .models import Bookfrom rest_framework import serializersclass BookSerializer(serializers.ModelSerializer): class Meta: model = Book fields = &#x27;__all__&#x27; 模型1234class Book(models.Model): name = models.CharField(max_length=32) price = models.DecimalField(decimal_places=2, max_digits=5) author = models.CharField(max_length=32) 3 cbv源码流程分析 （了解）12345678910111213# cbv路由写法：path(&#x27;test/&#x27;, views.TestView.as_view())---》第二个参数是函数内存地址---》as_view()执行完，也是一个内存地址---》闭包函数view的内存地址---》当请求来了，路由匹配成功--》执行view(request)，传入当次请求的request对象----&gt;return self.dispatch(request, *args, **kwargs)---&gt;View类中找dispatch---》如果是get请求就会执行视图类中的get方法，如果是post请求，就会执行视图类的post方法# as_view 类的绑定方法---》View类的方法--》@classonlymethod# dispatch核心代码---》getattr反射---》从当前对象(视图类的对象)---》如果是get请求--》会拿到get方法---》handler就是get方法---》handler(request)本质就是---》get(request)handler = getattr(self, request.method.lower(), self.http_method_not_allowed)return handler(request, *args, **kwargs)# 通过描述符自己写装饰器来装饰类---》完成类似于property，classmethod。。 4 drf之APIView和Request对象分析(了解)123from django.views.generic.base import View # 最真的路径from django.views.generic import View # 因为在generic包的init里注册了from django.views import View # views包的init里注册了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# APIView的执行流程路由 path(&#x27;order/&#x27;, views.OrderView.as_view())---》第二个参数是函数内存地址---》APIView的as_view的执行结果---》本质还是用了View类的as_view内的view闭包函数，去掉了csrf认证----》当请求来了---》触发view闭包函数执行，并且传入request---&gt;调用了self.dispatch--&gt;self是视图类的对象，从OrderView中找dispatch，但是找不到----》父类APIView中有---》本质执行的dispatch是APIView----》# APIView的as_view方法 view = super().as_view(**initkwargs) # 调用APIView的父类(View)的as_view方法 return csrf_exempt(view) # 去掉csrf_exempt的认证,以后只要继承了APIView后，csrf就无效了，无论中间件是否注释掉# APIView的dispatch def dispatch(self, request, *args, **kwargs): # request是新的drf提供的request，它是由老的django的request得到的 # 通过老request，生成一个新request，drf的Request的对象 request = self.initialize_request(request, *args, **kwargs) # 把新的request，放到了视图类对象中 self.request = request try: # 执行了三大认证(认证，权限，频率) self.initial(request, *args, **kwargs) # self.http_method_names是个列表 if request.method.lower() in self.http_method_names: # 原来dispatch的核心代码 handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed # 原来dispatch写的，但是request已经不是老request了，是新的 response = handler(request, *args, **kwargs) # 执行视图函数的方法 except Exception as exc: # 无论在三大认证过程中还是执行视图函数方法过程中，只要抛了异常，都会被捕获到 # 处理全局异常 response = self.handle_exception(exc) self.response = self.finalize_response(request, response, *args, **kwargs) return self.response # APIView执行流程---》 1 包装了新的Request对象，以后视图类中的方法中传入的request对象都是新的 2 在进入视图函数之前，执行了三大认证 3 无论三大认证还是视图函数的方法，执行过程中出了异常，都会被处理掉 # 如何包装的新的requestrequest = self.initialize_request(request, *args, **kwargs)---》APIView的initialize_request---》核心代码from rest_framework.request import Requestreturn Request( request, # 老的request parsers=self.get_parsers(), authenticators=self.get_authenticators(), negotiator=self.get_content_negotiator(), parser_context=parser_context )新的Request中：self._request = request---》新的request._request是老的request新的：&lt;class &#x27;rest_framework.request.Request&#x27;&gt;老的：&lt;class &#x27;django.core.handlers.wsgi.WSGIRequest&#x27;&gt;# 三大认证人如何走的self.initial(request, *args, **kwargs)---》APIView的核心代码： self.perform_authentication(request) # 认证 self.check_permissions(request) #权限 self.check_throttles(request) # 频率 # crsf的局部禁用--》在视图函数上加装饰器---》csrf_exempt装饰器---》装饰器本质就是一个函数@csrf_exempt # 装饰器的@ 是一个语法糖(特殊语法)--&gt;把下面的函数当参数传入装饰器中并且把返回结果赋值给函数名：index=csrf_exempt(index)def index(request) pass跟 csrf_exempt(index) 一毛一样 Request对象分析123456789101112131415# rest_framework.request.Request ---》常用属性和方法request.data # 前端post请求传入的数据---》在老的request.POST--&gt;老的只能处理urlencoded和formdata编码格式，json格式不能处理---》无论前端用什么编码post提交的数据，都从data中获取request.files # 上传的文件对象以后直接使用新的request.method request.path 拿到的就是老的request.method...对象.调用属性或方法会触发 魔法方法 __getattr__原因在于新的request类重写了__getattr__,以后新的request.method用的时候本质就是request._request.method def __getattr__(self, attr): try: return getattr(self._request, attr) # 通过反射去老的里面取 except AttributeError: return self.__getattribute__(attr) # 总结：新的request当老的用即可，只是多了个data前端post请求传入的数据,三种编码格式都可以 12345678910111213141 APIView和Request源码部分---》看看---》步骤写一写2 原来的django的request对象中没有data，写个装饰器，装在视图函数上(中间件)，使得request.data--&gt;无论什么编码格式，post提交数据，data都有值def before(func): def inner(request,*args,**kwargs): request.data=request.POST res=func(request,*args,**kwargs) return res return inner@beforedef test(request): print(request.data) # return HttpResponse(&#x27;ok&#x27;)","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"01、Web应用模式、API接口、接口测试工具postman、restful规范","slug":"drf_day01","date":"2018-10-20T06:04:01.000Z","updated":"2022-05-14T04:29:11.776Z","comments":true,"path":"2018/10/20/drf_day01/","link":"","permalink":"https://chenxiao0629.github.io/2018/10/20/drf_day01/","excerpt":"","text":"1 Web应用模式1234567891011121314# 前后端混合开发 -bbs项目，页面渲染是在后台完成---&gt;render(request,&#x27;index.html&#x27;) -后端人员---》写前端css，js，html# 前后端分离开发---》主流---》前端发展出一些框架(vue,react) -js的dom操作---》html页面--》通过js在页面中插入内容 -bom和dom -不用模板语法渲染页面了----》在前端使用js渲染页面 -页面渲染在前端完成 -以后前端人员只负责写前端 -后端人员只负责写后端 -前端的展现形式---》不一定只是网页，可能是app，小程序 # https://www.cnblogs.com/liuqingzheng/p/10900502.html 2 API接口123456789# api接口：前后端交互的媒介# 接口有的东西 -url地址 -请求方式：get ，post -请求参数：name=&#x27;西游记&#x27; get请求---&gt;127.0.0.1/books?name=&#x27;西游记&#x27; -响应结果 -http响应--》响应状态码--》响应头---》响应体(json) 3 接口测试工具postman123456# 对接口进行测试---》在浏览器中只能发送get请求，发不了post，delete..# 接口测试工具：mac，win，linux都可以# 使用最多的软件：postman ---》后来慢慢收费了---》Postwoman# 下载地址：https://www.getpostman.com/downloads/# 双击就装完了 1234# 前后端交互的编码格式有哪几种？ -urlencoded：正常的post请求提交数据：name=lqz&amp;age=19 -formdata：post请求上传文件:带文件二进制形式 -json：body体中的数据格式为：&#123;&quot;name&quot;:&quot;lqz&quot;,&quot;age&quot;:19&#125;--》用的多 4 restful规范(重要)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 前后端交互使用api接口---》符合某种规范---》restful规范---》写前后端分离的标准# REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征性状态转移）。 它首次出现在2000年Roy Fielding的博士论文中。RESTful是一种定义Web API接口的设计风格，尤其适用于前后端分离的应用模式中# https://api.weibo.com/2/account/get_uid.json# 10条内容---》 -1 数据的安全保障--》通常使用https协议 -2 用api关键字标识接口---》在接口中带api字眼--》让别人一看就知道这是个api接口 -https://api.baidu.com/books -https://127.0.0.1:8080/api/books -3 多版本共存---&gt;在接口地址中带版本号---》 -都留---》尽快升级---》xx年我们就不支持xx以下版本了 -有的人用了老版本app--》老接口v1 -有的人用了新版本app--》新接口v2 -https://api.baidu.com/v1/login -https://api.baidu.com/v2/login -4 数据即是资源，均使用名词(可复数)--》请求地址中尽量不出现动词 -https://api.baidu.com/v1/users # 获取用户，删除用户，新增用户 -5 资源操作由请求方式决定--&gt;get,post,delete ,put,patch -get请求是获取数据 -post请求是新增数据 -delete请求是删除数据 -put请求是修改数据 -patch请求是局部修改数据 -6 请求地址中带过滤条件 -https://api.example.com/v1/zoos?limit=10 # 返回10条数据 -https://api.example.com/v1/books?name=西游记 # 查询名字是西游记的这本书 -7 响应状态码（http的响应状态码，响应体的json数据中带状态码） -http的响应状态码 -1xx：请求正在处理 -2xx：请求成功(200,201) 200和201有什么区别？ -3xx：重定向 (301和302有什么区别) -4xx：客户端错误（404:地址不存在，403：禁止了） -5xx：服务端错误 -响应体中返回json格式数据---》code，status---&gt;也有状态码---》服务端自定义的 -1001 ：用户名错误 -1002 ：没有权限。。 -8 错误处理，应返回错误信息 -返回数据是json格式--》带状态码---》错误信息 &#123; error: &quot;无权限操作&quot; &#125; -9 返回数据格式符合如下规范（大部分公司不按这个） -多条数据返回列表 GET /collection：返回资源对象的列表 [&#123;name:lqz,age:19&#125;,&#123;name:pyy,age:33&#125;] -单条数据返回字典 GET /collection/resource：返回单个资源对象 &#123;name:lqz,age:19&#125; -新增，返回新增的对象---》&#123;name:lqz,age:19&#125; POST /collection：返回新生成的资源对象 -修改，返回修改后的对象--》&#123;name:lqz,age:19&#125; PUT /collection/resource：返回完整的资源对象 -修改，返回修改后的对象--》&#123;name:lqz,age:19&#125; PATCH /collection/resource：返回完整的资源对象 -删除，返回空文档 DELETE /collection/resource：返回一个空文档 --&gt;&#123;code:100,msg:删除成功&#125; -10 返回资源中链接地址 &#123; &quot;id&quot;: 1404376560, &quot;description&quot;: &quot;人生五十年，乃如梦如幻；有生斯有死，壮士复何憾。&quot;, &quot;url&quot;: &quot;http://blog.sina.com.cn/zaku&quot;, &quot;profile_image_url&quot;: &quot;http://tp1.sinaimg.cn/1404376560/50/0/1&quot;, &quot;domain&quot;: &quot;zaku&quot;, &#125; #面试题: http协议版本，你聊聊？ 0.9 1.1 2.0 作业12345# 想写就写，不想写拉倒1 postman安装使用，整理resful规范2 把drf安装上，写出5个接口3 面试题: http协议版本，你聊聊？4 http状态码---》写到你笔记里","categories":[],"tags":[{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"}]},{"title":"14、auth组件（介绍、常用方法、User对象属性、扩展默认的auth_user表）、Django启动流程","slug":"Django_day14","date":"2018-09-20T06:04:14.000Z","updated":"2022-05-14T04:04:26.615Z","comments":true,"path":"2018/09/20/Django_day14/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day14/","excerpt":"","text":"复习1234567891011121314151617181920212223242526272829303132333435363738391 中间件：request对象，response -process_request -返回None，继续往下走 -返回response对象，直接返回 -process_response -处理response -定义一个类，继承MiddlewareMixin -配置文件配置（执行顺序）2 中间件能干什么 -全局的登陆认证 -记录日志（访问日志，登录日志，客户端类型。。。） -对ip地址进行限制（一分钟访问十次） 3 csrf，xsrf:跨站请求伪造 4 django中处理csrf攻击 1 form表单形式 &#123;% csrf_token %&#125; 2 ajax提交：手动传，2种方式 3 ajax提交：放到请求头中 $.ajax(&#123; url: &#x27;/transfer/&#x27;, headers:&#123;&#x27;X-CSRFToken&#x27;:&#x27;sssssss&#x27;,&#x27;name&#x27;:&#x27;lqz&#x27;&#125;, method: &#x27;post&#x27;, data: &#123;to_user: $(&#x27;#id_name&#x27;).val(), money: $(&#x27;#id_money&#x27;).val(),csrfmiddlewaretoken:&#x27;&#123;&#123;csrf_token&#125;&#125;&#x27;&#125;, success: function (data) &#123; console.log(data) &#125; &#125;) 4 请求头中的数据，django如何获取 -request.META.get(&#x27;HTTP_字段名大写&#x27;)5 django的csrf中间件 -全局使用csrf，中间件解开 -局部禁用：在视图函数上加一个装饰器csrf_exempt -全局禁用，中间件加注释 -局部使用：在视图函数上加一个装饰器csrf_protect 1 auth组件介绍12341 django提供的用户认证，创建，修改密码。。。用户相关操作2 不需要创建用户表了，默认带了3 插入数据（创建用户）： python3 manage.py createsuperuser 2 auth组件常用方法12345678910# 1 内置User类方法返回的user对象from django.contrib.models import Useruser_obj = User.objects.createuser(username=&quot;cx&quot;, passowrd=123)# 2 从request拿的user对象def get_user(request): user_obj = request.user# 这两个user对象本质是一样的 2.1 authenticate()12345678#作用提供了用户认证功能，即验证用户名以及密码是否正确，一般需要username 、password两个关键字参数。如果认证成功（用户名和密码正确有效），便会返回一个user对象，否则返回None#使用from django.contrib.auth import authenticateuser = authenticate(username=&#x27;usernamer&#x27;,password=&#x27;password&#x27;) 2.2 login(HttpRequest, user)123456789101112# 作用：该函数接受一个HttpRequest对象，以及一个经过认证的user对象。该函数实现一个用户登录的功能。它本质上会在后端为该用户生成相关session数据，即可以从request.user拿到用户数据#使用登录成功后调用from django.contrib.auth import authenticateuser = authenticate(username=&#x27;usernamer&#x27;,password=&#x27;password&#x27;)if user: login(request, user) 2.3 logout(request)123456789#作用该函数接受一个HttpRequest对象，无返回值。当调用该函数时，当前请求的session信息会全部清除。该用户即使没有登录，使用该函数也不会报错# 使用from django.contrib.auth import logout def logout_view(request): logout(request) 2.4 is_authenticated1234567891011# 作用用来判断当前请求是否通过了认证。# 使用# 视图类中使用，在request.user里if not request.user.is_authenticated():#模板中使用&#123;% if request.user.is_authenticated %&#125; &#123;&#123; request.user.username &#125;&#125; 欢迎你&#123;% else %&#125; &lt;a href=&quot;/auth_login/&quot;&gt;请去登录&lt;/a&gt;&#123;% endif %&#125; 2.5 login_requierd() 装饰器1234567891011#作用auth 给我们提供的一个装饰器工具，用来快捷的给某个视图添加登录校验。#使用from django.contrib.auth.decorators import login_required @login_required(url=&#x27;/login/&#x27;)def my_view(request): ...#也可以在配置文件中配置LOGIN_URL = &#x27;/login/&#x27; # 这里配置成你项目登录页面的路由 2.6 create_user() 内置models的User类（表）1234567# 作用auth 提供的一个创建新用户的方法，需要提供必要参数（username、password）等。# 使用from django.contrib.auth.models import Useruser = User.objects.create_user（username=&#x27;用户名&#x27;,password=&#x27;密码&#x27;,email=&#x27;邮箱&#x27;,...） 2.7 create_superuser() 内置models的User类（表）12345#作用auth 提供的一个创建新的超级用户的方法，需要提供必要参数（username、password）等。# 使用from django.contrib.auth.models import Useruser = User.objects.create_superuser（username=&#x27;用户名&#x27;,password=&#x27;密码&#x27;,email=&#x27;邮箱&#x27;,...） 2.8 check_password(password)123456# 作用auth 提供的一个检查密码是否正确的方法，需要提供当前请求用户的密码。密码正确返回True，否则返回False。# 使用ok = request.user.check_password(&#x27;密码&#x27;) 2.9 set_password(password)12345678#作用auth 提供的一个修改密码的方法，接收 要设置的新密码 作为参数。注意：设置完一定要调用用户对象的save方法！！！# 使用request.user.set_password(password=&#x27;&#x27;) # 只修改了属性、没有更新数据库request.user.save() # 更新数据库 3 User对象的属性1234567from django.contrib.auth.models import UserUser对象属性：username， passwordis_staff ： 用户是否拥有网站的管理权限.如果没有，后台admin登录不进去is_active ：是否允许用户登录, 设置为 False，可以在不删除用户的前提下禁止用户登录。 4 扩展默认的auth_user表123456# 第一种方案： 一对一from django.contrib.auth.models import User class user_detail(models.Model): user=models.OneToOneField(to=User) phone=models.CharField(max_length=32) 123456789101112131415161718192021# 第二种方案，继承AbstractUser类来扩写 class Meta: abstract = True #这个表是个抽象表，只用来继承，不会在数据库生成表 # 使用步骤 -大前提是auth_user表没有创建之前干******* -写一个类，继承AbstractUser -在类中扩写字段(可以重写原来有的字段) class MyAuthUser(AbstractUser): username=models.CharField(max_length=12) phone=models.CharField(max_length=32) -在配置文件中配置******** # 引用Django自带的User表，继承使用时需要设置 AUTH_USER_MODEL = &quot;app01.MyAuthUser&quot; # 如果auth_user表已经有了，还想扩写 -删库 -清空项目中所有migration的记录 -清空源码中admin，auth俩app的migration的记录 作业1231 基于auth继承AbstractUser类，加一个phone字段，实现用户的注册登录，登录成功，在home页面显示用户名，未登录，显示登录注册2 实现修改密码功能3 超级管理员能够禁用户登录 补充1 django启动流程123451 配置文件settings中指定WSGI_APPLICATION = &#x27;day60.wsgi.application&#x27;2 被wsgi服务器管理，一旦有请求进来，会触发application()3 实际触发WSGIHandler类的__call__传入environ, start_response4 把environ包装成request对象，执行中间件，执行路由，执行视图函数，返回response5 最终结束django","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"13、CBV加装饰器、正向代理与反向代理、中间件（介绍、常用内置中间件、自定义中间件）、CSRF_TOKEN跨站请求伪造、Django处理csrf","slug":"Django_day13","date":"2018-09-20T06:04:13.000Z","updated":"2022-05-14T04:02:58.076Z","comments":true,"path":"2018/09/20/Django_day13/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day13/","excerpt":"","text":"复习12345678910111213141516171819202122232425261 forms局部和全局钩子的源码 -is_valid---》self.errors---&gt;self.full_clean()--&gt; self._clean_fields() # 字段自己的校验规则和局部钩子执行 self._clean_form() # 全局钩子执行 2 cookie，session和token3 django中使用cookie -HttpResponse的对象.set_cookie(key,value,expire=30) -request.COOKIES.get() -更新 -HttpResponse的对象.delete_cookie()4 cookie的其他参数 -过期时间 -httponly -path /index 5 session的使用 -request.session[&#x27;name&#x27;]=lqz(原来有，原来没有) -request.session.get(&#x27;name&#x27;) -del request.session[&#x27;name&#x27;] 6 session的其他 -对象的其他方法 -配置：过期时间，sessionid 1 cbv加装饰器12345678总结： 1-cbv加装饰器可以加在类上： @method_decorator(auth,name=&#x27;post&#x27;) #给get请求加装饰器 2-可以加在方法上 @method_decorator(auth) def get(self, request, *args, **kwargs): pass 123456789101112131415161718192021222324def auth(func): def inner(request,*args, **kwargs): #登录校验 if request.session.get(&#x27;is_login&#x27;): res = func(*args, **kwargs) return res else: return redirect(&#x27;/login&#x27;) return innerfrom django.views import Viewfrom django.utils.decorators import method_decorator# @method_decorator(auth,name=&#x27;post&#x27;) #给get请求加装饰器class Index(View): @method_decorator(auth) def get(self, request, *args, **kwargs): return HttpResponse(&#x27;index&#x27;) def post(self, request, *args, **kwargs): return HttpResponse(&#x27;post_index&#x27;) 2 正向代理和反向代理123456正向代理：翻墙反向代理：负载均衡详情见： https://www.cnblogs.com/liuqingzheng/p/10521675.html 3 中间件介绍和常用内置中间件123456中间件与Django中间件： 1 中间件：范围更大 数据库中间件（mycat，分库分表），服务器中间件（tomcat，nginx），消息队列中间件（rabbitmq） 2 django中间件（Middleware）： 介于request与response处理之间的一道处理过程，在全局上改变django的输入与输出 3.1 django在内置中间件123456789101112MIDDLEWARE = [ # 处理session &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;, # 处理是否带斜杠的 &#x27;django.middleware.common.CommonMiddleware&#x27;, # 跨站请求伪造的处理 &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,]# SessionMiddleware源码django.contrib.sessions.middleware.SessionMiddlewareprocess_request(self, request) # 请求来了process_response(self, request, response) # 请求走了会触发 4 自定义中间件4.1 process_request(重点)123456781 请求来了触发它，从上往下依次执行（在setting中中间件注册的位置） def process_request(self, request): 如果返回None，就继续往下走 如果返回四件套之一，直接就回去了 2 在这里面写请求来了的一些判断3 request.META.REMOTE_ADDR #客户端地址4 request.META.HTTP_USER_AGENT # 客户端类型 4.2 process_response（重点）12345671 请求走了，会触发它，从下往上执行 def process_response(self, request, response): print(&#x27;请求走了0000&#x27;) return response #一定要return response 2 在所有的响应中都写入cookie name=lqz3 在所有的响应头中都写入 response[&#x27;x-head&#x27;]=&#x27;xxx&#x27; 4.3 process_view（了解）123Django会在调用视图函数之前调用process_view方法。它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果 1234567891011def process_view(self, request, view_func, view_args, view_kwargs): # view_func 视图函数 # view_args, 位置参数 # view_kwargs 关键字参数 print(&#x27;我是process view&#x27;) # 如果return None，会执行执行视图函数 #手动执行了视图函数 # response=view_func(request,view_args, view_kwargs) # 返回response，视图函数就不执行了 return HttpResponse(&#x27;ddddd&#x27;) 4.4 process_exception（了解）1这个方法只有在视图函数中出现异常了才执行 1234def process_exception(self, request, exception): #记录错误日志 print(exception) print(&#x27;出错了&#x27;) 4.5 process_template_response（了解）1234567891011121314151617该方法对视图函数返回值有要求，必须是一个含有render方法类的对象，才会执行此方法def process_template_response(self,request,response): print(&#x27;我执行了&#x27;) return responseclass Test: def __init__(self,status,msg): self.status=status self.msg=msg def render(self): import json dic=&#123;&#x27;status&#x27;:self.status,&#x27;msg&#x27;:self.msg&#125; return HttpResponse(json.dumps(dic))def index(response): return Test(True,&#x27;测试&#x27;) 5 CSRF_TOKEN跨站请求伪造1234567891011https://www.cnblogs.com/liuqingzheng/p/9505044.html 1 CSRF或者XSRF：跨站请求伪造2 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的3 防范：CSRF攻击防范 -Referer：上一次访问的地址（图片防盗链） https://www.lagou.com/gongsi/ -在请求地址中添加 token 并验证 -在 HTTP 头中自定义属性并验证 -把随机字符串放在请求体中 6 django中处理csrf1234567891011121314151617181920211 中间件不要注释了2 如果是form表单&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &#123;% csrf_token %&#125; &lt;p&gt;给谁转：&lt;input type=&quot;text&quot; name=&quot;to_user&quot; id=&quot;id_name&quot;&gt;&lt;/p&gt; &lt;p&gt;转多少：&lt;input type=&quot;text&quot; name=&quot;money&quot; id=&quot;id_money&quot;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;转账&quot;&gt;&lt;/form&gt;3 如果是ajax提交：两种方案 $.ajax(&#123; url: &#x27;/transfer/&#x27;, method: &#x27;post&#x27;, //data: &#123;to_user: $(&#x27;#id_name&#x27;).val(), money: $(&#x27;#id_money&#x27;).val(),csrfmiddlewaretoken:$(&#x27;[name=&quot;csrfmiddlewaretoken&quot;]&#x27;).val()&#125;, data: &#123;to_user: $(&#x27;#id_name&#x27;).val(), money: $(&#x27;#id_money&#x27;).val(),csrfmiddlewaretoken:&#x27;&#123;&#123;csrf_token&#125;&#125;&#x27;&#125;, success: function (data) &#123; console.log(data) &#125; &#125;) 6.1 cookie的处理123&lt;script src=&quot;/static/jquery.cookie.js&quot;&gt;&lt;/script&gt;var token=$.cookie(&#x27;csrftoken&#x27;) 6.2 csrf放到请求头中123456789101112$.ajax(&#123; url: &#x27;&#x27;, headers:&#123;&#x27;X-CSRFToken&#x27;:token&#125;, type: &#x27;post&#x27;, data: &#123; &#x27;name&#x27;: $(&#x27;[name=&quot;name&quot;]&#x27;).val(), &#x27;password&#x27;: $(&quot;#pwd&quot;).val(), &#125;, success: function (data) &#123; console.log(data) &#125; &#125;) 6.1 全局使用csrf，局部视图函数禁用csrf12345671 在视图函数上加装饰器from django.views.decorators.csrf import csrf_exempt,csrf_protect# 不再检测，局部禁用（前提是全站使用）# @csrf_exempt# 检测，局部使用（前提是全站禁用）@csrf_protectdef csrf_token(request): 作业1234567891011121 通过中间件实现访问控制，未登录用户重定向到登陆，登录用户才能访问home页面2 通过中间件实现用户名，用户ip地址和客户端类型,登录时间记录3 使用bootstrap构建一个table页面，展示2题中记录的数据，支持分页3 301和302有什么区别？http://tools.jb51.net/table/http_status_code扩展（先调研，周末实现）：1 根据客户端类型，判断浏览器类型，按月统计浏览器类型占比，饼形图展示2 按月统计日活用户数，用折线图展示3https://gitee.com/lvyeyou/DaShuJuZhiDaPingZhanShi/tree/master4 图片防盗链","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"12、forms组件源码分析、（cookie、session、token关系与介绍）、Django中cookie与session使用","slug":"Django_day12","date":"2018-09-20T06:04:12.000Z","updated":"2022-05-14T04:01:16.706Z","comments":true,"path":"2018/09/20/Django_day12/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day12/","excerpt":"","text":"复习12345678910111213141516171819202122232425262728291 分页 -django提供的两个类 -Paginator类 -Pager类2 forms组件 -数据校验 -渲染页面 -错误信息 -局部全局钩子 -使用步骤： -写一个类，继承Form类 -写字段，字段参数（限制该字段的长短） -错误信息中文：字段参数 -widget：控制生成标签的属性 -视图函数中： -实例化得到form对象时，把要校验的数据传入 -is_valid():clean_data和errors就有值了 -如果校验通过就存，不通过就给页面提示 -渲染页面 -for循环的方式渲染页面（在标签前后可以再加标签） -局部钩子 -def clean_字段名(self): -校验规则 -如果通过，return 值 -如果不通过，抛异常 -全局钩子（多个字段校验） -def clean(self): -如果通过，return clean_data -如果不通过，抛异常 1 forms组件源码分析1234567891011121314151617181920212223242526272829303132333435363738391 为什么局部钩子要写成 clean_字段名，为什么要抛异常2 入口在 is_valid()3 校验流程 -先校验字段自己的规则（最大，最小，是否必填，是不是合法） -校验局部钩子函数 -全局钩子校验 4 流程 -is_valid()---》return self.is_bound and not self.errors -self.errors：方法包装成了数据数据 -一旦self._errors有值，就不进行校验了（之前调用过了） -self.full_clean()：核心 self._errors = ErrorDict() if not self.is_bound: return self.cleaned_data = &#123;&#125; self._clean_fields() self._clean_form() self._post_clean() -self._clean_fields()：核心代码,局部钩子执行位置 value = field.clean(value)# 字段自己的校验规则 self.cleaned_data[name] = value #把校验后数据放到cleaned_data if hasattr(self, &#x27;clean_%s&#x27; % name): # 判断有没有局部钩子 value = getattr(self, &#x27;clean_%s&#x27; % name)() #执行局部钩子 self.cleaned_data[name] = value #校验通过，把数据替换一下 # 如果 校验不通过，会抛异常，会被捕获，捕获后执行 self.add_error(name, e) - def _clean_form(self):#全局钩子执行位置 def _clean_form(self): try: #如果自己定义的form类中写了clean，他就会执行 cleaned_data = self.clean() except ValidationError as e: self.add_error(None, e) 2 cookie，session，token扫盲123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581 cookie:是保存到客户端浏览器上的键值对 -如果不加密，是不安全的（可能被窃取，篡改） 2 session:保存在服务端的键值对 -用户登录后，给用户分配一个随机字符串（会话标识：session id），用户存到cookie中 -在服务端以刚刚随机字符串为key，value是字典，放用户信息 3 token：三段式(jwt:json web token)(服务端不存了) &#123;公司信息。。&#125;.&#123;&quot;name&quot;:&quot;cx&quot;,&quot;id&quot;:10&#125;.asdfasasfxcvnwoi 发展史：1. 很久以前，网站都是静态的，eg: 新闻类，博客类 # 静态网站不需要登录 2. 随着发展，后续诞生了支付宝，购物网站... # 动态网站需要登录 3. HTTP协议的特点： 3.1 无状态 诞生了保存用户数据的cookie，session，token4. cookie介绍 &#x27;&#x27;&#x27; cookie把数据保存在浏览器上，以登录功能为例，cookie的工作原理 当用户第一次登录成功之后，django后端把用户数据保存在浏览器上，浏览器会自动把用户数据提交到django后端，django接收传过来的用户信息，再次做验证，如果正确，则正常登录 &#x27;&#x27;&#x27; # 用户名和密码存在浏览器上，不安全5. 为了解决浏览器数据不安全问题，诞生了session &#x27;&#x27;&#x27; session解决的是安全问题，把数据保存在后端，在django中，session把数据保存在数据库中（默认保存的）,session会把数据保存在django生成的django_session表中、 工作原理： 当用户第一次登录成功之后，django会自动生成一个随机字符串，与用户的真实信息做一个对应： 随机字符串1：用户信息1 随机字符串2：用户信息2 随机字符串3：用户信息3 django会把随机字符串返回给浏览器，说白了，把随机字符串保存在cookie里了，当用户再次进入网站的时候，浏览器会自动把随机字符串提交过来，django会拿着随机字符串去django_session表中查找对应的信息，如果有，则说明已经登录了，如果没有，说明没有登录 &#x27;&#x27;&#x27;6. session是基于cookie工作的？正确7. 如果用户主动进制了cookie，那么，session就一定不能用了？不是 7.1 把随机字符串以参数的形式提交到django 7.2 把数据放到请求头中 总结： 1. cookie的数据保存在浏览器 2. session的数据保存在数据库，session的保存位置是可以更改的： 2.1 文件 2.2 数据库 2.3 redis 2.4 memcache 2.5 消息队列 3. 专业的消息队列工具： 3.1 kafka 3.2 rabbitmq 3.3 HTTPsqs 4. session是基于cookie工作的 3 django中cookie 的使用12345678910111213141516171819202122231 设置cookie #四件套之一 obj.set_cookie(&#x27;key&#x27;,&#x27;value&#x27;)2 获取cookie request.COOKIES.get(&#x27;key&#x27;)3 更新cookie#四件套之一 obj.set_cookie(&#x27;key&#x27;,&#x27;value&#x27;)4 删除cookie obj.delete_cookie(&#x27;is_login&#x27;) 5 cookie的过期时间 -浏览器会管理cookie，到时间，它会自动删除，10s过期 -obj.set_cookie(&#x27;key&#x27;,&#x27;value&#x27;,expires=10) -如果不写，关闭浏览器，cookie就失效了 -obj.set_cookie(&#x27;key&#x27;,&#x27;value&#x27;) 6 对cookie进行加盐 obj.set_signed_cookie(&#x27;nb&#x27;,&#x27;yes&#x27;,&#x27;123&#x27;,expires=1000) # salt为123，第三个参数 7 获取加盐的cookie nb=request.get_signed_cookie(&#x27;nb&#x27;,salt=&#x27;123&#x27;) 4 django中session的使用12345678910111213141516171819201 设置session request.session[&#x27;name&#x27;]=&#x27;cx&#x27; request.session[&#x27;is_login&#x27;] = True &#x27;&#x27;&#x27; 1 生成一个随机字符串afdsfdasfs,如果数据库有，就是更新操作，没有就新建 2 把随机字符串放到cookie中：obj.set_cookie(&#x27;sessionid&#x27;,&#x27;afdsfdasfs&#x27;) 3 把name=cx 放到django_session表中 session_key session_data date afdsfdasfs &#123;name:&#x27;cx&#x27;,is_login:True&#125; 时间 &#x27;&#x27;&#x27;2 获取session name=request.session.get(&#x27;name&#x27;) is_login=request.session.get(&#x27;is_login&#x27;)3 更新cookie#四件套之一 request.session[&#x27;name&#x27;]=&#x27;cx&#x27;4 删除cookie del request.session[&#x27;name&#x27;] request.session.delete() # 删除数据库 request.session.flush() # cookie和数据库都删 5 cookie，session其他了解知识5.1 cookie的其他参数123456789101112131415key, 键value=’’, 值max_age=None, 超时时间 cookie需要延续的时间（以秒为单位）如果参数是\\ None`` ，这个cookie会延续到浏览器关闭为止expires=None, 超时时间(IE requires expires, so set it if hasn’t been already.)path=&#x27;/&#x27;, Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问，浏览器只会把cookie回传给带有该路径的页面，这样可以避免将cookie传给站点中的其他的应用。domain=None, Cookie生效的域名 你可用这个参数来构造一个跨站cookie。如， domain=”.example.com”所构造的cookie对下面这些站点都是可读的：www.example.com 、 www2.example.com 和an.other.sub.domain.example.com 。如果该参数设置为 None ，cookie只能由设置它的站点读取secure=False, 浏览器将通过HTTPS来回传cookiehttponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 5.2 session的其他方法12345678910111213141516171819202122232425262728293031323334353637383940# session继承了字典，所以字典的方法session都能用# 获取、设置、删除Session中数据request.session[&#x27;k1&#x27;]request.session.get(&#x27;k1&#x27;,None)request.session[&#x27;k1&#x27;] = 123request.session.setdefault(&#x27;k1&#x27;,123) # 存在则不设置del request.session[&#x27;k1&#x27;]# 所有 键、值、键值对request.session.keys()request.session.values()request.session.items()request.session.iterkeys()request.session.itervalues()request.session.iteritems()# 会话session的key(随机字符串)request.session.session_key# 将所有Session失效日期小于当前日期的数据删除request.session.clear_expired()# 检查会话session的key在数据库中是否存在request.session.exists(&quot;session_key&quot;)# 删除当前会话的所有Session数据(只删数据库)request.session.delete() # 删除当前的会话数据并删除会话的Cookie（数据库和cookie都删）。request.session.flush() 这用于确保前面的会话数据不可以再次被用户的浏览器访问# 设置会话Session和Cookie的超时时间request.session.set_expiry(value) * 如果value是个整数，session会在些秒数后失效。 * 如果value是个datatime或timedelta，session就会在这个时间后失效。 * 如果value是0,用户关闭浏览器session就会失效。 * 如果value是None,session会依赖全局session失效策略。 5.3 session的其他配置(配置文件中)12345678910111213141516171819202122232425261. 数据库SessionSESSION_ENGINE = &#x27;django.contrib.sessions.backends.db&#x27; # 引擎（默认）2. 缓存SessionSESSION_ENGINE = &#x27;django.contrib.sessions.backends.cache&#x27; # 引擎SESSION_CACHE_ALIAS = &#x27;default&#x27; # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置3. 文件SessionSESSION_ENGINE = &#x27;django.contrib.sessions.backends.file&#x27; # 引擎SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库SESSION_ENGINE = &#x27;django.contrib.sessions.backends.cached_db&#x27; # 引擎5. 加密Cookie SessionSESSION_ENGINE = &#x27;django.contrib.sessions.backends.signed_cookies&#x27; # 引擎其他公用设置项：SESSION_COOKIE_NAME ＝ &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH ＝ &quot;/&quot; # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 60 * 60 * 24 * 7 * 2 # Session的cookie失效日期（2周）（默认）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认） 补充121 方法和函数 -绑定给对象的方法，如果类来调用，它就是普通函数，有几个值就传几个值 2 如何看源码2.1 快速定位到当前py文件 2.2 查看当前py文件中有哪些类、哪些方法 作业必写： 1 登录功能，如果登录成功往cookie中写入用户名和登录成功的状态标志 2 访问order页面，如果登录了，可以正常显示，如果没登录，重定向到登陆页面 3 基于session的登陆认证装饰器 ​ -只要登录了能访问home，order地址 ​ -如果没有登录，都重定向到登陆 扩展作业： 1 什么是集群，什么是分布式 3 什么是正向代理，什么是反向代理 2 内网穿透 4 csrf：跨站请求伪造","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"11、分页器终极用法、forms组件（检验字段、渲染标签、渲染错误信息、参数配置、全局钩子、局部钩子）","slug":"Django_day11","date":"2018-09-20T06:04:11.000Z","updated":"2022-05-14T03:59:07.894Z","comments":true,"path":"2018/09/20/Django_day11/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day11/","excerpt":"","text":"复习12345678910111213141516171 ajax $.ajax(&#123; url:&#x27;/test/&#x27;, method:&#x27;get/post&#x27;, contentType:&#x27;application/json&#x27;, //processData:false //contentType:false data:json格式字符串，字典对象，formdata对象, success:function (data)&#123; //data的类型取决于，后端返回时指定的响应类型 ... &#125; &#125;) 2 上传文件（form表单，ajax）3 提交json格式，后端无论是什么格式，都从request.data中取值4 登录注册功能 1 分页器终极用法1.1 后端12345678910111213141516171819202122def books_page(request): current_num = int(request.GET.get(&#x27;page_num&#x27;, 1)) book_list = models.Books.objects.all() paginator = Paginator(book_list, 20) try: page = paginator.page(current_num) except Exception as e: current_num = 1 page = paginator.page(current_num) if paginator.num_pages &gt; 11: if current_num - 5 &lt; 1: page_range = range(1, 12) elif current_num + 5 &gt; paginator.num_pages: page_range = range(paginator.num_pages - 10, paginator.num_pages + 1) else: page_range = range(current_num - 5, current_num + 6) else: page_range = paginator.page_range return render(request, &#x27;book_page.html&#x27;, locals()) 1.2 前端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;/static/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/static/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-8 col-md-offset-2&quot;&gt; &lt;div class=&quot;panel panel-success&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;图书列表展示&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;table class=&quot;table table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;出版社&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for book in page.object_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; book.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.price &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.publish &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;div class=&quot;text-center&quot;&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &#123;% if page.has_previous %&#125; &lt;li&gt; &lt;a href=&quot;/books_page/?page_num=&#123;&#123; page.previous_page_number &#125;&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=&quot;disabled&quot;&gt; &lt;a href=&quot;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &#123;% for foo in page_range %&#125; &#123;% if current_num == foo %&#125; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/books_page/?page_num=&#123;&#123; foo &#125;&#125;&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=&quot;/books_page/?page_num=&#123;&#123; foo &#125;&#125;&quot;&gt;&#123;&#123; foo &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if page.has_next %&#125; &lt;li&gt; &lt;a href=&quot;/books_page/?page_num=&#123;&#123; page.next_page_number &#125;&#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=&quot;disabled&quot;&gt; &lt;a href=&quot;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2 forms组件之校验字段123456# 第一步：定义一个类,继承forms.Form# 第二步：在类中写字段，要校验的字段，字段属性就是校验规则# 第三步：实例化得到一个Form对象，把要校验的数据传入# 第四步：调用register_form.is_valid()校验，校验通过就是True# 第五步：校验通过有register_form.cleaned_data# 第六步：校验不通过 register_form.errors 12345678910111213141516171819202122#定义类from django import formsfrom django.forms import widgetsfrom django.core.exceptions import ValidationErrorclass RegisterForm(forms.Form): name = forms.CharField(max_length=8, min_length=3, label=&#x27;用户名&#x27;) password = forms.CharField(max_length=8, min_length=3, label=&#x27;密码&#x27;) re_password = forms.CharField(max_length=8, min_length=3, label=&#x27;确认密码&#x27;) email = forms.EmailField(label=&#x27;邮箱&#x27;) #在视图中使用register_form = RegisterForm(request.POST)if register_form.is_valid(): # 校验通过，存 # 取出校验通过的数据 print(&#x27;校验通过&#x27;) print(register_form.cleaned_data)else: # 校验不通过 print(&#x27;校验不通过&#x27;) print(register_form.errors) 3 forms组件之渲染标签3.1 渲染方式一123456789&lt;h2&gt;通过form自动渲染一&lt;/h2&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;p&gt;用户名 &#123;&#123; form.name &#125;&#125;&lt;/p&gt; &lt;p&gt;密码 &#123;&#123; form.password &#125;&#125;&lt;/p&gt; &lt;p&gt;确认密码 &#123;&#123; form.re_password &#125;&#125;&lt;/p&gt; &lt;p&gt;邮箱 &#123;&#123; form.email &#125;&#125;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 3.2 渲染方式二1234567891011121314151617&lt;h2&gt;通过form自动渲染二(基本用这种)&lt;/h2&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; novalidate&gt; &#123;% for item in form %&#125; &lt;div class=&quot;form-group&quot;&gt; &lt;p&gt;&#123;&#123; item.label &#125;&#125;&#123;&#123; item &#125;&#125; &lt;span style=&quot;color: red&quot;&gt;&#123;&#123; item.errors.0 &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;span style=&quot;color: red&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 3.3 渲染方式三1234567&lt;h2&gt;通过form自动渲染三&lt;/h2&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &#123;&#123; form.as_p &#125;&#125; &#123;# &#123;&#123; form.as_table &#125;&#125;#&#125; &#123;# &#123;&#123; form.as_ul &#125;&#125;#&#125;&lt;/form&gt; 4 forms组件之渲染错误信息4.1 前端1234567891011121314151617&lt;h2&gt;通过form自动渲染二(基本用这种)&lt;/h2&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; novalidate&gt; &#123;% for item in form %&#125; &lt;div class=&quot;form-group&quot;&gt; &lt;p&gt;&#123;&#123; item.label &#125;&#125;&#123;&#123; item &#125;&#125; &lt;span style=&quot;color: red&quot;&gt;&#123;&#123; item.errors.0 &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;span style=&quot;color: red&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 4.3 后端1234567891011121314151617from django import formsfrom django.forms import widgetsfrom django.core.exceptions import ValidationErrorclass RegisterForm(forms.Form): name = forms.CharField(max_length=8, min_length=3, label=&#x27;用户名&#x27;, error_messages=&#123;&#x27;max_length&#x27;: &#x27;最长为8&#x27;, &#x27;min_length&#x27;: &#x27;最短为3&#x27;&#125;, widget=widgets.TextInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) password = forms.CharField(max_length=8, min_length=3, label=&#x27;密码&#x27;, error_messages=&#123;&#x27;required&#x27;: &#x27;该字段必填&#x27;&#125;, widget=widgets.PasswordInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) re_password = forms.CharField(max_length=8, min_length=3, label=&#x27;确认密码&#x27;, widget=widgets.PasswordInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) email = forms.EmailField(label=&#x27;邮箱&#x27;, error_messages=&#123;&#x27;required&#x27;: &#x27;必填&#x27;, &#x27;invalid&#x27;: &#x27;必须是邮箱格式&#x27;&#125;, widget=widgets.TextInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) 5 forms组件参数配置1name = forms.CharField(max_length=8, min_length=3, label=&#x27;用户名&#x27;,error_messages=&#123;&#x27;max_length&#x27;: &#x27;最长为8&#x27;, &#x27;min_length&#x27;: &#x27;最短为3&#x27;&#125;,widget=widgets.TextInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) 6 forms组件全局钩子，局部钩子(总代码)6.1 后端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from django import formsfrom django.forms import widgetsfrom django.core.exceptions import ValidationErrorclass RegisterForm(forms.Form): name = forms.CharField(max_length=8, min_length=3, label=&#x27;用户名&#x27;, error_messages=&#123;&#x27;max_length&#x27;: &#x27;最长为8&#x27;, &#x27;min_length&#x27;: &#x27;最短为3&#x27;&#125;, widget=widgets.TextInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) password = forms.CharField(max_length=8, min_length=3, label=&#x27;密码&#x27;, error_messages=&#123;&#x27;required&#x27;: &#x27;该字段必填&#x27;&#125;, widget=widgets.PasswordInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) re_password = forms.CharField(max_length=8, min_length=3, label=&#x27;确认密码&#x27;, widget=widgets.PasswordInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) email = forms.EmailField(label=&#x27;邮箱&#x27;, error_messages=&#123;&#x27;required&#x27;: &#x27;必填&#x27;, &#x27;invalid&#x27;: &#x27;必须是邮箱格式&#x27;&#125;, widget=widgets.TextInput(attrs=&#123;&#x27;class&#x27;:&#x27;form-control&#x27;&#125;)) def clean_name(self):#name字段的局部钩子 # 校验名字不能以sb开头 name=self.cleaned_data.get(&#x27;name&#x27;) if name.startswith(&#x27;sb&#x27;): # 校验不通过，必须抛异常， raise ValidationError(&#x27;不能以sb开头&#x27;) else:#校验通过，返回name对应的值 return name def clean(self): # 全局钩子 password=self.cleaned_data.get(&#x27;password&#x27;) re_password=self.cleaned_data.get(&#x27;re_password&#x27;) if re_password==password: #校验通过 return self.cleaned_data else: raise ValidationError(&#x27;两次密码不一致&#x27;)from app01 import modelsdef register(request): if request.method == &#x27;GET&#x27;: # 生成一个空form对象 register_form = RegisterForm() return render(request, &#x27;register.html&#x27;, &#123;&#x27;form&#x27;: register_form&#125;) else: # 实例化得到对象，传入要校验的数据 # register_form=RegisterForm(data=request.POST) register_form = RegisterForm(request.POST) if register_form.is_valid(): # 校验通过，存 # 取出校验通过的数据 print(&#x27;校验通过&#x27;) print(register_form.cleaned_data) register_form.cleaned_data.pop(&#x27;re_password&#x27;) models.User.objects.create(**register_form.cleaned_data) return HttpResponse(&#x27;ok&#x27;) else: # 校验不通过 print(&#x27;校验不通过&#x27;) print(register_form.errors) error=register_form.errors.get(&#x27;__all__&#x27;)[0] print(type(register_form.errors.as_json)) from django.forms.utils import ErrorDict # name_error=register_form.errors.get(&#x27;name&#x27;)[0] return render(request, &#x27;register.html&#x27;, &#123;&#x27;form&#x27;: register_form,&#x27;error&#x27;:error&#125;) 6.2 前端1234567891011121314151617&lt;h2&gt;通过form自动渲染二(基本用这种)&lt;/h2&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; novalidate&gt; &#123;% for item in form %&#125; &lt;div class=&quot;form-group&quot;&gt; &lt;p&gt;&#123;&#123; item.label &#125;&#125;&#123;&#123; item &#125;&#125; &lt;span style=&quot;color: red&quot;&gt;&#123;&#123; item.errors.0 &#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;span style=&quot;color: red&quot;&gt;&#123;&#123; error &#125;&#125;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 作业1 建个图书表，插入100条数据，用bootstrap做分页（终极方法） 2 写一个注册功能（用户名，密码，确认密码，邮箱），使用forms渲染页面（bootstrap），保证不能以sb开头，并且用户名如果存在，提示用户已存在，邮箱必须是邮箱格式，用户名必须大于3，小于8，用户名必须大于4，小于9，错误信息也是中文，如果出错，渲染在标签后 扩展作业1231 form.errors对象的类中有那几个方法，分别有什么作业 from django.forms.utils import ErrorDict2 源码中，找为什么局部钩子得那么写，为什么全局钩子会那么写","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"10、Ajax发送post请求、上传文件（form、Ajax）、Ajax上传json格式、django内置序列化、分页器","slug":"Django_day10","date":"2018-09-20T06:04:10.000Z","updated":"2022-05-14T03:57:46.852Z","comments":true,"path":"2018/09/20/Django_day10/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day10/","excerpt":"","text":"复习123456789101112131415161718192021222324251 图书管理系统编辑功能2 常用和非常用字段3 字段参数4 字段关系：to ,to_fileds,related_name,related_query_name,on_delete ,db_constraint5 第三张表建立的三种方式 -纯手动建立（不使用manytomany） -自动创建第三张表 -手动创建第三张表，使用manytomany（多对多api用不了了）6 Meta元信息 7 原生sql8 orm框架（了解） -python：django的orm，sqlalchemy（独立使用，集成到flask） -go：beego自带的orm框架，gorm -java：mybatis，Hibernate9 ajax：js跟后端交互 -异步 -局部刷新 -原生js写（麻烦，兼容浏览器） -jq的ajax -axios 1 ajax发送post请求12345678910111213141 大坑 -如果在form表单中，写button和input是submit类型，会触发form表单的提交 -如果不想触发： -不写在form表单中 -使用input，类型是button 2 坑 -后端响应格式如果是：html/text格式，ajax接收到数据后需要自己转成对象 -后端响应格式是：json，ajax接收到数据后会自动转成对象 -总结：后端返回数据，统一都用JsonResponse、 3 坑 -如果使用了ajax，后端就不要返回rediret，render，HttpResponse -直接返回JsonResponse 1.1 登录功能前端12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; 用户名：&lt;input type=&quot;text&quot; id=&quot;id_name&quot;&gt;&lt;/p&gt; &lt;p&gt; 密码：&lt;input type=&quot;password&quot; id=&quot;id_password&quot;&gt;&lt;/p&gt; &lt;button id=&quot;id_btn&quot;&gt;提交&lt;/button&gt; &lt;span class=&quot;error&quot; style=&quot;color: red&quot;&gt;&lt;/span&gt;&lt;/body&gt; &lt;script&gt; $(&#x27;#id_btn&#x27;).click(function () &#123; $.ajax(&#123; url: &#x27;/login/&#x27;, method: &#x27;post&#x27;, data: &#123;username: $(&#x27;#id_name&#x27;).val(), password: $(&#x27;#id_password&#x27;).val()&#125;, success: function (data) &#123; //res=JSON.parse(data) //console.log(data) //console.log(res) // data 现在是对象类型 if(data.status==100)&#123; //登录成功，重定向到百度，前端重定向 location.href=&#x27;http://www.baidu.com&#x27; &#125;else &#123; //登录失败 //$(&#x27;.error&#x27;).html(data.msg).css(&#123;&#x27;color&#x27;:&#x27;red&#x27;&#125;) $(&#x27;.error&#x27;).html(data.msg) &#125; &#125;, error: function (data) &#123; console.log(data) &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html&gt; 1.2 登录功能后端1234567891011121314151617181920212223242526272829from django.shortcuts import render,redirect,HttpResponsefrom django.http import JsonResponse# Create your views here.from app01 import modelsimport jsondef login(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;login.html&#x27;) # elif request.method==&#x27;POST&#x27;: elif request.is_ajax(): response=&#123;&#x27;status&#x27;:100,&#x27;msg&#x27;:None&#125; name=request.POST.get(&#x27;username&#x27;) password=request.POST.get(&#x27;password&#x27;) user=models.User.objects.filter(name=name,password=password).first() if user: # 用户名和密码都对了 # return redirect(&#x27;&#x27;) 出错 response[&#x27;msg&#x27;]=&quot;登录成功&quot; else: response[&#x27;status&#x27;]=101 response[&#x27;msg&#x27;] = &quot;用户名或密码错误&quot; # return HttpResponse(json.dumps(response)) return JsonResponse(response) # return redirect(&#x27;http://www.baidu.com&#x27;) # return render(request,&#x27;login.html&#x27;) 1.3 登录功能路由1url(r&#x27;^login/&#x27;, views.login), 1.4 登录功能模型类1234567from django.db import models# Create your models here.class User(models.Model): name=models.CharField(max_length=32) password=models.CharField(max_length=32) 2 上传文件（ajax和form两种方式）123456789101112131415161 http --post--请求，有编码格式，主流有三种 -urlencoded ：默认的----》从request.POST取提交的数据 -form-data ：上传文件的----》从request.POST取提交的数据，request.FILES中取文件 -json ：ajax发送json格式数据-----》request.POST取不出数据了 2 使用ajax和form表单，默认都是urlencoded格式3 如果上传文件：form表单指定格式,ajax要使用Formdata对象4 如果编码方式是urlencoded格式，放到body体中数据格式如下 username=lqz&amp;password=123 5 如果是formdata编码格式，body体中是：两部分，数据和文件 6 如果是json格式，body体中的格式是：就是json格式字符串 -注意：注意：注意：如果这种格式，request.POST取不到值了 2.1 form表单上传文件123456&lt;h1&gt;form表单上传文件&lt;/h1&gt;&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;p&gt;用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;/p&gt; &lt;p&gt;文件：&lt;input type=&quot;file&quot; name=&quot;myfile&quot;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 2.2 ajax 上传文件123456789101112131415161718192021222324252627282930&lt;h1&gt;ajax上传文件&lt;/h1&gt;&lt;p&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;id_name&quot;&gt;&lt;/p&gt;&lt;p&gt;文件：&lt;input type=&quot;file&quot; id=&quot;id_myfile&quot;&gt;&lt;/p&gt;&lt;button id=&quot;id_btn&quot;&gt;提交&lt;/button&gt;&lt;script&gt; $(&#x27;#id_btn&#x27;).click(function () &#123; //如果要上传文件，需要借助于一个js的FormData对象 var formdata = new FormData() //实例化得到一个FormData对象 formdata.append(&#x27;name&#x27;, $(&#x27;#id_name&#x27;).val()) //追加了一个name对应填入的值 //能追加文件 var file = $(&#x27;#id_myfile&#x27;)[0].files[0] formdata.append(&#x27;myfile&#x27;, file) $.ajax(&#123; url: &#x27;file_upload&#x27;, method: &#x27;post&#x27;, //上传文件，一定要注意如下两行 processData: false, //不预处理数据， contentType: false, //不指定编码格式，使用formdata对象的默认编码就是formdata格式 data: formdata, success: function (data) &#123; console.log(data) &#125; &#125;) &#125;)&lt;/script&gt; 2.3 后端12345678910111213def file_upload(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;file_upload.html&#x27;) else: name=request.POST.get(&#x27;name&#x27;) myfile=request.FILES.get(&#x27;myfile&#x27;) print(type(myfile)) # 查看类型 from django.core.files.uploadedfile import InMemoryUploadedFile with open(myfile.name,&#x27;wb&#x27;) as f: for line in myfile: f.write(line) return HttpResponse(&#x27;上传成功&#x27;) 2.4 路由1url(r&#x27;^file_upload/&#x27;, views.file_upload), 3 ajax上传json格式3.1 前端1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;ajax提交json格式&lt;/h1&gt;&lt;p&gt;用户名: &lt;input type=&quot;text&quot; id=&quot;id_name&quot;&gt;&lt;/p&gt;&lt;p&gt;密码: &lt;input type=&quot;password&quot; id=&quot;id_password&quot;&gt;&lt;/p&gt;&lt;button id=&quot;id_button&quot;&gt;提交&lt;/button&gt;&lt;/body&gt;&lt;script&gt; $(&#x27;#id_button&#x27;).click(function () &#123; $.ajax(&#123; url: &#x27;/ajax_json/&#x27;, method: &#x27;post&#x27;, contentType: &#x27;application/json&#x27;, //指定编码格式 data: JSON.stringify(&#123;name:$(&#x27;#id_name&#x27;).val(),password:$(&#x27;#id_password&#x27;).val()&#125;), //json格式字符串 success: function (data) &#123; console.log(data) &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html&gt; 3.2 后端1234567891011121314151617181920def ajax_json(request): if request.method==&#x27;GET&#x27;: return render(request,&#x27;ajax_json.html&#x27;) else: # json格式，从POST中取不出来 name=request.POST.get(&#x27;name&#x27;) print(type(request.POST)) # from django.http.request import QueryDict print(name) # 在body体中，b格式 request.data=json.loads(request.body) name=request.data.get(&#x27;name&#x27;) password=request.data.get(&#x27;password&#x27;) print(name) print(password) return HttpResponse(&#x27;ok&#x27;) 4 django内置序列化（了解）把对象转成json格式字符串，django内置的不好用，字段不能控制 目前阶段，要做序列化，for循环拼列表套字典 4.1 后端12345def test(request): user_list = models.User.objects.all() ret = serializers.serialize(&quot;json&quot;, user_list) return HttpResponse(ret) 4.2 路由1url(r&#x27;^test/&#x27;, views.test), 5 分页器的使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546##############分页器###批量插入数据# def books_page(request):# # 第一种方案，每循环依次，操作一下数据库，性能低# # for i in range(1000):# # book=models.Books.objects.create(name=&#x27;图书%s&#x27;%i,price=i+10,publish=&#x27;东京出版社&#x27;)# ## # 第二种方案，批量插入# book_list=[]# for i in range(1000):# book=models.Books(name=&#x27;图书%s&#x27;%i,price=i+10,publish=&#x27;东京出版社&#x27;)# book_list.append(book)## models.Books.objects.bulk_create(book_list,batch_size=100)### return HttpResponse(&#x27;ok&#x27;)from django.core.paginator import Paginatordef books_page(request): book_list=models.Books.objects.all() paginator=Paginator(book_list,10) # Paginator对象的属性 print(paginator.count) # 数据总条数 print(paginator.num_pages) # 总页数 print(paginator.per_page) # 每页显示条数 print(paginator.page_range) # range(1, 101) print(paginator.page(1)) # Page对象的属性和方法 # has_next 是否有下一页 # next_page_number 下一页页码 # has_previous 是否有上一页 # previous_page_number 上一页页码 # object_list 分页之后的数据列表 # number 当前页 page=paginator.page(2) print(page.has_next()) print(page.next_page_number()) print(page.has_previous()) print(page.previous_page_number()) print(page.object_list) print(page.number) return render(request,&#x27;book_page.html&#x27;,locals()) 作业1 使用ajax发送post请求，完成注册功能，注册成功，跳转到登陆，登陆成功跳转到百度 2 使用ajax上传文件，保存到项目路径的media路径下（登录成功才能上传文件） 3 使用ajax上传json格式数据，写一个装饰器，实现不论前端以什么格式传递数据，我从视图函数中都从request.data中取值（POST的数据） 补充1234json.loads(b&#x27;dfdasfda&#x27;)问题：json可以直接loads bytes格式吗？ -3.5之前不可以 -3.6以后可以","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"09、图书管理系统图书修改、orm常用字段（种类、参数、关系）、手动创建第三张表、Meta元信息、原生sql、Django与ajax","slug":"Django_day09","date":"2018-09-20T06:04:09.000Z","updated":"2022-05-14T03:56:28.229Z","comments":true,"path":"2018/09/20/Django_day09/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day09/","excerpt":"","text":"复习123456789101112131415161718192021221 分组查询 -把同一类归为一组，然后使用聚合函数操作 -如果是多表，把连个表连起来，再分组，再聚合 -取的字段必须是分组字段或者聚合函数的字段 -总结： -annotate(聚合函数) -values在前，表示分组字段 -values在后，表示取字段 -filter在前，表示where条件 -filter在后，表示having条件2 wsgi，uWSGI，uwsgi，cgi，fastcgi3 前后端开发模式 -动态网站和静态网站 -前后端分离：后端只写后端，返回json格式字符串，vue，react。。 -前后端混合开发：模板，dtl（模板语法），jsp，php 4 图书管理系统 -后端是django+mysql+bootstrap （主机管理系统，人事管理系统，文档分享平台） -图书增删查改 -增，删，查 -出版社的增删查改 -作者的增删查改 1 图书管理系统图书修改1.1 后端views12345678910111213141516171819202122232425def update_book(request): if request.method==&#x27;GET&#x27;: # 把这本书取出来，需要书的id号 book_id=request.GET.get(&#x27;id&#x27;) book=models.Book.objects.get(pk=book_id) authors=models.Author.objects.all() publishs=models.Publish.objects.all() return render(request,&#x27;update_book.html&#x27;,locals()) else: # 几种方案 # 第一种方案 # book_id = request.POST.get(&#x27;id&#x27;) # 第二种方案 book_id = request.GET.get(&#x27;id&#x27;) data = request.POST authors = request.POST.getlist(&#x27;authors&#x27;) name = request.POST.get(&#x27;name&#x27;) price = request.POST.get(&#x27;price&#x27;) pub_date = request.POST.get(&#x27;pub_date&#x27;) publish = request.POST.get(&#x27;publish&#x27;) book_queryset=models.Book.objects.filter(pk=book_id) res=book_queryset.update(name=name,price=price,pub_date=pub_date,publish_id=publish) book_queryset.first().authors.set(authors) return redirect(&#x27;/book_list/&#x27;) 1.2 路由1url(r&#x27;^update_book/$&#x27;, views.update_book), 1.3 前端模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;修改图书&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;/static/jquery-3.3.1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/static/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt; &lt;div class=&quot;panel panel-primary&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt; &lt;h3 class=&quot;panel-title&quot;&gt;修改新增&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt; &lt;form action=&quot;/update_book/?id=&#123;&#123; book.id &#125;&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;&#123;&#123; book.id &#125;&#125;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;p&gt;书名：&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&#123;&#123; book.name &#125;&#125;&quot; class=&quot;form-control&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;p&gt;价格：&lt;input type=&quot;text&quot; name=&quot;price&quot; value=&quot;&#123;&#123; book.price &#125;&#125;&quot; class=&quot;form-control&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;p&gt;出版日期：&lt;input type=&quot;date&quot; name=&quot;pub_date&quot; value=&quot;&#123;&#123; book.pub_date|date:&#x27;Y-m-d&#x27; &#125;&#125;&quot; class=&quot;form-control&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;p&gt;作者： &lt;select name=&quot;authors&quot; class=&quot;form-control&quot; multiple&gt; &#123;% for author in authors %&#125; &#123;% if author in book.authors.all %&#125; &lt;option value=&quot;&#123;&#123; author.id &#125;&#125;&quot; selected&gt;&#123;&#123; author.name &#125;&#125;&lt;/option&gt; &#123;% else %&#125; &lt;option value=&quot;&#123;&#123; author.id &#125;&#125;&quot;&gt;&#123;&#123; author.name &#125;&#125;&lt;/option&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/select&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;p&gt;出版社： &lt;select name=&quot;publish&quot; id=&quot;&quot; class=&quot;form-control&quot;&gt; &#123;% for publish in publishs %&#125; &#123;% if publish.id == book.publish_id %&#125; &lt;option value=&quot;&#123;&#123; publish.id &#125;&#125;&quot; selected&gt;&#123;&#123; publish.name &#125;&#125;&lt;/option&gt; &#123;% else %&#125; &lt;option value=&quot;&#123;&#123; publish.id &#125;&#125;&quot;&gt;&#123;&#123; publish.name &#125;&#125;&lt;/option&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/select&gt; &lt;/p&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;修改&quot; class=&quot;btn btn-warning pull-right&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2 orm常用和非常用字段（了解）1234567891 常用AutoField IntegerField CharField DateField DateTimeField2 不常用的 -BooleanField -TextField -FileField3 对应关系 3 orm字段参数（了解）1234567891011121314151617181920211 null 是否可以为空2 unique 是否唯一3 db_index 是否给该字段建索引4 default 默认值为5 DateField和DateTimeField 两个参数 #### auto_now_add 配置auto_now_add=True，创建数据记录的时候会把当前时间添加到数据库。 #### auto_now（对象.属性 对象.save()） queryset.update无效 配置上auto_now=True，每次更新数据记录的时候会更新该字段。6 choices(知道) -在model表模型定义的时候给某个字段指定choice sex_choice=((1,&#x27;男&#x27;),(2,&#x27;女&#x27;),(0,&#x27;未知&#x27;)) sex =models.IntegerField(default=1,choices=sex_choice) -在使用的时候，直接取出中文 对象.get_sex_display()7 了解的 verbose_name Admin中显示的字段名称 blank Admin中是否允许用户输入为空 editable Admin中是否可以编辑 help_text Admin中该字段的提示信息 choices Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作 4 字段关系（了解）12345678910111213141516171819202122232425262728293031321 一对以 一对多 多对多2 ForeignKey -to ：对那张表 -to_field:对表中的某个字段 -related_name：反向操作时，使用的字段名，用于代替原反向查询时的’表名_set’ -related_query_name：反向查询操作时，使用的连接前缀，用于替换表名 -on_delete： 当删除关联表中的数据时，当前表与其关联的行的行为。 models.CASCADE 删除关联数据，与之关联也删除 models.DO_NOTHING 删除关联数据，什么都不做 models.PROTECT 删除关联数据，引发错误ProtectedError models.SET_NULL 删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空） models.SET_DEFAULT 删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值） models.SET 删除关联数据， a. 与之关联的值设置为指定值，设置：models.SET(值) b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象) -db_constraint -True：建立外键，默认是True -False：不建立外键 -外键是否建立： -好处：不会出现脏数据 -坏处：插入的时候，效率低 -企业中：通常不建立，程序员控制 3 OneToOneField-跟ForeignKey4 ManyToManyField：如何手动创建第三张表 5 手动创建第三张表1234567891011121314-字段参数 -db_table：指定第三张表的名字 -to：关联的表 -related_name 同ForeignKey字段。 -related_query_name 同ForeignKey字段。 -through：手动创建第三张表，指定通过哪个表 -through_fields：关联字段是什么 -多对多关系建立的三种方式 -第一种：自动创建（常用：第三张表没有其他字段） -第二种：手动创建第三张表（比较常用：第三张表有多余字段） -第三中：完全手动写第三张表 123456789# 第一种：class Book(models.Model): title = models.CharField(max_length=32, verbose_name=&quot;书名&quot;)# 通过ORM自带的ManyToManyField自动创建第三张表class Author(models.Model): name = models.CharField(max_length=32, verbose_name=&quot;作者姓名&quot;) books = models.ManyToManyField(to=&quot;Book&quot;, related_name=&quot;authors&quot;) 123456789101112131415161718192021# 第二种class Book1(models.Model): title = models.CharField(max_length=32, verbose_name=&quot;书名&quot;)# 自己创建第三张表，并通过ManyToManyField指定关联class Author1(models.Model): name = models.CharField(max_length=32, verbose_name=&quot;作者姓名&quot;) books = models.ManyToManyField(to=&quot;Book1&quot;, through=&quot;Author2Book&quot;, through_fields=(&quot;author&quot;, &quot;book&quot;)) # through_fields 元组的第一个值是ManyToManyField所在的表去中间表通过那个字段，就写在第一个位置class Author2Book(models.Model): author = models.ForeignKey(to=&quot;Author1&quot;) book = models.ForeignKey(to=&quot;Book1&quot;) ##基于对象的跨表查，还能继续使用## 基于双下划綫连表查## 原来的多对多操作api用不了了，需要手动操作 12345678910111213# 第三种class Book1(models.Model): title = models.CharField(max_length=32, verbose_name=&quot;书名&quot;) class Author1(models.Model): name = models.CharField(max_length=32, verbose_name=&quot;作者姓名&quot;)# 自己创建第三张表，分别通过外键关联书和作者class Author2Book1(models.Model): author = models.ForeignKey(to=&quot;Author1&quot;) book = models.ForeignKey(to=&quot;Book1&quot;) 6 Meta元信息123456# 在每一个模型类中都可以写class Meta: #元信息 db_table=&#x27;lqz_publish&#x27; #表名 index_together=(&#x27;name&#x27;,&#x27;city&#x27;) # 多个字段联合索引 unique_together=(&#x27;name&#x27;,&#x27;city&#x27;) # 联合唯一 ordering=(&#x27;nid&#x27;, ) # 默认以哪个字段排序 7 原生sql12345678910111213141516 from app01 import models # res=models.Author.objects.all() # for author in res: # print(author.sex) # print(author.get_sex_display()) # 使用原生sql # res=models.Author.objects.raw(&#x27;select * from app01_author where nid&gt;1&#x27;) # for author in res: # print(author.name) res = models.Author.objects.raw(&#x27;select * from app01_book where nid&gt;1&#x27;) for book in res: print(book.price) # 执行原生sql，跟对象类型无关了，查出什么字段，可以直接使用该字段 8 Django与ajax（入门）1234561 概念AJAX（Asynchronous Javascript And XML）翻译成中文就是“异步Javascript和XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML,现在更多使用json数据）2 异步：请求发出去，不会卡在这，可以干其他事3 局部刷新：js的dom操作，使页面局部刷新4 基本上web页面都有很多ajax请求 8.1 写ajax跟后端交互12345671 使用原生js写ajax请求（没有人用） -第一：麻烦 -第二：区分浏览器，需要做浏览器兼容2 现在主流做法（现成有人封装好了，jquery，axios..） -以jquery为例讲 -后面会讲axios 后端12345678910def ajax_test(request): return render(request,&#x27;ajax_test.html&#x27;)def sum(request): import time time.sleep(2) a1=int(request.GET.get(&#x27;a1&#x27;)) a2=int(request.GET.get(&#x27;a2&#x27;)) return HttpResponse(a1+a2) 前端1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;/static/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;a1&quot;&gt; + &lt;input type=&quot;text&quot; id=&quot;a2&quot;&gt;=&lt;input type=&quot;text&quot; id=&quot;sum&quot;&gt; &lt;button id=&quot;btn_submit&quot;&gt;计算&lt;/button&gt;&lt;/body&gt; &lt;script&gt; $(&#x27;#btn_submit&#x27;).click(function () &#123; var a1 = $(&#x27;#a1&#x27;).val() var a2 = $(&#x27;#a2&#x27;).val() // 发送ajax请求，计算，返回结果 $.ajax(&#123; url: &#x27;/sum/&#x27;, //ajax请求的地址 method: &#x27;get&#x27;,//请求方式 data: &#123;&#x27;a1&#x27;: a1, &#x27;a2&#x27;: a2&#125;, //携带参数 success:function (data) &#123; //服务端成功返回会回调，执行匿名函数 console.log(data) $(&#x27;#sum&#x27;).val(data) &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html&gt; 其他1 基础题1 图书管理系统完成 2 手动创建第三张表（使用through，验证我说的三句话） 3 写一个ajax计算乘法的 2 扩展题（有余力）1 自学django中如何使用事务 2 自学django orm 的defer和only有什么作用","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"08、分组查询、图书管理系统、（wsgi、uwsgi、cgi、fastcgi介绍）","slug":"Django_day08","date":"2018-09-20T06:04:08.000Z","updated":"2022-05-14T03:51:25.702Z","comments":true,"path":"2018/09/20/Django_day08/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day08/","excerpt":"","text":"复习123456789101112131415161718192021222324252627282930313233343536-1 前后端混合开发（咱们前后端都写） 前后端分离，前端的人专门写前端，后端的人专门写后端0 django的模板语法 -dtl：在模板中写python代码 ../14550984.html -php：http://www.aa7a.cn/user.php -java：https://www.pearvideo.com/category_loading.jsp -go：../14550984.html -jsp javascript1 后续的课程 -django高级，ajax，分页，auth,中间件.. -BBS项目 -drf：写接口 -vue -路飞：git，celery，redis，发短信.... -flask -cmdb：自动化运维 -爬虫 -go -es -redis高级 -rabbitmq，rpc -mongodb -mysql 主从，读写分离，分库分表 -分布式锁，分布式id。。。。 2 python后端开发，爬虫，自动化运维，自动化测试，python开发（写脚本） 数据分析，go开发 3 多对多操作的api -add -remove -clear -set 4 什么情况下手动创建第三张表？ -第三张表中有其它额外的字段 1 分组查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import osos.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;day53.settings&quot;)if __name__ == &#x27;__main__&#x27;: import django django.setup() from app01 import models # 查询每一个出版社id，以及出书平均价格(单表) # 原生sql # select publish_id,avg(price) from book group by publish_id; # orm实现 &#x27;&#x27;&#x27;标准 annotate() 内写聚合函数 values在前，表示group by 的字段 values在后，表示取字段 filter在前，表示where条件 filter在后，表示having &#x27;&#x27;&#x27; from django.db.models import Avg,Count,Max # res = models.Book.objects.all().\\ # values(&#x27;publish_id&#x27;).\\ # annotate(price_ave=Avg(&#x27;price&#x27;)).values(&#x27;publish_id&#x27;,&#x27;price_ave&#x27;) # print(res) # 查询出版社id大于1的出版社id，以及出书平均价格 # res=models.Book.objects.values(&#x27;publish_id&#x27;).filter(publish_id__gt=1).annotate(price_ave=Avg(&#x27;price&#x27;)).values(&#x27;publish_id&#x27;,&#x27;price_ave&#x27;) # print(res) # 查询出版社id大于1的出版社id，以及出书平均价格大于30的 # res=models.Book.objects.values(&#x27;publish_id&#x27;).filter(publish_id__gt=1).annotate(price_ave=Avg(&#x27;price&#x27;)).filter(price_ave__gt=60).values(&#x27;publish_id&#x27;,&#x27;price_ave&#x27;) # print(res) #查询每一个出版社出版的名称和书籍个数(连表) # 联表的话最好以group by的表作为基表 # res=models.Publish.objects.values(&#x27;nid&#x27;).annotate(book_count=Count(&#x27;book__nid&#x27;)).values(&#x27;name&#x27;,&#x27;book_count&#x27;) # 简写成，如果基表是group by的表，就可以不写values # res=models.Publish.objects.annotate(book_count=Count(&#x27;book&#x27;)).values(&#x27;name&#x27;,&#x27;book_count&#x27;) # 以book为基表 # res=models.Book.objects.values(&#x27;publish__nid&#x27;).annotate(book_count=Count(&#x27;nid&#x27;)).values(&#x27;publish__name&#x27;,&#x27;book_count&#x27;) # print(res) #查询每个作者的名字，以及出版过书籍的最高价格(建议使用分组的表作为基表) # 多对多如果不以分组表作为基表，可能会出数据问题 # res=models.Author.objects.annotate(price_max=Max(&#x27;book__price&#x27;)).values(&#x27;name&#x27;,&#x27;price_max&#x27;) # res=models.Book.objects.values(&#x27;authors__nid&#x27;).annotate(price_max=Max(&#x27;price&#x27;)).values(&#x27;authors__name&#x27;,&#x27;price_max&#x27;) # print(res) #查询每一个书籍的名称，以及对应的作者个数 res=models.Book.objects.annotate(count=Count(&#x27;authors&#x27;)).values(&#x27;name&#x27;,&#x27;count&#x27;) print(res) ##统计不止一个作者的图书 ## 统计价格数大于10元，作者的图书 ##统计价格数大于10元，作者个数大于1的图书 res=models.Book.objects.filter(price__gt=10).annotate(count=Count(&#x27;authors&#x27;)).filter(count__gt=1).values(&#x27;name&#x27;,&#x27;price&#x27;,&#x27;count&#x27;) print(res) 2 图书管理系统项目123451 后端是django+mysql/sqlite2 前端：jquery，bootstrap3 首页，图书列表展示，图书新增，修改，作者展示，新增，修改，出版社展示，新增，修改。。。4 项目地址：https://gitee.com/liuqingzheng/books 补充1 wsgi，uwsgi,cgi,fastcgi1234567891011python：有wsgi协议，uwsgi，gunicornjava：tomcat，jbossphp:php服务器wsgi：协议，规定了如何拆http请求，拆到一个python字典中，environment：响应对象，start_responsewsgiref:符合wsgi协议的web服务器 详情见：http://www.liuqingzheng.top/article/1/05-CGI,FastCGI,WSGI,uWSGI,uwsgi%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82/ # asgi协议","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"07、图书相关表关系建立、基于双下划线跨表查询、聚合查询、F（取字段对应值）查询、Q（构造与或非）查询、django用admin注册表","slug":"Django_day07","date":"2018-09-20T06:04:07.000Z","updated":"2022-05-14T03:50:23.588Z","comments":true,"path":"2018/09/20/Django_day07/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day07/","excerpt":"","text":"1 图书相关表关系建立12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561 5个表2 书籍表，作者表，作者详情表，出版社表，书籍和作者表（多对多关系）3 一对一的关系，关联字段可以写在任意一方4 一对多的关系，关联字段写在多的一方5 多对多的关系，必须建立第三张表（orm中，可以用一个字段表示，这个字段可以写在任意一方）5 把表关系同步到数据库中 -python3 manage.py makemigrations # 在migrations文件夹下记录一下 -python3 manage.py migrate # 把记录变更到数据库6 表关系from django.db import modelsclass Publish(models.Model): nid = models.AutoField(primary_key=True) name = models.CharField(max_length=32) city = models.CharField(max_length=32) email = models.EmailField() # 本质是varchar类型class Book(models.Model): nid = models.AutoField(primary_key=True) # 自增，主键 name = models.CharField(max_length=32) # varchar 32 price = models.DecimalField(max_digits=5, decimal_places=2) publish_date = models.DateField() # 年月日类型 # 阅读数 # reat_num=models.IntegerField(default=0) # 评论数 # commit_num=models.IntegerField(default=0) # 建议加引号，也可以不加引号 #models.CASCADE：级联删除，设为默认值，设为空，设为指定的值，不做处理 # 2.x以后必须加，否则报错 # publish = models.ForeignKey(to=Publish,to_field=&#x27;nid&#x27;,on_delete=models.CASCADE) publish = models.ForeignKey(to=Publish,to_field=&#x27;nid&#x27;,on_delete=models.CASCADE) # 在数据库中，根本没有这个字段，orm用来查中介模型询，映射成一个表了 # 如果我不这么写，手动建立第三张表， authors=models.ManyToManyField(to=&#x27;Author&#x27;) def __str__(self): return self.nameclass Author(models.Model): nid = models.AutoField(primary_key=True) name = models.CharField(max_length=32) age = models.IntegerField() author_detail = models.OneToOneField(to=&#x27;AuthorDatail&#x27;,to_field=&#x27;nid&#x27;,unique=True,on_delete=models.CASCADE) # author_detail = models.ForeignKey(to=&#x27;AuthorDatail&#x27;,to_field=&#x27;nid&#x27;,unique=True,on_delete=models.CASCADE)class AuthorDatail(models.Model): nid = models.AutoField(primary_key=True) telephone = models.BigIntegerField() birthday = models.DateField() addr = models.CharField(max_length=64) 2基于双下划线的跨表查询123451 基于对象的跨表查 -子查询，多次查询2 基于双下划线的跨表查 -多表连接查询 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import os#加载配置文件，跑django的项目，最开始就是把配置文件加载上os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;day53.settings&quot;)if __name__ == &#x27;__main__&#x27;: import django # 安装了django模块，就可以import django.setup() # 使用环境变量中的配置文件，跑django from app01 import models # 正反向：正向，关联字段在当前对象中，去另一个表中查 # 查询主键为1的书籍的出版社所在的城市 # book=models.Book.objects.filter(pk=1).first() # print(book.publish.city) # res=models.Book.objects.filter(pk=1).values(&#x27;publish__city&#x27;) # print(res) # res=models.Publish.objects.filter(book__nid=1).values(&#x27;city&#x27;) # print(res) # 查询所有住址在北京的作者的姓名 # res=models.Author.objects.filter(author_detail__addr=&#x27;北京&#x27;).values(&#x27;name&#x27;) # print(res) # # res=models.AuthorDatail.objects.filter(addr=&#x27;北京&#x27;).values(&#x27;author__name&#x27;) # print(res) #查询egon出过的所有书籍的名字 # res=models.Author.objects.filter(name=&#x27;egon&#x27;).values(&#x27;book__name&#x27;) # print(res) # res=models.Book.objects.filter(authors__name=&#x27;egon&#x27;).values(&#x27;name&#x27;) # print(res) # 查询人民出版社出版过的所有书籍的名字以及作者的姓名和地址 res=models.Book.objects.filter(publish__name=&#x27;北京出版社&#x27;)\\ .values(&#x27;publish__name&#x27;,&#x27;name&#x27;,&#x27;authors__name&#x27;,&#x27;authors__author_detail__addr&#x27;) res=models.Publish.objects.filter(name=&#x27;北京出版社&#x27;).values(&#x27;name&#x27;,&#x27;book__name&#x27;,&#x27;book__authors__name&#x27;,&#x27;book__authors__author_detail__addr&#x27;) res=models.Author.objects.filter(book__publish__name=&#x27;北京出版社&#x27;).values(&#x27;book__publish__name&#x27;,&#x27;book__name&#x27;,&#x27;name&#x27;,&#x27;author_detail__addr&#x27;) res=models.AuthorDatail.objects.filter(author__book__publish__name=&#x27;北京出版社&#x27;).values(&#x27;author__book__publish__name&#x27;,&#x27;author__book__name&#x27;,&#x27;author__name&#x27;,&#x27;addr&#x27;) print(res) 3 聚合查询1231 聚合函数，sum，max，min，count，avg2 把聚合结果字段重命名res=models.Book.objects.all().aggregate(aaa=Sum(&#x27;price&#x27;)) 12345# 聚合查询# 计算所有图书的平均价格from django.db.models import Sum,Avg,Max,Min,Countres=models.Book.objects.all().aggregate(Avg(&#x27;price&#x27;))print(res)# 计算所有图书的最高价格res=models.Book.objects.all().aggregate(Max(&#x27;price&#x27;))print(res)# 计算所有图书的总价格res=models.Book.objects.all().aggregate(Sum(&#x27;price&#x27;))print(res)# egon出版图书的总价格# 北京出版从出版社书的最高价格# 计算所有图书的总价格 res=models.Book.objects.all().aggregate(book_sum=Sum(&#x27;price&#x27;),book_avg=Avg(&#x27;price&#x27;)) print(res) 4F查询12345678910# F 查询,取出某个字段对应的值from django.db.models import F#查询评论数大于阅读数的书籍# res=models.Book.objects.filter(commit_num__gt=F(&#x27;read_num&#x27;))# print(res)# 把所有图书价格+1res=models.Book.objects.all().update(price=F(&#x27;price&#x27;)+1)print(res) # 影响额行数 5 Q查询123456789101112131415# Q查询：构造出与&amp; 或| 非~from django.db.models import Q# 查询名字叫红楼梦或者价格大于100的书# res=models.Book.objects.filter(name=&#x27;红楼梦&#x27;,price__gt=100)# res=models.Book.objects.filter(Q(name=&#x27;红楼梦&#x27;)|Q(price__gt=100))# res=models.Book.objects.filter(Q(name=&#x27;红楼梦&#x27;)&amp; Q(price__gt=100))# 查询名字不是红楼梦的书res=models.Book.objects.filter(~Q(name=&#x27;红楼梦&#x27;))#查询名字不是红楼梦，并且价格大于100的书# res = models.Book.objects.filter(~Q(name=&#x27;红楼梦&#x27;),price__gt=&#x27;100&#x27;)res = models.Book.objects.filter(~Q(name=&#x27;红楼梦&#x27;)&amp;Q(price__gt=&#x27;100&#x27;))print(res) 补充：1234567891011121314151 普通函数以__开头 -说明当前函数只在当前模块（py）下使用，尽量不在外部调用 2 mysql -utf8：2个字节表示一个字符 -utf8mb4：等同于真正意义上的utf-8 -utf-8：1--4个字节，表示一个字符 3 django 的orm使用pymysql连接mysql -需要加这一句话（本质就是猴子补丁的应用） import pymysql pymysql.install_as_MySQLdb() -本质是想让它执行，放在哪都可以 -init中 -settings.py中 djago admin的使用1234567891011121314151 后台管理，方便我们快速的录入书籍2 使用方法： 第一步：在admin.py 中把要使用的表注册 from app01 import models admin.site.register(models.Book) admin.site.register(models.Author) admin.site.register(models.AuthorDatail) admin.site.register(models.Publish) 第二步：创建个超级管理员 python3 manage.py createsuperuser 输入用户名，输入密码 第三步：登录，录入书籍 -http://127.0.0.1:8000/admin/ 使用脚本调用django12345678910111 写一个脚本文件import os#加载配置文件，跑django的项目，最开始就是把配置文件加载上os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;day53.settings&quot;)if __name__ == &#x27;__main__&#x27;: import django # 安装了django模块，就可以import django.setup() # 使用环境变量中的配置文件，跑django from app01 import models django查看原生sql123456789101112131415161718191 queryset对象.query2 通过日志，如下，配置到setting.py中LOGGING = &#123; &#x27;version&#x27;: 1, &#x27;disable_existing_loggers&#x27;: False, &#x27;handlers&#x27;: &#123; &#x27;console&#x27;:&#123; &#x27;level&#x27;:&#x27;DEBUG&#x27;, &#x27;class&#x27;:&#x27;logging.StreamHandler&#x27;, &#125;, &#125;, &#x27;loggers&#x27;: &#123; &#x27;django.db.backends&#x27;: &#123; &#x27;handlers&#x27;: [&#x27;console&#x27;], &#x27;propagate&#x27;: True, &#x27;level&#x27;:&#x27;DEBUG&#x27;, &#125;, &#125;&#125;","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"06、Django测试环境搭建、单表查询关键字、双下划线范围查询查询、图书管理系统表设计、外键字段操作、Django跨表查询（理论、基于对象查、基于双下划线查）","slug":"Django_day06","date":"2018-09-20T06:04:06.000Z","updated":"2022-05-14T03:42:25.546Z","comments":true,"path":"2018/09/20/Django_day06/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day06/","excerpt":"","text":"django测试环境搭建12345678910111213ps: 1.pycharm链接数据库都需要提前下载对应的驱动 2.自带的sqlite3对日期格式数据不敏感 如果后续业务需要使用日期辅助筛选数据那么不推荐使用sqlite3 # 方式1:任意创建一个py文件，在该文件内书写固定的配置import osif __name__ == &quot;__main__&quot;: os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;day06.settings&quot;) import django django.setup()# 方式2:直接使用pycharm提供的python console 单表查询关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374QuerySet对象方法 query # 查看orm内部对应的SQL语句 # 增 # res = models.Books.objects.create(title=&#x27;西游记&#x27;,price=687.90) # print(res.title) &#x27;&#x27;&#x27;create返回值就是当前被创建的数据对象&#x27;&#x27;&#x27; # 查 # res = models.Books.objects.all() # print(res.query) # res = models.Books.objects.filter() # print(res.query) # res = models.Books.objects.filter(title=&#x27;jason&#x27;) # print(res) &quot;&quot;&quot;filter括号内可以放多个参数 默认是and关系 推荐使用 条件不符合不会报错&quot;&quot;&quot; # res1 = models.Books.objects.get(title=&#x27;jason&#x27;) # print(res1) &quot;&quot;&quot;get括号内可以放多个参数 默认是and关系 不推荐使用 条件不符合直接报错&quot;&quot;&quot; # 改 # res = models.Books.objects.filter(pk=1).update(price=666.66) # print(res) # 返回值是受影响的行数 # book_obj = models.Books.objects.filter(pk=2).first() # book_obj.price = 999.66 # book_obj.save() # 效率低(所有字段重新写一遍) &quot;&quot;&quot;pk能够自动查找到当前表的主键字段 我们不需要查看当前表主键字段名&quot;&quot;&quot; # 删 # models.Books.objects.filter(pk=1).delete() # 1.first() 取第一个数据对象 # res = models.Books.objects.all().first() # res1 = models.Books.objects.all()[0] # res2 = models.Books.objects.all()[0:2] # print(res,res1,res2) &quot;&quot;&quot;QuerySet对象还支持切片操作 但是只能填正数&quot;&quot;&quot; # 2.last() 取最后一个数据对象 # res = models.Books.objects.all().last() # print(res) # 3.values() 获取数据指定字段的值 # res = models.Books.objects.all().values(&#x27;title&#x27;,&#x27;publish_time&#x27;) # res1 = models.Books.objects.values(&#x27;title&#x27;,&#x27;publish_time&#x27;) # print(res,res1) &quot;&quot;&quot;all()加不加都表示所有数据 values获取的结果 类似于列表套字典&quot;&quot;&quot; # 4.values_list() 获取数据指定字段的值 # res = models.Books.objects.values_list(&#x27;title&#x27;, &#x27;publish_time&#x27;) # print(res) &quot;&quot;&quot;values_list获取的结果 类似于列表套元组&quot;&quot;&quot; # 5.order_by() 排序 # res = models.Books.objects.order_by(&#x27;price&#x27;) # 默认是升序 # print(res) # res1 = models.Books.objects.order_by(&#x27;-price&#x27;) # 减号降序 # print(res1) # 6.count() 计数 # res = models.Books.objects.count() # 统计数据条数 # print(res) # 7.distinct() 去重 # res = models.Books.objects.all().distinct() # res1 = models.Books.objects.values(&#x27;title&#x27;).distinct() # print(res1) &quot;&quot;&quot;去重的前提是数据必须是一模一样 一定不能忽略主键&quot;&quot;&quot; # 8.exclude() 排除什么什么在外 取反操作 # res = models.Books.objects.exclude(title=&#x27;西游记&#x27;) # print(res.query) # 9.reverse() # res = models.Books.objects.all() # res1 = models.Books.objects.reverse() # res2 = models.Books.objects.order_by(&#x27;price&#x27;).reverse() # print(res) # print(res1) # print(res2) &quot;&quot;&quot;reverse需要先排序之后才能反转&quot;&quot;&quot; # 10.exists() 判断是否有数据 返回布尔值 # res = models.Books.objects.all().exists() # print(res) 神奇的双下划綫查询(范围查询)1234567891011121314151617181920212223242526272829303132# 1.查询价格大于700的书籍 # res = models.Books.objects.filter(price__gt=700) # print(res) # print(res.query) # 2.查询价格小于700的书籍 # res = models.Books.objects.filter(price__lt=700) # print(res) # print(res.query) # 价格大于等于700 小于等于700 # res1 = models.Books.objects.filter(price__gte=700) # res2 = models.Books.objects.filter(price__lte=700) # print(res1.query,res2.query) # 3.查询价格要么是666.66 要么是999.66 要么是10000 # res = models.Books.objects.filter(price__in=[666.66,999.66,10000]) # print(res) &quot;&quot;&quot;python对数字不是很敏感 精确度不高 很多时候我们会采取字符串存储数字类型&quot;&quot;&quot; # 4.查询价格在500到800之间的 # res = models.Books.objects.filter(price__range=(500,800)) # print(res.query) # 5.查询书名中包含字母s的书 # res = models.Books.objects.filter(title__contains=&#x27;s&#x27;) # 区分大小写 # print(res.query) # res = models.Books.objects.filter(title__icontains=&#x27;s&#x27;) # 区分大小写 # print(res) # 6.查询出版日期是2021的书 # res = models.Books.objects.filter(publish_time__year=2021) # print(res.query) # 7.查询出版日期是3月的书 # res = models.Books.objects.filter(publish_time__month=3) # print(res) 图书管理系统表设计12345678910111213141516171819202122232425262728293031323334class Book(models.Model): title = models.CharField(verbose_name=&#x27;书名&#x27;, max_length=32) price = models.DecimalField(verbose_name=&#x27;价格&#x27;, max_digits=8, decimal_places=2) publish_time = models.DateField(verbose_name=&#x27;出版日期&#x27;,auto_now_add=True) # 一对多 外键字段建在多的一方 publish = models.ForeignKey(to=&#x27;Publish&#x27;) # 多对多 外键字段推荐建在查询频率较高的表中 authors = models.ManyToManyField(to=&#x27;Author&#x27;)class Publish(models.Model): title = models.CharField(verbose_name=&#x27;名称&#x27;,max_length=32) addr = models.CharField(verbose_name=&#x27;地址&#x27;,max_length=128) email = models.EmailField(verbose_name=&#x27;邮箱&#x27;)class Author(models.Model): name = models.CharField(verbose_name=&#x27;姓名&#x27;,max_length=32) age = models.IntegerField(verbose_name=&#x27;年龄&#x27;) # 一对一 外键字段推荐建在查询频率较高的表中 author_detail = models.OneToOneField(to=&#x27;AuthorDetail&#x27;)class AuthorDetail(models.Model): phone = models.BigIntegerField(verbose_name=&#x27;电话&#x27;) addr = models.CharField(verbose_name=&#x27;地址&#x27;,max_length=32) &quot;&quot;&quot;作者详情表作者表出版社表书籍表和关系表通过orm实现&quot;&quot;&quot; 外键字段操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 外键字段# 直接传主键值models.Book.objects.create(title=&#x27;聊斋&#x27;,price=666.98,publish_id=1)models.Book.objects.create(title=&#x27;聊斋志异2&#x27;,price=666.98,publish_id=2)# 传数据对象publish_obj = models.Publish.objects.filter(pk=1).first()models.Book.objects.create(title=&#x27;神雕侠侣&#x27;, price=234.56, publish=publish_obj)models.Book.objects.filter(pk=1).update(publish_id=2)models.Book.objects.filter(pk=3).update(publish=publish_obj)# 多对多外键字段# 增book_obj = models.Book.objects.filter(pk=1).first()# 主键值book_obj.authors.add(1) # 去第三张关系表中 与作者主键为1的绑定关系# 作者对象author_obj = models.Author.objects.filter(pk=2).first()book_obj.authors.add(author_obj)# 括号内支持传多个参数book_obj.authors.add(1,2)author_obj1 = models.Author.objects.filter(pk=1).first()author_obj2 = models.Author.objects.filter(pk=2).first()book_obj.authors.add(author_obj1,author_obj2)# 改book_obj.authors.set([1,])book_obj.authors.set((1,2))book_obj.authors.set([author_obj1, ])book_obj.authors.set([author_obj1,author_obj2 ])# 删book_obj.authors.remove(1)book_obj.authors.remove(1,2)book_obj.authors.remove(author_obj1,author_obj2)# 清空book_obj.authors.clear() # 去第三张关系表中删除所有改书籍对应的记录&quot;&quot;&quot;add()、remove() 括号内既可以传数字也可以传对象 逗号隔开即可set() 括号内必须传递可迭代对象 可迭代对象内既可以传数字也可以传对象 支持多个clear() 清空操作 无需传值&quot;&quot;&quot; 跨表查询理论1234567891011正向 外键字段在谁那儿，谁查另外的人就是正向反向 没有外键字段# 就是判断你是否有关联的外键字段&quot;&quot;&quot;正向查询按外键字段反向查询按表名小写 _set&quot;&quot;&quot; 基于对象的跨表查询12345678910111213141516171819202122232425262728293031323334353637383940414243# 子查询&quot;&quot;&quot;1.先查询出一个对象2.基于对象点正反向字段&quot;&quot;&quot;反向查询表明小写加_set 查询的对象可能有多个的情况查询的对象只有一个的情况不需要加基于对象的跨表查询 1.查询聊斋书籍对应的出版社名称 book_obj = models.Book.objects.filter(title=&#x27;聊斋&#x27;).first() res = book_obj.publish print(res.title) 2.查询神雕侠侣对应的作者 book_obj = models.Book.objects.filter(title=&#x27;神雕侠侣&#x27;).first() # res = book_obj.authors # app01.Author.None res = book_obj.authors.all() print(res) 3.查询jason的地址 author_obj = models.Author.objects.filter(name=&#x27;jason&#x27;).first() res = author_obj.author_detail print(res.phone,res.addr) 4.查询东方出版社出版过的书籍 publish_obj = models.Publish.objects.filter(title=&#x27;东方出版社&#x27;).first() # res = publish_obj.book_set # app01.Book.None res = publish_obj.book_set.all() # app01.Book.None print(res) 5.查询jason写过的书 author_obj = models.Author.objects.filter(name=&#x27;jason&#x27;).first() # res = author_obj.book_set # app01.Book.None res = author_obj.book_set.all() print(res) 6.查询电话是110的作者姓名 author_detail_obj = models.AuthorDetail.objects.filter(phone=110).first() res = author_detail_obj.author print(res.name,res.age) 基于双下划线的跨表查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 连表操作############################################################################# # 基于对象的跨表查询 # 1.查询聊斋书籍对应的出版社名称 # book_obj = models.Book.objects.filter(title=&#x27;聊斋&#x27;).first() # res = book_obj.publish # print(res.title) # # 2.查询神雕侠侣对应的作者 # book_obj = models.Book.objects.filter(title=&#x27;神雕侠侣&#x27;).first() # # res = book_obj.authors # app01.Author.None # res = book_obj.authors.all() # print(res) # # # 3.查询jason的地址 # author_obj = models.Author.objects.filter(name=&#x27;jason&#x27;).first() # res = author_obj.author_detail # print(res.phone,res.addr) # # 4.查询东方出版社出版过的书籍 # publish_obj = models.Publish.objects.filter(title=&#x27;东方出版社&#x27;).first() # # res = publish_obj.book_set # app01.Book.None # res = publish_obj.book_set.all() # app01.Book.None # print(res) # # 5.查询jason写过的书 # author_obj = models.Author.objects.filter(name=&#x27;jason&#x27;).first() # # res = author_obj.book_set # app01.Book.None # res = author_obj.book_set.all() # print(res) # # 6.查询电话是110的作者姓名 # author_detail_obj = models.AuthorDetail.objects.filter(phone=110).first() # res = author_detail_obj.author # print(res.name,res.age) ######################################################################## # 基于双下划线查询 # 1.查询聊斋书籍对应的出版社名称 # res = models.Book.objects.filter(title=&#x27;聊斋&#x27;).values(&#x27;publish__title&#x27;) # print(res.query) # 2.查询神雕侠侣对应的作者名字和年龄 # res = models.Book.objects.filter(title=&#x27;神雕侠侣&#x27;).values(&#x27;authors__name&#x27;,&#x27;authors__age&#x27;) # print(res) # 3.查询jason的地址 # res = models.Author.objects.filter(name=&#x27;jason&#x27;).values(&#x27;author_detail__addr&#x27;) # print(res) # 1.查询聊斋书籍对应的出版社名称 # res = models.Publish.objects.filter(book__title=&#x27;聊斋&#x27;).values(&#x27;title&#x27;) # print(res) # 2.查询神雕侠侣对应的作者名字和年龄 # res = models.Author.objects.filter(book__title=&#x27;神雕侠侣&#x27;).values(&#x27;name&#x27;,&#x27;age&#x27;) # print(res) # 3.查询jason的地址 # res = models.AuthorDetail.objects.filter(author__name=&#x27;jason&#x27;).values(&#x27;addr&#x27;) # print(res) # 查询神雕侠侣对应的作者的电话和地址 res = models.Book.objects.filter(title=&#x27;神雕侠侣&#x27;).values(&#x27;authors__author_detail__phone&#x27;,&#x27;authors__author_detail__addr&#x27;) print(res)","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"05、Django settings源码、模板语法（传值、获取值、过滤器、标签、自定义（过滤器、标签、inclusion_tag）、模板导入、模板继承）","slug":"Django_day05","date":"2018-09-20T06:04:05.000Z","updated":"2022-05-14T03:36:32.031Z","comments":true,"path":"2018/09/20/Django_day05/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day05/","excerpt":"","text":"复习 路由分发 12345678在django中所有的应用都可以有自己独立的路由层、模板层、静态文件路由分发是为了解决总路由代码过于冗余的情况include(&#x27;应用名.urls&#x27;)注意事项 总路由最后千万不要加$ 名称空间 12345当多个应用出现反向解析起别名冲突的情况include(&#x27;应用名.urls&#x27;,namespace=&#x27;自定义名称空间名字&#x27;)reverse(&#x27;自定义名称空间名字:别名&#x27;)&#123;% url &#x27;自定义名称空间名字:别名&#x27; %&#125;# 名称空间其实也可以不使用 只要我们做到所有的别名不冲突即可，eg:在每个别名前面加上各自应用名作为前缀 本地虚拟环境 1234类似于docker容器，给每个项目配备独立的运行环境ps:requirements.txt创建虚拟环境类似于重新下载了一个纯净的python解释器 django版本区别 12345671.路由层使用的方法不一样 url() path() re_path() == url()2.转换器3.2.X与3.X区别 3.X新增了异步功能 三板斧本质 1返回HttpResponse对象 JsonResponse 12JsonResponse(obj,json_dumps_params,safe)ps:看源码学习的好处 FBV与CBV及源码 12345678910111213141516171819202122232425FBV def index(request): return HttpResponse(&#x27;index&#x27;)CBV from django.views import View class MyClassView(View): def get(self,request): return HttpResponse(&#x27;get&#x27;) def post(self,request): return HttpResponse(&#x27;post&#x27;) url(r&#x27;^login/&#x27;,views.MyClassView.as_view())# 为什么能够根据前期方式的不同自动匹配执行对应的方法class View(...): @classonlymethod def as_view(...): def view(...): obj = cls(...) return self.dispatch(...) # 面向对象属性查找顺序 return view # FBV与CBV路由匹配其实是一样的 def dispatch(...): if request.method.lower() in [8个方法]: handler = getattr(self,request.method.lower(),&#x27;报错&#x27;) else: handler = &#x27;报错&#x27; return handler(...) django settings源码123456789101112131415161718192021222324252627282930313233343536&quot;&quot;&quot;1.django其实有两个配置文件 一个是暴露给用户可以自定义的配置文件 项目根目录下的settings.py 一个是项目默认的配置文件 当用户不做任何配置的时候自动加载默认配置2.配置文件变量名必须是大写&quot;&quot;&quot;疑问:为什么当用户配置了就使用用户配置的 不配置就是要默认的from django.conf import settings # 这个配置是两个配置的结合settings = LazySettings()os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;项目名.settings&quot;)ENVIRONMENT_VARIABLE = &quot;DJANGO_SETTINGS_MODULE&quot;class LazySettings(LazyObject): def _setup(self, name=None): # os.environ看成是一个全局大字典 &#x27;项目名.settings&#x27; settings_module = os.environ.get(ENVIRONMENT_VARIABLE) self._wrapped = Settings(settings_module) # Settings(&#x27;项目名.settings&#x27;) class Settings(object): def __init__(self, settings_module): # &#x27;项目名.settings&#x27; for setting in dir(global_settings): # 获取全局配置文件里面所有的变量名 if setting.isupper(): # 校验是否是纯大写 # 给Settings对象添加全局配置文件中所有的配置信息 setattr(self, setting, getattr(global_settings, setting)) self.SETTINGS_MODULE = settings_module # &#x27;项目名.settings&#x27; mod = importlib.import_module(self.SETTINGS_MODULE) # from day05 import settings # 导入暴露给用户的自定义配置文件 for setting in dir(mod): if setting.isupper(): setting_value = getattr(mod, setting) setattr(self, setting, setting_value) 模板语法之传值1234567891011# 传值方式1:利用字典挨个传值return render(request,&#x27;index.html&#x27;,&#123;&#x27;i&#x27;:i,&#x27;f&#x27;:f,&#x27;s&#x27;:s&#125;)# 传值方式2:简单粗暴 locals()将当前名称空间中所有的变量名全部传递给页面return render(request,&#x27;index.html&#x27;,locals())&quot;&quot;&quot; 传值方式1 传值精确 不会造成资源浪费 传值方式2 传值粗糙 可能会造成一定的资源浪费 ps:为了教学方便 我们以后就是用locals()&quot;&quot;&quot;补充:传递函数名和类名都会自动加括号调用(模板语法不支持额外的传参) 模板语法之获取值123&#x27;&#x27;&#x27;django模板语法取值只能采用 句点符(.) &#x27;&#x27;&#x27;索引 键都可以无限制的点点点&lt;p&gt;&#123;&#123; d.hobby.3.username &#125;&#125;&lt;/p&gt; 模板语法之过滤器1234567891011121314151617181920212223# 类似于python的内置方法&lt;p&gt;过滤器:将竖杆左侧的数据当做第一个参数&lt;/p&gt;&lt;p&gt;统计长度:&#123;&#123; s|length &#125;&#125;&lt;/p&gt;&lt;p&gt;加法运算:&#123;&#123; i|add:100000000000 &#125;&#125;&lt;/p&gt;&lt;p&gt;字符串拼接:&#123;&#123; s|add:&#x27;heiheihei&#x27; &#125;&#125;&lt;/p&gt;&lt;p&gt;日期格式:&#123;&#123; ctime|date:&#x27;Y年-m月-d日&#x27; &#125;&#125;&lt;/p&gt;&lt;p&gt;默认值:&#123;&#123; b|default:&#x27;哈哈&#x27; &#125;&#125;&lt;/p&gt;&lt;p&gt;默认值:&#123;&#123; b1|default:&#x27;哈哈&#x27; &#125;&#125;&lt;/p&gt;&lt;p&gt;文件大小:&#123;&#123; file_size|filesizeformat &#125;&#125;&lt;/p&gt;&lt;p&gt;截取文本(三个点也算):&#123;&#123; s|truncatechars:6 &#125;&#125;&lt;/p&gt;&lt;p&gt;截取文本(三个点不算)空格:&#123;&#123; s|truncatewords:3 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; h|safe &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; sss &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; sss1 &#125;&#125;&lt;/p&gt;转义 前端 |safe 后端 from django.utils.safestring import mark_safe sss1 = mark_safe(&#x27;&lt;h2&gt;老子要挣大钱&lt;/h2&gt;&#x27;) ps:前端代码也可以在后端写好传入!!! 模板语法之标签1234567891011121314151617181920212223# 类似于python的流程控制&#123;% for foo in s %&#125; &#123;% if forloop.first %&#125; &lt;p&gt;这是我的第一次~~&lt;/p&gt; &#123;% elif forloop.last %&#125; &lt;p&gt;这是最后一次了啊~&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &#123;% endif %&#125; &#123;% empty %&#125; &lt;p&gt;传入的数据是空的&lt;/p&gt;&#123;% endfor %&#125;&quot;&quot;&quot;&#123;&#123;&#125;&#125; 变量相关&#123;%%&#125; 逻辑相关&quot;&quot;&quot;# 起别名：（了解）&#123;% with d.hobby.3.username as name %&#125; &#123;&#123; name &#125;&#125; &#123;&#123; d.hobby.3.username &#125;&#125;&#123;% endwith %&#125; 自定义过滤器、标签、inclusion_tag1234567891011121314151617181920212223242526272829303132333435363738394041# 类似于python里面的自定义函数1.在应用下创建一个名字必须叫&quot;templatetags&quot;文件夹2.在上述文件夹内创建一个任意名称的py文件3.在该py文件内固定先书写以下两句话 from django import template register = template.Library() # 自定义过滤器@register.filter(name=&#x27;myfilter&#x27;)def index(a,b): # 简单的加法运算 return a + b# 自定义标签@register.simple_tag(name=&#x27;mysimple&#x27;)def func1(a,b,c,d): return &#x27;%s-%s|%s?%s&#x27;%(a,b,c,d)# 自定义inclusion_tag@register.inclusion_tag(&#x27;login.html&#x27;,name=&#x27;my_inclusion_tag&#x27;)def func2(n): l = [] for i in range(1,n+1): l.append(&#x27;第%s页&#x27;%i) return locals()前端&#123;% load mytag %&#125;&#123;&#123; i|myfilter:666 &#125;&#125;&#123;% mysimple 1 &#x27;jason&#x27; 222 &#x27;egon&#x27; %&#125;&#123;% my_inclusion_tag 10 %&#125;&#123;% my_inclusion_tag 8 %&#125;inclusion_tag 当某个区域需要反复使用并且数据不是固定的 模板的导入123# 类似于后端到模块 想要什么局部页面直接导入即可&#123;% include &#x27;myform.html&#x27; %&#125; 模板的继承12345678910111213141516171819202122232425262728先使用block划定区域母版 &#123;% block 区域名称 %&#125; &#123;% endblock %&#125;子版 &#123;% extends &#x27;home.html&#x27; %&#125; &#123;% block 区域名称 %&#125; &#123;% endblock %&#125; 母版在划定区域的时候一般都应该有三个区域 css区域 html文档区域 js区域 ps:目的是为了让子版具有独立的css js等 增加扩展性 &#123;% block css %&#125; &#123;% endblock %&#125; &#123;% block content %&#125; &#123;% endblock %&#125; &#123;% block js %&#125; &#123;% endblock %&#125; ps:子版也可以继续使用母版划定区域内的内容 &#123;&#123; block.super &#125;&#125;","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"04、路由分发、名称空间、伪静态、本地虚拟环境、Django版本区别、三板斧本质、JsonResponse、上传文件、FBV与CBV","slug":"Django_day04","date":"2018-09-20T06:04:04.000Z","updated":"2022-05-14T03:34:28.563Z","comments":true,"path":"2018/09/20/Django_day04/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day04/","excerpt":"","text":"路由分发123456789101112131415161718&quot;&quot;&quot;简介 django是专注于开发应用的，当一个django项目特别庞大的时候 所有的路由与视图函数映射关系全部写在总的urls.py很明显太冗余不便于管理 其实django中的每一个应用都可以有自己的urls.py,static文件夹,templates文件夹,基于上述特点，使用django做分组开发非常的简便 每个人只需要写自己的应用即可 最后由组长统一汇总到一个空的django项目中然后使用路由分发将多个应用关联到一起&quot;&quot;&quot;复杂版本 from app01 import urls as app01_urls from app02 import urls as app02_urls url(r&#x27;^app01/&#x27;,include(app01_urls)) url(r&#x27;^app02/&#x27;,include(app02_urls)) &#x27;&#x27;&#x27;总路由最后千万不能加$，加了后面的路由就不能匹配了&#x27;&#x27;&#x27;# 进阶版本 url(r&#x27;^app01/&#x27;,include(&#x27;app01.urls&#x27;)), url(r&#x27;^app02/&#x27;,include(&#x27;app02.urls&#x27;)) 名称空间1234567891011121314151617&quot;&quot;&quot;当多个应用在反向解析的时候如果出现了别名冲突的情况，那么无法自动识别&quot;&quot;&quot;解决方式1&gt;&gt;&gt;:名称空间 总路由 url(r&#x27;^app01/&#x27;,include(&#x27;app01.urls&#x27;,namespace=&#x27;app01&#x27;)) url(r&#x27;^app02/&#x27;,include(&#x27;app02.urls&#x27;,namespace=&#x27;app02&#x27;)) reverse(&#x27;app01:index_name&#x27;) reverse(&#x27;app02:index_name&#x27;) &lt;a href=&quot;&#123;% url &#x27;app01:index_name&#x27; %&#125;&quot;&gt;app01&lt;/a&gt; &lt;a href=&quot;&#123;% url &#x27;app02:index_name&#x27; %&#125;&quot;&gt;app02&lt;/a&gt; 解决方式2&gt;&gt;&gt;:别名不能冲突(加上自己应用名作为前缀) url(r&#x27;^index/&#x27;,views.index,name=&#x27;app01_index_name&#x27;) url(r&#x27;^index/&#x27;,views.index,name=&#x27;app02_index_name&#x27;) 伪静态12345动静态网页将url地址模拟成html结尾的样子，看上去像是一个静态文件目的是为了增加搜索引擎收藏我们网站的概率以及seo查询几率ps:再怎么优化都不如RMB玩家!!! 本地虚拟环境12345678910111213141516&quot;&quot;&quot;在时间开发过程中，我们会给不同的项目配备不同的环境项目用到什么就装什么，用不到的一概不装不同的项目解释器环境都不一样&quot;&quot;&quot;requirements.txt # 这个是项目的依赖包及包对应版本号# 可以通过pip生成或安装requirements.txt： # 生成 pip freeze &gt; requirements.txt # 安装 pip install -r requirements.txt (-r 就是-requirement的意思)创建虚拟环境类似于你重新下载了一个纯净的python解释器 如果反复创建类似于反复下载，会消耗一定的硬盘空间ps:我们目前不推荐你使用虚拟环境，所有的模块统一全部下载到本地 django版本区别123456789101112131415161718192021222324252627282930313233343536373839404142django1.X与2.X、3.X1.区别 urls.py中的路由匹配方法 1.X第一个参数正则表达式 url() 2.X和3.X第一个参数不支持正则表达式，写什么就匹配什么 path() 如果想要使用正则，那么2.X与3.X也有响应的方法 from django.urls import path,re_path re_path 等价于 1.X里面的url方法 2.转换器 五种常用转换器 str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式 int,匹配正整数，包含0。 slug,匹配字母、数字以及横杠、下划线组成的字符串。 uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。 path,匹配任何非空字符串，包含了路径分隔符（/）（不能用？） 自定义转换器 class MonthConverter: regex=&#x27;\\d&#123;2&#125;&#x27; # 属性名必须为regex def to_python(self, value): return int(value) def to_url(self, value): return value # 匹配的regex是两个数字，返回的结果也必须是两个数字 from django.urls import path,register_converter from app01.path_converts import MonthConverter register_converter(MonthConverter,&#x27;mon&#x27;) from app01 import views urlpatterns = [ path(&#x27;articles/&lt;int:year&gt;/&lt;mon:month&gt;/&lt;slug:other&gt;/&#x27;, views.article_detail, name=&#x27;aaa&#x27;), ] 三板斧本质123456789101112131415161718192021222324django视图函数必须要返回一个HttpResponse对象class HttpResponse(HttpResponseBase): &quot;&quot;&quot; An HTTP response class with a string as content. This content that can be read, appended to or replaced. &quot;&quot;&quot; streaming = False def __init__(self, content=b&#x27;&#x27;, *args, **kwargs): super(HttpResponse, self).__init__(*args, **kwargs) # Content is a bytestring. See the `content` property methods. self.content = content def render(request, template_name, context=None, content_type=None, status=None, using=None): &quot;&quot;&quot; Returns a HttpResponse whose content is filled with the result of calling django.template.loader.render_to_string() with the passed arguments. &quot;&quot;&quot; content = loader.render_to_string(template_name, context, request, using=using) return HttpResponse(content, content_type, status) redirect内部是继承了HttpRespone类 JsonResponse12345678910111213141516需求:给前端返回json格式数据方式1:自己序列化 res = json.dumps(d,ensure_ascii=False) return HttpResponse(res)方式2:JsonResponse from django.http import JsonResponse def func2(request): d = &#123;&#x27;user&#x27;:&#x27;jason好帅&#x27;,&#x27;password&#x27;:123&#125; return JsonResponse(d) ps:额外参数补充 json_dumps_params=&#123;&#x27;ensure_ascii&#x27;:False&#125; # 看源码，不将内容转为ASCII码 safe=False # 看报错信息 比如传列表失败，可以把safe关掉 # JsonResponse返回的也是HttpResponse对象 上传文件12345678910111213form表单上传文件注意事项 1.method必须是post 2.enctype参数修改为multipart/form-data def func3(request): if request.method == &#x27;POST&#x27;: print(request.POST) file_obj = request.FILES.get(&#x27;myfile&#x27;) print(file_obj.name) # 获取文件名称 with open(r&#x27;%s&#x27;%file_obj.name,&#x27;wb&#x27;) as f: for chunks in file_obj.chunks(): # 循环file_obj.chunks()比直接循环file_obj要节省资源一些 f.write(chunks) return render(request,&#x27;func3.html&#x27;) FBV与CBV12345678910111213141516171819202122232425262728293031323334353637FBV 基于函数的视图CBV 基于类的视图 # 基本使用from django.views import Viewclass MyView(View): def get(self,request): return HttpResponse(&quot;get方法&quot;) def post(self,request): return HttpResponse(&quot;post方法&quot;) url(r&#x27;^func4&#x27;,views.MyView.as_view())&quot;&quot;&quot;为什么能够自动根据请求方法的不同执行不同的方法&quot;&quot;&quot;1.突破口 as_view()2.CBV与FBV路由匹配本质 url(r&#x27;^func4&#x27;,views.MyView.as_view()) # 等价 CBV路由配置本质跟FBV一样 # url(r&#x27;^func4&#x27;,views.view)3.源码 def as_view(cls, **initkwargs): def view(request, *args, **kwargs): self = cls(**initkwargs) # self = MyView() 生成一个我们自己写的类的对象 return self.dispatch(request, *args, **kwargs) return view def dispatch(self, request, *args, **kwargs): # 获取当前请求并判断是否属于正常的请求(8个) if request.method.lower() in self.http_method_names: # get请求 getattr(对象,&#x27;get&#x27;) handler = 我们自己写的get方法 handler = getattr(self, request.method.lower(), self.http_method_not_allowed) else: handler = self.http_method_not_allowed return handler(request, *args, **kwargs) # 执行我们写的get方法并返回该方法的返回值 作业 121.整理今日内容至笔记2.理解并口头表述出CBV流程","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"03、数据库同步命令、orm创建外键关系、Django请求生命周期流程图、路由层之路由匹配（无名、有名分组）、无名有名反向解析","slug":"Django_day03","date":"2018-09-20T06:04:03.000Z","updated":"2022-05-14T03:33:20.871Z","comments":true,"path":"2018/09/20/Django_day03/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day03/","excerpt":"","text":"数据库同步命令(了解)12345678910111213141516171819&quot;&quot;&quot;数据库里面已经有一些表，我们如何通过django orm操作? 1.照着数据库表字段自己在models.py 数据需要自己二次同步 2.django提供的反向同步&quot;&quot;&quot;1.先执行数据库迁移命令 完成链接 python manage.py makemigrations2.查看代码 python manage.py inspectdb class Userinfo(models.Model): id = models.IntegerField(blank=True, null=True) name = models.CharField(max_length=32, blank=True, null=True) pwd = models.IntegerField(blank=True, null=True) class Meta: managed = False db_table = &#x27;userinfo&#x27; orm创建外键关系12345678910111213141516171819202122232425262728293031323334353637383940414243444546&quot;&quot;&quot;1.表与表之间的关系 一对多 一对一 多对多2.表关系的判断 换位思考&quot;&quot;&quot;书籍表出版社表作者表# ORM针对外键字段的创建位置 一对多 推荐建在多的一方 一对一 建在任何一方都可以,但是推荐建在查询频率较高的表中 多对多 1.自己建表 2.建在任何一方都可以,但是推荐建在查询频率较高的表中 class Book(models.Model): title = models.CharField(max_length=32) price = models.DecimalField(max_digits=8,decimal_places=2) # 总共8位 小数占2位 # 出版社外键 publish = models.ForeignKey(to=&#x27;Publish&#x27;) # 默认就是主键 &quot;&quot;&quot;自动在外键字段后面加_id后缀&quot;&quot;&quot; # 作者外键 authors = models.ManyToManyField(to=&#x27;Author&#x27;) # 自动帮你创建书籍和作者的第三张表 &quot;&quot;&quot;虚拟字段不会在表中实例化出来 而是告诉ORM创建第三张关系表&quot;&quot;&quot;class Publish(models.Model): title = models.CharField(max_length=32) email = models.EmailField()class Author(models.Model): name = models.CharField(max_length=32) age = models.IntegerField() author_detail = models.OneToOneField(to=&#x27;AuthorDetail&#x27;) &quot;&quot;&quot;自动在外键字段后面加_id后缀&quot;&quot;&quot;class AuthorDetail(models.Model): phone = models.BigIntegerField() addr = models.CharField(max_length=128) django请求生命周期流程图 路由层之路由匹配12345&quot;&quot;&quot;路由你可以看成就是出去ip和的port之后的地址&quot;&quot;&quot;url()方法 1.第一个参数其实是一个正则表达式 2.一旦第一个参数匹配到了内容直接结束匹配 执行对应的视图函数url(r&#x27;^test/$&#x27;,views.test) 无名分组1234567url(r&#x27;^test/\\d+/$&#x27;,views.test)# 正则表达式分组:给正则表达式前后加一个小括号url(r&#x27;^test/(\\d+)/$&#x27;,views.test)&quot;&quot;&quot;无名分组 将括号内正则表达式匹配到的内容当做位置参数传递给后面的视图函数&quot;&quot;&quot; 有名分组12345url(r&#x27;^testadd/(?P&lt;id&gt;\\d+)/$&#x27;,views.testadd)&quot;&quot;&quot;有名分组 将括号内正则表达式匹配到的内容当做关键字参数传递给后面的视图函数&quot;&quot;&quot; 是否可以结合使用123456url(r&#x27;^test1/(\\d+)/(?P&lt;id&gt;\\d+)/$&#x27;,views.test1)1.无名有名分组不能混合使用url(r&#x27;^test2/(\\d+)/(\\d+)/$&#x27;,views.test2),url(r&#x27;^test2/(?P&lt;id&gt;\\d+)/(?P&lt;id1&gt;\\d+)/$&#x27;,views.test2)2.可以单个重复使用 反向解析12345678910当路由频繁变化的时候,html界面上的连接地址如何做到动态解析# 1.给路由与视图函数对应关系添加一个别名(名字自己指定 只要不冲突即可) url(r&#x27;^index/&#x27;,views.index,name=&#x27;index_name&#x27;)# 2.根据该别名动态解析出一个结果，该结果可以直接访问到对应的路由 前端 &lt;a href=&quot;&#123;% url &#x27;index_name&#x27; %&#125;&quot;&gt;111&lt;/a&gt; 后端 from django.shortcuts import reverse reverse(&#x27;index_name&#x27;) ps:redirect括号内也可以直接写别名 无名有名反向解析123456789101112131415url(r&#x27;^index/(\\d+)/&#x27;,views.index,name=&#x27;index_name&#x27;)后端 reverse(&#x27;index_name&#x27;,args=(1,)) # 只要给个数字即可前端 &lt;a href=&quot;&#123;% url &#x27;index_name&#x27; 1 %&#125;&quot;&gt;&lt;/a&gt; # 只要给个数字即可 url(r&#x27;^index/(?P&lt;id&gt;\\d+)/&#x27;,views.index,name=&#x27;index_name&#x27;)后端 reverse(&#x27;index_name&#x27;,kwargs=&#123;&#x27;id&#x27;:123&#125;) # 只要给个数字即可前端 &lt;a href=&quot;&#123;% url &#x27;index_name&#x27; id=666 %&#125;&quot;&gt;&lt;/a&gt; # 只要给个数字即可 总结 无名有名都可以使用一种(无名)反向解析的形式 作业1231.整理今日笔记2.使用无名有名分组 与 反向解析 完成昨天的用户增删改查的功能 一定要尝试着自己写","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"02、静态文件配置、request对象方法、pycharm链接数据库、django链接MySQL、django之orm（简介、实操、字段增删改查、数据增删改查）","slug":"Django_day02","date":"2018-09-20T06:04:02.000Z","updated":"2022-05-14T03:30:28.117Z","comments":true,"path":"2018/09/20/Django_day02/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day02/","excerpt":"","text":"静态文件配置 123456789101112131415161718192021222324252627282930313233343536373839&quot;&quot;&quot;我们之所以能够在浏览器地址栏里面输入网址就可以拿到对应的资源是因为开发者早已经提前开设了该资源的访问接口&quot;&quot;&quot;1.静态文件 写好之后不会自动动态改变的文件资源，比如我们写好的css文件、js文件、图片文件、第三方框架文件 我们默认将所有的静态文件都放在一个static文件夹内 我们需要自己在django目录下创建该文件夹 static目录下基本还会再分几个文件夹 static css js img 第三方文件资源 # 在加在静态资源的时候没有开设对应的访问接口2.配置 settings.py配置文件 # 静态文件配置 STATICFILES_DIRS = [ os.path.join(BASE_DIR,&#x27;static&#x27;) ] &lt;script src=&quot;/static/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;3.进阶操作 STATIC_URL = &#x27;/static/&#x27; # 接口前缀 &quot;&quot;&quot; 如果你想要访问静态文件资源，那么必须以static开头 &lt;script src=&quot;/static/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 你书写了接口前缀之后 就拥有了访问下列列表中所有文件夹内部资源的权限 &quot;&quot;&quot; # 静态文件配置 STATICFILES_DIRS = [ os.path.join(BASE_DIR,&#x27;static&#x27;), os.path.join(BASE_DIR,&#x27;static1&#x27;), os.path.join(BASE_DIR,&#x27;static2&#x27;), ]4.动态解析 &#123;% load static %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/css/bootstrap.min.css&#x27; %&#125;&quot;&gt; &lt;script src=&quot;&#123;% static &#x27;bootstrap-3.3.7-dist/js/bootstrap.min.js&#x27; %&#125;&quot;&gt;&lt;/script&gt; request对象方法 1234567891011121314151617181920212223242526272829303132333435361.form表单回顾 form表单默认使用的是get请求 action 控制后端提交的路径 1.不写:默认朝当前页面地址提交数据 2.后缀:/index/ 3.全写:https://www.mzitu.com method get post2.request对象方法 request.method 获取当前请求的请求方法并且结果是一个纯大写的字符串类型 request.POST # 直接看成是字典即可 获取用户提交post请求过来的基本数据(不包含文件) get() # 获取列表最后一个元素 getlist() # 获取整个列表 request.GET # 直接看成是字典即可 获取url问好后面的数据 get() # 获取列表最后一个元素 getlist() # 获取整个列表 request.FILES # 直接看成是字典即可 获取用户上传的文件数据 &#x27;&#x27;&#x27;form表单如果需要携带文件数据 那么要添加参数 &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &#x27;&#x27;&#x27; get() # 获取列表最后一个元素 getlist() # 获取整个列表 &quot;&quot;&quot;视图函数书写格式 def login(request): if request.method == &#x27;POST&#x27;: return HttpResponse(&quot;我很气愤&quot;) return render(request,&#x27;login.html&#x27;)&quot;&quot;&quot; pycharm链接数据库 12DataBase工具栏 下载对应的驱动即可 django链接MySQL 12345678910111213141516&quot;&quot;&quot;django默认使用自带的sqlite3&quot;&quot;&quot;1.配置文件修改配置 DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;db666&#x27;, # 一定要事先创建好才能指定 &#x27;HOST&#x27;:&#x27;127.0.0.1&#x27;, &#x27;PORT&#x27;:3306, &#x27;USER&#x27;:&#x27;root&#x27;, &#x27;PASSWORD&#x27;:&#x27;123&#x27;, &#x27;CHARSET&#x27;:&#x27;utf8&#x27; &#125;&#125;2.在项目文件夹或者应用文件夹内的__init__.py文件中书写固定的代码 import pymysql pymysql.install_as_MySQLdb() django orm简介123456789&quot;&quot;&quot;orm:对象关系映射&quot;&quot;&quot;orm目的就是为了能够让不懂SQL语句的人通过python面向对象的知识点也能够轻松自如的操作数据库类 &gt;&gt;&gt; 表对象 &gt;&gt;&gt; 表里面的数据对象点属性 &gt;&gt;&gt; 字段对应的值# 缺陷:sql封装死了 有时候查询速度很慢 orm实操1234567891011121314151617181920211.我们的模型类需要写在应用下的models.py文件中 class User(models.Model): # id int primary key auto_increment id = models.AutoField(primary_key=True) # name varchar(32) name = models.CharField(max_length=32) # CharField必须要加max_length参数 # age int age = models.IntegerField()****************************************************************************2.数据库迁移命令 1.将数据库修改操作先记录到小本本上(对应应用下的migrations文件夹) python3 manage.py makemigrations 2.真正的执行数据库迁移操作 python3 manage.py migrate # 只要动了models.py中跟数据库相关的代码就必须重新执行上述两条命令****************************************************************************3.针对主键字段 class User1(models.Model): # 如果你不指定主键 那么orm会自动帮你创建一个名为id的主键字段 # 如果你想让主键字段名不叫id 叫uid、sid、pid等则需要自己手动指定 username = models.CharField(max_length=32) 字段的增删改查123456789# 增pwd = models.IntegerField(&#x27;密码&#x27;,null=True) # 该字段可以为空is_delete = models.IntegerField(default=0) # 默认值# 改直接改代码然后执行数据库迁移命令即可# 删注释掉代码然后执行数据库迁移命令即可 数据的增删改查1234567891011121314151617181920# 1.查询数据# select * from user where name=username;user_obj = models.User.objects.filter(name=username).first()# 2.添加数据# insert into user(name,pwd) values(username,password);models.User.objects.create(name=username,pwd=password)# 3.查询所有的数据# select * from user;models.User.objects.all() # [obj1,obj2,obj3,obj4]# 4.修改数据models.User.objects.filter(id=edit_id).update(name=username,pwd=password)edit_obj.name = usernameedit_obj.pwd = passwordedit_obj.save()# 5.删除数据models.User.objects.filter(id=delete_id).delete() 补充11.针对浏览器缓存我们可以认为的限制不适用缓存 作业 121.整理今日内容至笔记2.自己尝试着搭建一个增删改查页面","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"01、软件开发架构、HTTP协议、请求方法、web框架（纯手写、基于wsgiref写、封装、动静态网页、总结）、主流web框架、django框架（命令行模式、app、pycharm快捷方式、django目录结构、view里的三板斧）","slug":"Django_day01","date":"2018-09-20T06:04:01.000Z","updated":"2022-05-14T03:24:27.194Z","comments":true,"path":"2018/09/20/Django_day01/","link":"","permalink":"https://chenxiao0629.github.io/2018/09/20/Django_day01/","excerpt":"","text":"软件开发架构1231.c/s架构2.b/s架构# b/s本质也是c/s架构 HTTP协议1234567891011121314151617181920212223242526272829&quot;&quot;&quot;规定了浏览器与服务端之间数据交互的格式&quot;&quot;&quot;# 1.四大特性 1.基于TCP、IP作用于应用层之上的协议 2.基于请求响应 3.无状态 见你千百遍我都当你如初见 ps:为了保存状态，后面会学cookie、session、token... 4.无(短)连接 ps:长连接:websocket# 2.数据格式 请求数据格式 请求首行(请求方法...) 请求头(一大堆K:V键值对) 请求体(并不是所有的请求方法都有 主要用来携带敏感性数据) 响应数据格式 响应首行(响应状态码...) 响应头(一大堆K:V键值对) 响应体(展示给用户的数据)# 3.响应状态码 用简单的数字来表示一串中文意思 1XX:服务端已经接受到你的数据正在处理，你可以继续提交 2XX:200 OK&gt;&gt;&gt;:请求成功 3XX:重定向(原本想访问A但是内部跳到B) 4XX:403当前请求不符合条件 404请求资源不存在 5XX:服务器内部错误 ps:除了上述统一的响应状态码之外，公司还可以自定义自己的状态码 请求方法12345678910111.get请求 朝别人索要数据2.post请求 朝别人提交数据&quot;&quot;&quot;上述两种请求都可以携带额外的参数get请求(网址栏的网址) url?username=jason&amp;hobby=mnpost请求 数据是放在请求体里面的&quot;&quot;&quot; 纯手撸web框架1234567891011121314151617181920212223242526272829303132333435363738394041424344import socket&quot;&quot;&quot;b&#x27;GET / HTTP/1.1\\r\\n （请求首行）Host: 127.0.0.1:8080\\r\\n （请求头，全是kv键值对）Connection: keep-alive\\r\\nsec-ch-ua: &quot;Google Chrome&quot;;v=&quot;89&quot;, &quot;Chromium&quot;;v=&quot;89&quot;, &quot;;Not A Brand&quot;;v=&quot;99&quot;\\r\\nsec-ch-ua-mobile: ?0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\\r\\nSec-Fetch-Site: none\\r\\nSec-Fetch-Mode: navigate\\r\\nSec-Fetch-User: ?1\\r\\nSec-Fetch-Dest: document\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n （请求头，全是kv键值对）\\r\\n请求体&#x27;&quot;&quot;&quot;server = socket.socket() # 默认就是TCP协议server.bind((&#x27;127.0.0.1&#x27;,8080))server.listen(5)while True: conn, addr = server.accept() # 三次四次挥手 data = conn.recv(1024) res = data.decode(&#x27;utf8&#x27;) conn.send(b&#x27;HTTP/1.1 200 OK\\r\\n\\r\\n&#x27;) # 字符串切割获取地址 path = res.split(&#x27; &#x27;)[1] # 判断地址 if path == &#x27;/index&#x27;: # conn.send(b&#x27;index&#x27;) with open(r&#x27;fh.html&#x27;,&#x27;rb&#x27;) as f: data = f.read() conn.send(data) elif path == &#x27;/login&#x27;: conn.send(b&#x27;login&#x27;) conn.close() 问题 服务端代码重复 手动处理http数据格式过于繁琐 基于wsgiref模块撸12345678910111213141516171819202122# 解决了上述两个问题from wsgiref.simple_server import make_serverdef run(request,response): &quot;&quot;&quot; :param request:请求相关的所有数据 :param response:响应相关的所有数据 :return: &quot;&quot;&quot; response(&#x27;200 OK&#x27;,[]) current_path = request.get(&quot;PATH_INFO&quot;) if current_path == &#x27;/index&#x27;: return [b&#x27;index&#x27;] elif current_path == &#x27;/login&#x27;: return [b&#x27;login&#x27;] return [b&#x27;404 error&#x27;]if __name__ == &#x27;__main__&#x27;: server = make_server(&#x27;127.0.0.1&#x27;,8080,run) # 一旦被访问会全部交给run函数处理 server.serve_forever() 问题 网址很多的情况下如何匹配 网址多匹配如何解决 功能复杂代码块如何解决 封装处理1234567891011121314151617181920212223241.定义一个网址与功能函数的对应关系 # 地址与功能的对应关系 urls = [ (&#x27;/index&#x27;,index_func), (&#x27;/login&#x27;,login_func), (&#x27;/reg&#x27;,reg_func), ]2.按照功能的不同划分成不同的py文件 urls.py views.py 服务端.py3.书写服务端代码 func = None # for循环判断 for url_tuple in urls: # (),() if current_path == url_tuple[0]: # 将匹配到的函数名赋值给func变量 func = url_tuple[1] break # 判断func是否有值 if func: # 执行对应的函数 res = func(request) else: res = errors(request) return [bytes(res,encoding=&#x27;utf8&#x27;)] 动静态网页12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061静态网页 数据全部都是写死的动态网页 数据来源于后端(代码、数据库) 1.访问网址展示当前时间(由后端模块生成并展示到html页面) def get_time_func(request): from datetime import datetime current_time = datetime.now().strftime(&#x27;%Y-%m-%d %X&#x27;) with open(r&#x27;get_time.html&#x27;,&#x27;r&#x27;,encoding=&#x27;utf8&#x27;) as f: data = f.read() # 字符串 data = data.replace(&#x27;sadadadad&#x27;,current_time) return data2.后端有一个字典，将该字段传递给html页面，并且在该页面上还可以使用字典取值的各种操作 jinja2模块 pip3 install jinja2 ps:该模块是flask框架必备的模块 所以下载flask也会自动下载该模块 def get_dict_func(request): user_dict = &#123;&quot;username&quot;:&#x27;jason&#x27;,&#x27;password&#x27;:123,&#x27;hobby&#x27;:&#x27;study&#x27;&#125; from jinja2 import Template with open(r&#x27;templates/get_dict.html&#x27;,&#x27;r&#x27;,encoding=&#x27;utf8&#x27;) as f: data = f.read() # 字符串 temp = Template(data) # 将user_dict传递给get_dict.html页面 在该页面上使用变量名user_data调用 res = temp.render(user_data=user_dict) return res 模板语法(用近似于python的语法在html文件上操作数据) &#123;&#123;user_data&#125;&#125; &#123;&#123;user_data[&#x27;username&#x27;]&#125;&#125; &#123;&#123;user_data.get(&#x27;password&#x27;)&#125;&#125; &#123;&#123;user_data.hobby&#125;&#125; &#123;%for user_dict in data_list%&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123;user_dict.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user_dict.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;user_dict.age&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;%endfor%&#125;3.获取MySQL数据库数据展示到页面上 def get_db_func(request): import pymysql conn = pymysql.connect( host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, db=&#x27;db666&#x27;, charset=&#x27;utf8&#x27;, autocommit=True ) cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) sql = &#x27;select * from userinfo&#x27; affect_rows = cursor.execute(sql) res1 = cursor.fetchall() # [&#123;&#125;,&#123;&#125;,&#123;&#125;] with open(r&#x27;templates/get_db.html&#x27;,&#x27;r&#x27;,encoding=&#x27;utf8&#x27;) as f: data = f.read() # 字符串 temp = Template(data) # 将user_dict传递给get_dict.html页面 在该页面上使用变量名user_data调用 res = temp.render(data_list=res1) return res 总结1234567891011121314151.纯手撸web框架2.wsgiref模块 1.封装了socket代码 2.处理了http数据格式3.根据功能的不同拆分成不同的文件夹 urls.py 路由与视图函数对应关系 views.py 视图函数 templates 模板文件夹 # 1.第一步添加路由与视图函数的对应关系 # 2.去views中书写功能代码 # 3.如果需要使用到html则去模板文件夹中操作4.jinja2模板语法 &#123;&#123;&#125;&#125; &#123;%%&#125;5.简易版本web框架流程图 主流web框架1234567891011121314151617181920212223242526271.django框架 大而全,自带的功能组件非常非常非常的多!类似于航空母舰 2.flask框架 小而精,自身的功能组件非常非常非常的少!类似于游骑兵 但是第三方模块非常之多,如果把第三方模块全部叠加起来完全可以盖过django 有时候也会受限于第三方模块 ps:三行代码就可以启动一个flask后端服务3.tornado框架 异步非阻塞 速度非常的快 快到可以开发游戏服务器ps:Sanic、FastAPI...&quot;&quot;&quot;注意:小白不要同时学习两个及以上&quot;&quot;&quot; A:socket部分B:路由与视图匹配C:模板语法 django A:用的是wsgiref模块 B:自己写的 C:自己写的flask A:用的是wsgiref模块封装之后werkzeug B:自己写的 C:jinja2模块tornado A、B、C都是自己写的 django框架12345678910111213# 注意事项 1.计算机名称不能有中文 2.项目名和py文件名最好也不要使用中文 3.django版本问题 1.X 2.X 3.X ps:版本选择1.11.11版本 # 命令行下载 pip3 install django==1.11.11# 测试是否安装完成 django-admin 命令行模式12345678910111.创建django项目 django-admin startproject 项目名2.启动django项目 cd 项目名 python3 manage.py runserver ip:port ps:如果报错需要修改py文件源码 D:\\Python38\\lib\\site-packages\\django\\contrib\\admin\\widgets.py 152行后面的逗号去掉即可!!! &#x27;%s=%s&#x27; % (k, v) for k, v in params.items()3.创建app python manage.py startapp app名字 app123456django是一款专门开发app(应用)的软件我们创建一个django项目之后类似于创建了一所大学而app就类似于大学里面的各个学院，每个学院都可以有自己独立的各项功能职责django相当于是一个空壳子用来给各个学院提供资源!!!&quot;&quot;&quot;我们创建的app一定要去settings文件中注册才能生效&quot;&quot;&quot; pycharm快捷方式1234561.new project django 项目名 解释器 应用名 # pycharm会自动帮你创建一个app 总结123命令行与pycharm创建不同点 1.命令行不会自动创建templates模板文件夹 2.命令行也不会自动在配置文件中配置模板文件夹路径 django目录结构123456789101112131415mysite mysite文件夹 # 项目同名文件夹 settings.py # django暴露给用户可以配置的配置文件 urls.py # 路由与视图函数(可以是函数也可是类)对应关系(路由层) wsgi.py # 忽略 app01文件夹 # 应用(可以有多个) migrations文件夹 # 存储数据库记录相关(类似于操作日志) admin.py # django后台管理 apps.py # 注册app models.py # 数据库相关(模型层) tests.py # 测试文件 views.py # 视图函数(视图层) db.sqlite3 # django自带的小型数据库 manage.py # django入口文件 templates # 模板文件(存储html文件)(模板层) 小白必会三板斧123456789101112131415161718191.HttpResponse 返回字符串2.render 返回html页面，还可以使用模板语法3.redirect 重定向def index(request): print(&#x27;123&#x27;) # 暂且记忆返回值是字符串类型 # return HttpResponse(&#x27;hello django!&#x27;) # 返回给浏览器了 ctime = time.strftime(&#x27;%Y-%m-%d %X&#x27;) a = 1 b = 2 print(locals()) # return render(request, &#x27;index.html&#x27;, &#123;&#x27;ctime11111&#x27;:ctime, &#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;) # return render(request, &#x27;index.html&#x27;, locals()) # return redirect(&#x27;http://www.baidu.com&#x27;) return redirect(&#x27;/admin/&#x27;) # ip+port/admin 作业12341.理解上午框架推导思路(代码无需掌握)2.独立完成django安装及启动3.使用django展示数据库数据 urls.py views.py templates","categories":[],"tags":[{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"}]},{"title":"04、多表查询思路、navicat可视化软件、多表查询练习题、Python操作MySQL、SQL注入问题、MySQL知识补充","slug":"mysql_day04","date":"2018-07-23T06:04:04.000Z","updated":"2022-05-13T13:05:00.978Z","comments":true,"path":"2018/07/23/mysql_day04/","link":"","permalink":"https://chenxiao0629.github.io/2018/07/23/mysql_day04/","excerpt":"","text":"多表查询思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 数据准备#建表create table dep(id int primary key auto_increment,name varchar(20) );create table emp(id int primary key auto_increment,name varchar(20),sex enum(&#x27;male&#x27;,&#x27;female&#x27;) not null default &#x27;male&#x27;,age int,dep_id int);#插入数据insert into dep values(200,&#x27;技术&#x27;),(201,&#x27;人力资源&#x27;),(202,&#x27;销售&#x27;),(203,&#x27;运营&#x27;),(205,&#x27;保洁&#x27;);insert into emp(name,sex,age,dep_id) values(&#x27;jason&#x27;,&#x27;male&#x27;,18,200),(&#x27;egon&#x27;,&#x27;female&#x27;,48,201),(&#x27;kevin&#x27;,&#x27;male&#x27;,18,201),(&#x27;nick&#x27;,&#x27;male&#x27;,28,202),(&#x27;owen&#x27;,&#x27;male&#x27;,18,203),(&#x27;jerry&#x27;,&#x27;female&#x27;,18,204);# 1.查询jason所在的部门名称 涉及到SQL查询题目 一定要先明确到底需要几张表 1.先查询jason所在的部门编号 select dep_id from emp where name=&#x27;jason&#x27;; 2.根据部门编号查询部门名称 select name from dep where id=(select dep_id from emp where name=&#x27;jason&#x27;); &quot;&quot;&quot;一条SQL语句的查询结果既可以看成是一张表也可以看成是查询条件&quot;&quot;&quot; &quot;&quot;&quot;多表查询的思路 1.子查询 将SQL语句查询的结果括号括起来当做另外一条SQL语句的条件 大白话:就是我们日常生活中解决问题的方式&gt;&gt;&gt;:分步操作 2.连表操作(重要) 先将需要使用到的表拼接成一张大表 之后基于单表查询完成 inner join 内连接 left join 左连接 right join 右连接 union 全连接&quot;&quot;&quot;# 涉及到多表查询的时候 字段名称容易冲突 需要使用表名点字段的方式区分# inner join:只拼接两张表中共有的部分select * from emp inner join dep on emp.dep_id = dep.id;# left join:以左表为基准展示所有的内容 没有的NULL填充select * from emp left join dep on emp.dep_id = dep.id;# right join:以右表为基准展示所有的内容 没有的NULL填充select * from emp right join dep on emp.dep_id = dep.id;# union:左右表所有的数据都在 没有的NULL填充select * from emp left join dep on emp.dep_id = dep.idunionselect * from emp right join dep on emp.dep_id = dep.id;&quot;&quot;&quot;疑问:上述操作一次只能连接两张表 如何做到多张表? 将两张表的拼接结果当成一张表与跟另外一张表做拼接 依次往复 即可拼接多张表&quot;&quot;&quot; navicat可视化软件123456789内部封装了很多SQL的操作 用户只需要鼠标点点点 自动构建SQL语句并执行下载使用:需要破解基本使用 navicat可以看成是很多数据库软件的客户端 MySQL的注释语法 # 注释 -- 注释 多表查询练习题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101、查询所有的课程的名称以及对应的任课老师姓名4、查询平均成绩大于八十分的同学的姓名和平均成绩7、查询没有报李平老师课的学生姓名8、查询没有同时选修物理课程和体育课程的学生姓名9、查询挂科超过两门(包括两门)的学生姓名和班级###########################编写SQL不要想着一次性写完 可以边写边看######################################-- 1、查询所有的课程的名称以及对应的任课老师姓名-- SELECT-- teacher.tname,-- course.cname -- FROM-- teacher-- INNER JOIN course ON teacher.tid = course.teacher_id;-- 4、查询平均成绩大于八十分的同学的姓名和平均成绩# 1.先确定需要使用到的表 # 2.在思考多表查询的方式# 第一步先查询成绩表中 平均成绩大于80的学生编号# 1.1 按照学生id分组并获取平均成绩-- select student_id,avg(num) from score group by student_id;# 1.2 筛选出平均成绩大于80的数据 (针对聚合函数的字段结果 最好起别名防止冲突)-- select student_id,avg(num) as avg_num from score group by student_id having avg(num) &gt; 80;# 1.3 将上述SQL的结果与student表拼接-- SELECT-- student.sname,-- t1.avg_num -- FROM-- student-- INNER JOIN ( SELECT student_id, avg( num ) AS avg_num FROM score GROUP BY student_id HAVING avg( num ) &gt; 80 ) AS t1 ON student.sid = t1.student_id;-- 7、查询没有报李平老师课的学生姓名# 1.先查询李平老师教授的课程编号-- select course.cid from course where teacher_id = -- (select tid from teacher where tname =&#x27;李平老师&#x27;);# 2.根据课程id号筛选出所有报了的学生id号-- select distinct score.student_id from score where course_id in (select course.cid from course where teacher_id = -- (select tid from teacher where tname =&#x27;李平老师&#x27;));# 3.去学生表中根据id号取反筛选学生姓名-- SELECT-- student.sname -- FROM-- student -- WHERE-- sid NOT IN (-- SELECT DISTINCT-- score.student_id -- FROM-- score -- WHERE-- course_id IN ( SELECT course.cid FROM course WHERE teacher_id = ( SELECT tid FROM teacher WHERE tname = &#x27;李平老师&#x27; ) ) -- );-- 8、查询没有同时选修物理课程和体育课程的学生姓名(只要了报了一门的 两门和一门没报的都不要)# 1.先获取两门课程的id号-- select course.cid from course where cname in (&#x27;物理&#x27;,&#x27;体育&#x27;);# 2.再去分数表中先筛选出所有报了物理和体育的学生id(两门 一门)-- select * from score where course_id in (select course.cid from course where cname in (&#x27;物理&#x27;,&#x27;体育&#x27;));# 3.如何筛选出只报了一门的学生id 按照学生id分组 然后计数 并过滤出计数结果为1的数据-- select score.student_id from score where course_id in (select course.cid from course where cname in (&#x27;物理&#x27;,&#x27;体育&#x27;))-- group by score.student_id-- having count(score.course_id) = 1-- ;# 4.根据学生id号去student表中筛选学生姓名-- SELECT-- student.sname -- FROM-- student -- WHERE-- sid IN (-- SELECT-- score.student_id -- FROM-- score -- WHERE-- course_id IN ( SELECT course.cid FROM course WHERE cname IN ( &#x27;物理&#x27;, &#x27;体育&#x27; ) ) -- GROUP BY-- score.student_id -- HAVING-- count( score.course_id ) = 1 -- );-- 9、查询挂科超过两门(包括两门)的学生姓名和班级# 1.先筛选出小于60分的数据-- select * from score where num &lt; 60;# 2.按照学生id分组 然后统计挂科数量-- select student_id,count(course_id) from score where num &lt; 60 group by student_id;# 3.筛选出挂科超过两门的学生id-- select student_id from score where num &lt; 60 group by student_id-- having count(course_id) &gt;=2;# 4.先将上述结果放在一边 去连接student和class表SELECT student.sname, class.caption FROM class INNER JOIN student ON class.cid = student.class_id WHERE student.sid IN ( SELECT student_id FROM score WHERE num &lt; 60 GROUP BY student_id HAVING count( course_id ) &gt;= 2 );更多练习https://www.cnblogs.com/Dominic-Ji/p/10875493.html python操作MySQL1234567891011121314151617181920212223第三方模块 pymysqlpip3 install pymysqlimport pymysql# 连接MySQL服务端conn = pymysql.connect( host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, database=&#x27;db8_2&#x27;, charset=&#x27;utf8&#x27;)# 产生一个游标对象cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)# 编写SQL语句sql = &#x27;select * from teacher&#x27;affect_rows = cursor.execute(sql)print(affect_rows)# 获取执行结果print(cursor.fetchall()) SQL注入问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import pymysql# 连接MySQL服务端conn = pymysql.connect( host=&#x27;127.0.0.1&#x27;, port=3306, user=&#x27;root&#x27;, password=&#x27;123&#x27;, database=&#x27;db8_3&#x27;, charset=&#x27;utf8&#x27;, autocommit=True # 针对增 改 删自动二次确认)# 产生一个游标对象cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) # 参数表示：将取回值以字典形式显示# 编写SQL语句username = input(&#x27;username&gt;&gt;&gt;:&#x27;).strip()password = input(&#x27;password&gt;&gt;&gt;:&#x27;).strip()sql = &quot;select * from userinfo where name=%s and pwd=%s&quot;cursor.execute(sql,(username,password))data = cursor.fetchall()if data: print(data) print(&#x27;登录成功&#x27;)else: print(&#x27;用户名或密码错误&#x27;)# 1.只需要用户名也可以登录# 2.不需要用户名和密码也可以登录&quot;&quot;&quot;SQL注入的原因 是由于特殊符号的组合会产生特殊的效果 实际生活中 尤其是在注册用户名的时候 会非常明显的提示你很多特殊符号不能用 原因也是一样的结论:设计到敏感数据部分 不要自己拼接 交给现成的方法拼接即可&quot;&quot;&quot;# sql = &#x27;insert into userinfo(name,pwd) values(&quot;jason&quot;,&quot;123&quot;),(&quot;kevin&quot;,&quot;321&quot;)&#x27;# res = cursor.execute(sql)# print(res)&quot;&quot;&quot;在使用代码进行数据操作的时候 不同操作的级别是不一样的 针对查无所谓 针对增 改 删都需要二次确认 conn.commit()&quot;&quot;&quot; MySQL补充知识123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 事务(重要) ACID A:原子性 C:一致性 I:隔离性 D:持久性原子性（atomicity） 一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。一致性（consistency） 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。隔离性（isolation） 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。持久性（durability） 持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响 事务相关操作 start transaction; # 开启事务 诸多SQL操作 rollback # 回滚到操作之前的状态 commit # 确认事务操作 之后不能回滚 # 先介绍事务的三个关键字 再去用表实际展示效果create table user(id int primary key auto_increment,name char(32),balance int);insert into user(name,balance)values(&#x27;jason&#x27;,1000),(&#x27;egon&#x27;,1000),(&#x27;tank&#x27;,1000);# 修改数据之前先开启事务操作start transaction;# 修改操作update user set balance=900 where name=&#x27;jason&#x27;; #买支付100元update user set balance=1010 where name=&#x27;egon&#x27;; #中介拿走10元update user set balance=1090 where name=&#x27;tank&#x27;; #卖家拿到90元# 回滚到上一个状态rollback;# 开启事务之后，只要没有执行commit操作，数据其实都没有真正刷新到硬盘commit;&quot;&quot;&quot;开启事务检测操作是否完整，不完整主动回滚到上一个状态，如果完整就应该执行commit操作&quot;&quot;&quot;# 站在python代码的角度，应该实现的伪代码逻辑，try: update user set balance=900 where name=&#x27;jason&#x27;; #买支付100元 update user set balance=1010 where name=&#x27;egon&#x27;; #中介拿走10元 update user set balance=1090 where name=&#x27;tank&#x27;; #卖家拿到90元except 异常: rollback;else: commit;","categories":[],"tags":[{"name":"5、数据库之MySQL","slug":"5、数据库之MySQL","permalink":"https://chenxiao0629.github.io/tags/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMySQL/"}]},{"title":"03、外键、表与表之间建立关系、外键约束、查询关键字（select与from、where筛选、group by分组、having过滤、distinct去重、order by排序、limit分页、regexp正则）","slug":"mysql_day03","date":"2018-07-23T06:04:03.000Z","updated":"2022-05-13T13:55:00.651Z","comments":true,"path":"2018/07/23/mysql_day03/","link":"","permalink":"https://chenxiao0629.github.io/2018/07/23/mysql_day03/","excerpt":"","text":"外键12345678910111213141516171819202122# 外键前戏 创建一张员工表 id name age dep_name dep_desc&quot;&quot;&quot;缺陷1.表的重点不清晰 可以忽略 到底是员工表还是部门表2.表中相关字段一直在重复存储 可以忽略 浪费存储空间3.表的扩展性极差,牵一发而动全身 不能忽略&quot;&quot;&quot; 解决方式 将上述一张表拆分成两张表 emp与dep # 上述三个缺陷全部解决&quot;&quot;&quot;带来了一个小问题 表与表之间的数据没有对应关系了&quot;&quot;&quot;外键字段&gt;&gt;&gt;:部门编号 其实就是用来标识表与表之间的数据关系 # 简单的理解为该字段可以让你去到其他表中查找数据 表与表之间建关系123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102表关系总共就四种 一对多 多对多 一对一 没有关系&quot;&quot;&quot;判断表关系的方式:换位思考&quot;&quot;&quot;1.一对多 以员工和部门表为例 先站在员工表的基础之上 问:一个员工信息能否对应多个部门信息 答:不可以 再站在部门表的基础之上 问:一个部门信息能否对应多个员工信息 答:可以 结论:一个可以一个不可以 那么表关系就是&quot;一对多&quot; 员工表是多 部门表是一 &quot;&quot;&quot; 针对一对多的表关系 外键字段建在多的一方 &quot;&quot;&quot; # 表关系没有&#x27;多对一&#x27;一说 都是&#x27;一对多&#x27;&quot;&quot;&quot;使用SQL语句建立真正意义上的表关系 可以先创建不含外键字段的基本表之后再添加外键字段 create table emp( id int primary key auto_increment, name varchar(32), age int, dep_id int, foreign key(dep_id) references dep(id) ); create table dep( id int primary key auto_increment, dep_name varchar(32), dep_desc varchar(254) );&quot;&quot;&quot;2.多对多关系 以书籍表与作者表为例 先站在书籍表的基础之上 问:一个书籍信息能否对应多个作者信息 答:可以 再站在作者表的基础之上 问:一个作者信息能否对应多个书籍信息 答:可以 结论:两个都可以 那么表关系就是&quot;多对多&quot; # 多对多表关系 需要单独开设第三张表存储(并且第三张表可以不绑定)&quot;&quot;&quot;create table book( id int primary key auto_increment, title varchar(32), price float(6,2));create table author( id int primary key auto_increment, name varchar(32), age int);create table book2author( id int primary key auto_increment, author_id int, book_id int, foreign key(author_id) references author(id) on update cascade # 级联更新 on delete cascade, # 级联删除 foreign key(book_id) references book(id) on update cascade # 级联更新 on delete cascade # 级联删除);&quot;&quot;&quot; 3.一对一表关系 作者表与作者详情表 先站在作者表的基础之上 问:一个作者信息能否对应多个作者详情信息 答:不可以 再站在作者详情表的基础之上 问:一个作者详情信息能否对应多个作者信息 答:不可以 结论:两个都不可以 那么表关系可能是&quot;一对一&quot;或者&quot;没有关系&quot; # 外键字段建在任何一方都可以 但是推荐建在查询频率较高的表中&quot;&quot;&quot;create table author( id int primary key auto_increment, name varchar(32), age int, author_id int unique, foreign key(author_id) references author_detail(id) on update cascade # 级联更新 on delete cascade # 级联删除);create table author_detail( id int primary key auto_increment, phone varchar(32), address varchar(32));&quot;&quot;&quot; 外键约束123456789101112131415161718192021222324251.在创建表的时候 需要先创建被关联表(没有外键字段的表)2.在插入新数据的时候 应该先确保被关联表中有数据3.在插入新数据的时候 外键字段只能填写被关联表中已经存在的数据4.在修改和删除被关联表中的数据的时候 无法直接操作 如果想要数据之间自动修改和删除需要添加额外的配置 create table emp1( id int primary key auto_increment, name varchar(32), age int, dep_id int, foreign key(dep_id) references dep1(id) on update cascade # 级联更新 on delete cascade # 级联删除 ); create table dep1( id int primary key auto_increment, dep_name varchar(32), dep_desc varchar(254) );&quot;&quot;&quot;由于外键有实质性的诸多约束 当表特别多的时候外键的增多反而会增加耦合程度 所以在实际开发项目中 有时候并不会使用外键创建表关系 而是通过SQL语句层面 建立逻辑意义上的表关系 eg:操作员工表的sql执行完毕之后 立刻跟着执行操作部门的sql&quot;&quot;&quot; 查询关键字1234567891011121314151617181920212223242526272829303132333435# 数据准备create table emp( id int primary key auto_increment, name varchar(20) not null, sex enum(&#x27;male&#x27;,&#x27;female&#x27;) not null default &#x27;male&#x27;, #大部分是男的 age int(3) unsigned not null default 28, hire_date date not null, post varchar(50), post_comment varchar(100), salary double(15,2), office int, #一个部门一个屋子 depart_id int);#插入记录#三个部门：教学，销售，运营insert into emp(name,sex,age,hire_date,post,salary,office,depart_id) values(&#x27;jason&#x27;,&#x27;male&#x27;,18,&#x27;20170301&#x27;,&#x27;张江第一帅形象代言&#x27;,7300.33,401,1), #以下是教学部(&#x27;tom&#x27;,&#x27;male&#x27;,78,&#x27;20150302&#x27;,&#x27;teacher&#x27;,1000000.31,401,1),(&#x27;kevin&#x27;,&#x27;male&#x27;,81,&#x27;20130305&#x27;,&#x27;teacher&#x27;,8300,401,1),(&#x27;tony&#x27;,&#x27;male&#x27;,73,&#x27;20140701&#x27;,&#x27;teacher&#x27;,3500,401,1),(&#x27;owen&#x27;,&#x27;male&#x27;,28,&#x27;20121101&#x27;,&#x27;teacher&#x27;,2100,401,1),(&#x27;jack&#x27;,&#x27;female&#x27;,18,&#x27;20110211&#x27;,&#x27;teacher&#x27;,9000,401,1),(&#x27;jenny&#x27;,&#x27;male&#x27;,18,&#x27;19000301&#x27;,&#x27;teacher&#x27;,30000,401,1),(&#x27;sank&#x27;,&#x27;male&#x27;,48,&#x27;20101111&#x27;,&#x27;teacher&#x27;,10000,401,1),(&#x27;哈哈&#x27;,&#x27;female&#x27;,48,&#x27;20150311&#x27;,&#x27;sale&#x27;,3000.13,402,2),#以下是销售部门(&#x27;呵呵&#x27;,&#x27;female&#x27;,38,&#x27;20101101&#x27;,&#x27;sale&#x27;,2000.35,402,2),(&#x27;西西&#x27;,&#x27;female&#x27;,18,&#x27;20110312&#x27;,&#x27;sale&#x27;,1000.37,402,2),(&#x27;乐乐&#x27;,&#x27;female&#x27;,18,&#x27;20160513&#x27;,&#x27;sale&#x27;,3000.29,402,2),(&#x27;拉拉&#x27;,&#x27;female&#x27;,28,&#x27;20170127&#x27;,&#x27;sale&#x27;,4000.33,402,2),(&#x27;僧龙&#x27;,&#x27;male&#x27;,28,&#x27;20160311&#x27;,&#x27;operation&#x27;,10000.13,403,3), #以下是运营部门(&#x27;程咬金&#x27;,&#x27;male&#x27;,18,&#x27;19970312&#x27;,&#x27;operation&#x27;,20000,403,3),(&#x27;程咬银&#x27;,&#x27;female&#x27;,18,&#x27;20130311&#x27;,&#x27;operation&#x27;,19000,403,3),(&#x27;程咬铜&#x27;,&#x27;male&#x27;,18,&#x27;20150411&#x27;,&#x27;operation&#x27;,18000,403,3),(&#x27;程咬铁&#x27;,&#x27;female&#x27;,18,&#x27;20140512&#x27;,&#x27;operation&#x27;,17000,403,3); 查询关键字之select与from1234from控制的是查询哪张表select控制的是查询表里面的哪些字段 select * from emp; select id,name from emp; 查询关键字之where筛选1234567891011121314151617181920212223242526272829303132333435363738394041where筛选功能 &quot;&quot;&quot;模糊查询:没有明确的筛选条件 关键字:like 关键符号: %:匹配任意个数任意字符 _:匹配单个个数任意字符show variables like &#x27;%mode%se&#x27;;&quot;&quot;&quot;# 1.查询id大于等于3小于等于6的数据select id,name from emp where id &gt;= 3 and id &lt;= 6;select * from emp where id between 3 and 6; # 2.查询薪资是20000或者18000或者17000的数据select * from emp where salary = 20000 or salary = 18000 or salary = 17000;select * from emp where salary in (20000,18000,17000); # 简写# 3.查询员工姓名中包含o字母的员工姓名和薪资# 在你刚开始接触mysql查询的时候，建议你按照查询的优先级顺序拼写出你的sql语句&quot;&quot;&quot;先是查哪张表 from emp再是根据什么条件去查 where name like ‘%o%’再是对查询出来的数据筛选展示部分 select name,salary&quot;&quot;&quot;select name,salary from emp where name like &#x27;%o%&#x27;;# 4.查询员工姓名是由四个字符组成的员工姓名与其薪资select name,salary from emp where name like &#x27;____&#x27;;select name,salary from emp where char_length(name) = 4;# 5.查询id小于3或者大于6的数据select * from emp where id not between 3 and 6;# 6.查询薪资不在20000，18000，17000范围的数据select * from emp where salary not in (20000,18000,17000);# 7.查询岗位描述为空的员工名与岗位名 针对null不能用等号，只能用isselect name,post from emp where post_comment = NULL; # 查询为空！select name,post from emp where post_comment is NULL;select name,post from emp where post_comment is not NULL; 查询关键字之group by分组1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950分组&quot;&quot;&quot;按照某个指定的条件将单个单个的个体分成一个个整体 eg: 按照男女将人分组 按照肤色分组 按照年龄分组&quot;&quot;&quot;# 分组之后默认只能够直接过去到分组的依据 其他数据都不能直接获取 针对5.6需要自己设置sql_mode set global sql_mode = &#x27;only_full_group_by,STRICT_TRANS_TABLES,PAD_CHAR_TO_FULL_LENGTH&#x27;; # 聚合函数 聚合函数主要就是配合分组一起使用 max min sum count avg # 数据分组应用场景：每个部门的平均薪资，男女比例等# 1.按部门分组select * from emp group by post; # 分组后取出的是每个组的第一条数据select id,name,sex from emp group by post; # 验证&quot;&quot;&quot;设置sql_mode为only_full_group_by，意味着以后但凡分组，只能取到分组的依据，不应该在去取组里面的单个元素的值，那样的话分组就没有意义了，因为不分组就是对单个元素信息的随意获取&quot;&quot;&quot;set global sql_mode=&quot;strict_trans_tables,only_full_group_by&quot;;# 重新链接客户端select * from emp group by post; # 报错select id,name,sex from emp group by post; # 报错select post from emp group by post; # 获取部门信息# 强调:只要分组了，就不能够再“直接”查找到单个数据信息了，只能获取到组名# 2.获取每个部门的最高工资 # 以组为单位统计组内数据&gt;&gt;&gt;聚合查询(聚集到一起合成为一个结果)# 每个部门的最高工资select post,max(salary) from emp group by post;补充:在显示的时候还可以给字段取别名select post as &#x27;部门&#x27;,max(salary) as &#x27;最高工资&#x27; from emp group by post;as也可以省略 但是不推荐省 因为寓意不明确# 每个部门的最低工资select post,min(salary) from emp group by post;# 每个部门的平均工资select post,avg(salary) from emp group by post;# 每个部门的工资总和select post,sum(salary) from emp group by post;# 每个部门的人数select post,count(id) from emp group by post;统计的时候只要是非空字段 效果都是一致的 这里显示age，salary，id最后演示特殊情况post_comment 补充说明12345678910# group_concat 分组之后使用如果真的需要获取分组意外的数据字段 可以使用group_concat()# 每个部门的员工姓名select post,group_concat(name) from emp group by post;select post,group_concat(name,&#x27;|&#x27;,sex) from emp group by post;# concat 不分组使用select concat(name,sex) from emp;select concat(name,&#x27;|&#x27;,sex) from emp; 关键字之having过滤12345678&quot;&quot;&quot;where与having都是筛选功能 但是有区别 where在分组之前对数据进行筛选 having在分组之后对数据进行筛选我们一定要有一个简单的认识 一条SQL语句的结果也可以看成是一张全新的表&quot;&quot;&quot;select post,avg(salary) from emp where age&gt;30 group by post having avg(salary)&gt;10000; 关键字之distinct去重123# 对有重复的展示数据进行去重操作 一定要是重复的数据select distinct id,age from emp;select distinct post from emp; 关键字之order by排序12345678select * from emp order by salary asc; #默认升序排select * from emp order by salary desc; #降序排#先按照age降序排，在年轻相同的情况下再按照薪资升序排select * from emp order by age desc,salary asc; # 统计各部门年龄在10岁以上的员工平均工资，并且保留平均工资大于1000的部门，然后对平均工资进行排序select post,avg(salary) from emp where age&gt;10 group by post having avg(salary)&gt;1000 order by avg(salary) desc; 关键字之limit分页12345678# 限制展示条数select * from emp limit 3;# 查询工资最高的人的详细信息select * from emp order by salary desc limit 1;# 分页显示select * from emp limit 0,5; # 第一个参数表示起始位置，第二个参数表示的是条数，不是索引位置select * from emp limit 5,5; 关键字之regexp正则1select * from emp where name regexp &#x27;^j.*(n|y)$&#x27;;","categories":[],"tags":[{"name":"5、数据库之MySQL","slug":"5、数据库之MySQL","permalink":"https://chenxiao0629.github.io/tags/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMySQL/"}]},{"title":"02、存储引擎、MySQL基本数据类型、char与varchar对比、整型中括号内数字作用、枚举与集合类型、日期类型、创建表的完整语法、约束条件、自增的特性","slug":"mysql_day02","date":"2018-07-23T06:04:02.000Z","updated":"2022-05-13T13:54:30.191Z","comments":true,"path":"2018/07/23/mysql_day02/","link":"","permalink":"https://chenxiao0629.github.io/2018/07/23/mysql_day02/","excerpt":"","text":"存储引擎12345678910111213141516171819202122232425262728293031323334353637# 存储引擎可以看成是处理数据的不同方式# 查看存储引擎的方式 show engines; # 需要掌握的四个存储引擎 MyISAM MySQL5.5之前默认的存储引擎 不支持事务、行级锁和外键 针对数据的操作较于InnoDB不够安全 但是数据的存取速度较于InnoDB更快 InnoDB MySQL5.5之后默认的存储引擎 支持事务、行级锁和外键 针对数据的操作更加的安全 memory 基于内存存取数据 速度最快但是断电立刻丢失 blackhole 写入其中的数据都会立刻消失 类似于垃圾处理站 # 存储引擎：创建表的不同 create table t1(id int) engine=myisam; create table t2(id int) engine=innodb; create table t3(id int) engine=memory; create table t4(id int) engine=blackhole; &quot;&quot;&quot; MyISAM会创建三个文件 .frm 表结构文件 .MYD 表数据文件 .MYI 表索引文件(索引是用来加快数据查询的) InnoDB会创建两个文件 .frm 表结构文件 .ibd 表数据和表索引文件 memory .frm 表结构文件 blackhole .frm 表结构文件 &quot;&quot;&quot; MySQL基本数据类型![image-20220218151839839](C:\\Users\\xiao’s computer\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220218151839839.png) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 1.整型 tinyint smallint int bigint 不同的int类型能够存储的数字范围是不一样的 1.要注意是否存负数(正负号需要占一个比特位) 2.针对手机号码只能用bigint &#x27;&#x27;&#x27;研究默认是否需要正负号&#x27;&#x27;&#x27; create table t5(id tinyint); insert into t5 values(-128),(127); # 存储正负号需要1bit位，所以存储数据的有7个bit位 # 结论:所有的int类型默认都需要正负号 create table t6(id tinyint unsigned); # 移除正负号，多了一个bit位所以存储数据大小大一倍 insert into t6 values(0),(255); # 2.浮点型 float double decimal float(255,30) # 总共255位 小数位占30位 double(255,30) # 总共255位 小数位占30位 decimal(65,30) # 总共65位 小数位占30位 &quot;&quot;&quot;研究三者的不同&quot;&quot;&quot; create table t7(id float(255,30)); create table t8(id double(255,30)); create table t9(id decimal(65,30)); insert into t7 values(1.11111111111111111111111); insert into t8 values(1.11111111111111111111111); insert into t9 values(1.11111111111111111111111); # 结论:三者的精确度不一样 float &lt; double &lt; decimal &quot;&quot;&quot; 到底使用哪个 一般情况下小数点后面只保留两位 所以float足矣 如果是从事高精密业务 则需要考虑更高的精确度 ps:有时候很多看似需要用数字存储的数据 可能都是存的字符串 课外扩展:python本身对数字的精确度很低 之所以能够从事人工智能和数据分析完全得益于功能强大的模块 &quot;&quot;&quot; # 3.字符类型 char(4) 定长类型 最多只能存四个字符 多了报错少了自动空格填充至四个 varchar(4) 变长类型 最多只能存四个字符 多了报错少了有几个则存几个 &quot;&quot;&quot;研究上述特征&quot;&quot;&quot; create table t10(id int,name char(4)); create table t11(id int,name varchar(4)); insert into t10 values(1,&#x27;jason&#x27;); insert into t11 values(1,&#x27;jason&#x27;); # 针对5.6版本超出范围不会报错 而是自动帮你截取并保存(此行为不合理) 方式1:修改配置文件(永久) 方式2:命令修改(暂时) show variables like &#x27;%mode%&#x27; set session # 当前窗口有效 set global # 当前服务端有效 set gloabl sql_mode = &#x27;strict_trans_tables&#x27; 修改完毕后退出客户端重新进入即可 修改后再次执行上述插入命令 会直接报错 # 研究定长与变长特性 insert into t10 values(1,&#x27;j&#x27;); insert into t11 values(1,&#x27;t&#x27;); # 统计某个字段数据的长度 char_length() &#x27;&#x27;&#x27;底层确实会填充 但是取出来的时候又会自动去除&#x27;&#x27;&#x27; set global sql_mode = &#x27;strict_trans_tables,pad_char_to_full_length&#x27; char与varchar的对比12345678910111213141516171819202122char; 优势:整存整取 速度快 劣势:浪费存储空间varchar 优势:节省存储空间 劣势:存取数据的速度较char慢&quot;&quot;&quot;char(5) 存：5个字符5个字符存 取：5个字符5个字符取varchar(5) 存:先计算数据的长度 取:先获取报头的数据&quot;&quot;&quot;# 以前几乎都是char 现在很多情况下使用varchar 进了公司之后 会通过邮件告诉你每个字段的英文名和中文名及类型等项目的诸多信息 补充:在创建字段的时候可以加上相应的注释 create table t12( id int comment &#x27;序号&#x27;, name char(4) comment &#x27;姓名&#x27; ); 整型中括号内数字的作用1234567891011create table t13(id int(3));insert into t13 values(4444444); # 可以插入&quot;&quot;&quot;在整型中括号内的数字并不是用来限制存储的长度 而是用来控制展示的长度我们以后在定义整型字段的时候 不需要自己添加数字 使用默认的就可以&quot;&quot;&quot;create table t14(id int(3) zerofill);insert into t14 values(4);select * from t14; # 不够3个字符用0补充：id 004 # 结论:整型比较的特殊 是唯一个不是用来限制存储长度的类型 枚举与集合类型12345678910111213141516171819枚举 多选一enum() create table user( id int, name varchar(32), gender enum(&#x27;male&#x27;,&#x27;female&#x27;,&#x27;others&#x27;) ); insert into user values(1,&#x27;jason&#x27;,&#x27;男&#x27;); # 报错 insert into user values(1,&#x27;jason&#x27;,&#x27;male&#x27;); # 正常 集合 多选多(包含了多选一)set() create table userinfo( id int, name char(16), hobby set(&#x27;basketball&#x27;,&#x27;football&#x27;,&#x27;doublecolorball&#x27;) ); 日期类型1234567891011121314date 年月日datetime 年月日时分秒time 时分秒year 年份create table client( id int, name varchar(32), reg_time date, birth datetime, study_time time, join_time year);insert into client values(1,&#x27;jason&#x27;,&#x27;2000-11-11&#x27;,&#x27;2000-1-21 11:11:11&#x27;,&#x27;11:11:11&#x27;,1995); 创建表的完整语法12345678910create table 表名( 字段名1 字段类型(数字) 约束条件, 字段名2 字段类型(数字) 约束条件, 字段名3 字段类型(数字) 约束条件);&quot;&quot;&quot;1.字段名和字段类型是必须的2.数字和约束条件是可选的 并且 约束条件可以有多个，空格隔开即可3.最后一个语句的结尾不要加逗号&quot;&quot;&quot; 约束条件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&quot;&quot;&quot;约束条件相当于是在字段类型的基础之上添加的额外约束 eg: id int unsigned&quot;&quot;&quot;1、unsigned 让数字没有正负号2、zerofill 多余的使用数字0填充3、not null 非空 &quot;&quot;&quot; 新增表数据的方式 方式1: 按照字段顺序一一传值 insert into t1 values(1,&#x27;jason&#x27;); 方式2: 自定义传值顺序 甚至不传 insert into t1(name,id) values(&#x27;jason&#x27;,1); insert into t1(id) values(1); 在MySQL中不传数据 会使用关键字NULL填充，意思就是空 类似于python的None &quot;&quot;&quot; create table t( id int, name varchar(32) not null ); 4、default： 就是默认值 &quot;&quot;&quot; 所有的字段都可以设置默认值 用户不给该字段传值则使用默认的 否则使用传了的 create table t3( id int default 911, name varchar(16) default &#x27;jason&#x27; ); &quot;&quot;&quot; 5、unique 唯一值 &quot;&quot;&quot; 单列唯一 create table t4( id int, name varchar(32) unique ); 联合唯一 create table t5( id int, host varchar(32), port int, unique(host,port) ); &quot;&quot;&quot; 6、primary key 主键 &quot;&quot;&quot; 但从约束层面上来说 相当于是 not null + unique(非空且唯一) 并且可以加快数据的查询 InnoDB存储引擎规定了一个表必须有且只有一个主键 因为InnoDB是通过主键的方式来构造表的 如果没有设置主键 情况1:没有主键和其他约束条件 InnoDB会采用隐藏的字段作为主键 不能加快数据的查询 情况2:没有主键但是有非空且唯一的字段 自动将该字段升级为主键 create table t6( id int, age int not null unique, # 自动变为主键 pwd int not null unique ); 结论: 以后我们在创建表的时候一定要设置主键 并且主键字段一般都是表的id字段(uid sid pid cid) create table user( id int primary key, name varchar(32) ); &quot;&quot;&quot; 7、auto_increment： 自增 &quot;&quot;&quot; 由于主键类似于数据的唯一标识 并且主键一般都是数字类型 我们在添加数据的时候不可能记住接下来的序号是多少 太麻烦 create table user1( id int primary key auto_increment, name varchar(32) ); &quot;&quot;&quot; 自增的特性1234自增不会因为删除操作而回退 delete from无法影响自增如果想要重置需需要使用truncate关键字 truncate 表名; # 清空表数据并且重置主键值","categories":[],"tags":[{"name":"5、数据库之MySQL","slug":"5、数据库之MySQL","permalink":"https://chenxiao0629.github.io/tags/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMySQL/"}]},{"title":"01、数据（发展史、存储发展史）、数据库（本质、分类）、SQL与NoSQL的由来、系统服务、密码相关、重要概念介绍（库、表、记录）、基本SQL语句、针对（库、表、字段、记录）的SQL语句、字符编码问题","slug":"mysql_day01","date":"2018-07-23T06:04:01.000Z","updated":"2022-05-13T13:54:04.111Z","comments":true,"path":"2018/07/23/mysql_day01/","link":"","permalink":"https://chenxiao0629.github.io/2018/07/23/mysql_day01/","excerpt":"","text":"数据发展史123456789101112131、单独的文本文件（Python文本操作的时候） 文件名不统一 数据格式没有统一（代码层不统一）2、软件开发目录规范 规定了文件名和存储位置 文件查找简单了 并没有解决核心问题3、数据库截断 规定了文件存储位置、数据格式 目前正在使用的阶段 解决了核心问题 数据存储发展史1234567891011121、单机游戏阶段 数据各自保存在各自的计算机上 无法实现共享2、多机游戏阶段 数据统一保存在某个固定的服务器（计算机） 实现数据共享 前提：必须有网络 为了数据安全，还会采用集群策略来分担风险 数据库的本质12345678910# 本质也是一款cs架构的软件 既然数据库本质是一款cs架构的软件 也就意味着我们每个人都可以编写一个数据库软件 在目前地球上有很多牛逼的程序员 他们都具备编写数据库软件的能力 并且目前市面上真的有很多款数据库软件&quot;&quot;&quot;数据库在狭义层面上来说 指的是处理数据的底层程序数据库在广义层面上来说 指的是操作这些底层程序的便捷应用软件其实学习数据库很多时候学习的是配套的数据库软件&quot;&quot;&quot; 数据库的分类(重点)12345678910111213141516171819202122232425262728# 市面上有很多数据库软件 但是大致就分为两类1.关系型数据库 MySQL、Oracle、PostgreSQL、MariaDB、sqlite、sql server、db2 MySQL:开源免费 使用非常规范 Oracle:收费 维护成本高 大型公司可能会使用 PostgreSQL:支持二次开发 MariaDB:MySQL的替代产品(并且有自己的特性) sqlite:小型数据库(django框架自带该数据库) 2.非关系型数据库 Redis、mongoDB、memcache Redis:目前最火的缓存数据库 具有很多数据结构 功能强大 mongoDB:文档型数据库 可以用在大数据和爬虫领域 memcache:已经被redis淘汰 &quot;&quot;&quot;1.两类数据库的区别 关系型数据库 拥有固定的表结构 并且表与表之间可以建立代码层面的关系 非关系型数据库 没有固定的表结构 数据存储采用的是K:V键值对的形式2.这么多数据库如何学习 两大类数据库操作逻辑基本一致 每一类学习一个基本就可以掌握所有 关系型学MySQL 非关系型学redis、mongodb&quot;&quot;&quot; SQL与NoSQL的由来12345数据库的服务端为了能够兼容不同类型的客户端实现数据交互所以规定了统一的交互方式 关系型数据库&gt;&gt;&gt;:SQL语句 非关系型数据库&gt;&gt;&gt;:NoSQL语句# NoSQL有时候也表示 非关系型数据库 MySQL下载安装1234567891011121314151617181920212223242526272829303132333435363738394041421.主要版本 5.6:使用频率较高的版本 5.7:目前正在过渡的版本 8.0:目前最新的版本&quot;&quot;&quot;不同的版本主要区别在于底层的逻辑 SQL语句几乎是一模一样的&quot;&quot;&quot;# 学习阶段可以使用5.6的版本(如果已经下载了其他版本也没问题)2.软件下载 mac: https://www.cnblogs.com/Dominic-Ji/articles/15402755.html https://www.cnblogs.com/xingxiangyi/p/9334694.html linux:博客置顶文章 windows:瞪大眼睛看（下面） 访问官网:https://www.mysql.com/ 具体步骤: DOWNLOADS MySQL Community (GPL) Downloads MySQL Community Server Archives 选择版本下载压缩包(客服端 服务端) 3.目录介绍 bin文件夹 mysqld.exe 服务端 mysql.exe 客服端 data文件夹 存储使用过程中需要保存的数据 my-default.ini 配置文件 redadme 说明文件 4.基本使用 # 一定要先启动服务端再启动客户端 &quot;&quot;&quot;前期在操作的时候最好使用管理员权限打开cmd操作&quot;&quot;&quot; 1.环境变量的配置 2.直接输入mysqld启动服务端(当前cmd窗口不要关闭) 3.开设一个新的cmd窗口操作客户端 mysql # 游客模式登陆 mysql -u用户名 -p密码 # 账号登录(本地使用) mysql -hIP地址 -P端口号 -u用户名 -p密码 # 完整命令 后期项目中基于网络访问数据库要用 &quot;&quot;&quot;第一次登录 root用户没有密码 直接连续回车即可&quot;&quot;&quot; 系统服务1234567891011121314151617# 将MySQL的服务端制作成系统服务 开机自启动 关机自关闭# 注意：cmd中关闭、开启、添加、移除服务要都用管理员身份进入cmd，避免请求被拒绝1.先关闭之前的服务端2.查看当前计算机系统服务列表 运行窗口输入：services.msc3.以管理员身份运行cmd并制作系统服务 mysqld --install # 仅仅是添加到了系统服务 第一次需要手动启动4.启动服务 方式1:鼠标右键选择启动即可 方式2:cmd里命令行方式启动 net start mysql&quot;&quot;&quot;停止服务 net stop mysql移除系统服务 mysqld --remove&quot;&quot;&quot; 密码相关1234567891011121314151617181920212223# 针对管理员用户需要设置密码 方式1:直接在cmd窗口内使用mysqladmin命令 mysqladmin -uroot -p原密码 password 新密码 eg: mysqladmin -uroot -p password 123 mysqladmin -uroot -p123 password 666 方式2:直接在登录状态下修改当前登录用户的密码 set password=password(&#x27;密码&#x27;); # 忘记密码如何解决(了解) 方式1:前期数据库里面也没有数据 干脆重来!!! 方式2:稍作了解 1.关闭服务端 2.以跳过授权表的方式重新启动服务端 只需要提供用户名就可以登录 mysqld --skip-grant-tables 3.以管理员身份登录 mysql -uroot -p 4.修改管理员用户密码 update mysql.user set password=password(123) where user=&quot;root&quot; and host=&quot;localhost&quot;; 5.关闭服务端再正常启动 net start mysql(用管理员身份进入cmd运行) 6.使用修改之后的密码登录 重要概念介绍12345库 文件夹表 文件夹里面的文件记录 文件夹里面的文件里面的一行行内容 基本SQL语句123456789101112131415&quot;&quot;&quot;SQL语句注意： 1、结束必须使用分号 2、不区分大小写 3、字符串用&#x27;&#x27;、&quot;&quot;都可以&quot;&quot;&quot;# 1.如何查看所有的数据库名称 show databases; &#x27;&#x27;&#x27;会有一个临时产生在内存的库:in...sc&#x27;&#x27;&#x27;# 2.如何查看所有的表名称 use 库名; &#x27;&#x27;&#x27;切换库(类似于双击了文件夹)&#x27;&#x27;&#x27; show tables;# 3.如何查看所有的记录 select * from 表名; 如果内容较多展示补全出现错乱的情况 可以在语句后面加\\G \\G：可以将查询结果按列打印 针对库的SQL语句12345678910&quot;&quot;&quot;辛辛苦苦一个月 换来的就是一条SQL语句：工资数字的增删改查&quot;&quot;&quot;# 增 create database 数据库名;# 查 show databases; # 查看所有的库名 show create database 数据库名; # 定向查看某个库# 改 alter database 数据库名 charset=&#x27;gbk&#x27;;# 删 drop database 数据库名; 针对表的SQL语句123456789101112131415161718192021&quot;&quot;&quot;要想操作表必须得先有库 1.先创建库 create database db1; 2.查看当前所在的库名 select database(); 3.切换库 use bd1;&quot;&quot;&quot;# 增 create table 表名(字段名1 字段类型1,字段2 字段类型2);# 查 show tables; # 查看当前库下面所有的表名 show create table 表名; # 查看指定的表信息 describe 表名; # 查看表的具体信息(常用) 简写 desc 表名;# 改 alter table t1 rename ttt; # 修改表名 alter table ttt change id nid int; # 修改字段名和类型 alter table ttt modify nid char(4); # 修改字段类型# 删 drop table 表名; 针对字段的SQL语句12345678910111213141516171819202122232425show tables;desc 表名;create table t1(id int);alter table t1 change id nid int;drop table t1;语法：1. 修改表名 ALTER TABLE 表名 RENAME 新表名;2. 增加字段 ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…], ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] FIRST; ALTER TABLE 表名 ADD 字段名 数据类型 [完整性约束条件…] AFTER 字段名; 3. 删除字段 ALTER TABLE 表名 DROP 字段名;4. 修改字段 # modify只能改字段数据类型完整约束，不能改字段名，但是change可以！ ALTER TABLE 表名 MODIFY 字段名 数据类型 [完整性约束条件…]; ALTER TABLE 表名 CHANGE 旧字段名 新字段名 旧数据类型 [完整性约束条件…]; 针对记录的操作12345678910111213&quot;&quot;&quot;肯定得先确定库和表&quot;&quot;&quot;# 增 insert into 表名 values(数据,数据,数据); &#x27;&#x27;&#x27;单条数据&#x27;&#x27;&#x27; insert into 表名 values(),(),(); &#x27;&#x27;&#x27;多条数据&#x27;&#x27;&#x27; 注意：insert可以省略# 查 select * from 表名; &#x27;&#x27;&#x27;查询表中所有的数据&#x27;&#x27;&#x27;# 改 update 表名 set 字段名=&#x27;新数据&#x27; where 筛选条件;# 删 delete from 表名 where 筛选条件; 字符编码问题1234567891011121314# 查看MySQL内部默认的编码情况 \\s &quot;&quot;&quot;MySQL默认的配置文件&gt;&gt;&gt;:mydefault.ini&quot;&quot;&quot;1.拷贝默认的配置文件并且重新命名为my.ini2.拷贝固定的配置信息 [mysqld] character-set-server=utf8 collation-server=utf8_general_ci [client] default-character-set=utf8 [mysql] default-character-set=utf83.重启MySQL服务端","categories":[],"tags":[{"name":"5、数据库之MySQL","slug":"5、数据库之MySQL","permalink":"https://chenxiao0629.github.io/tags/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMySQL/"}]},{"title":"10、高可用（简介、常用的工具、VRRP协议、部署keepalived、keepalived配置、脑裂问题解决、非抢占式）、四层负载均衡","slug":"day11笔记","date":"2018-06-23T06:04:10.000Z","updated":"2022-05-13T12:31:05.410Z","comments":true,"path":"2018/06/23/day11笔记/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day11%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1、今日内容121、高可用2、七层负载均衡 和 四层负载均衡 2、什么是高可用123456789101112一般是指2台机器启动着完全相同的业务系统，当有一台机器down机了，另外一台服务器就能快速的接管，对于访问的用户是无感知的。比如公司的网络是通过网关进行上网的，那么如果该路由器故障了，网关无法转发报文了，此时所有人都无法上网了，怎么办？通常做法是给路由器增加一台备节点，但是问题是，如果我们的主网关master故障了，用户是需要手动指向backup的，如果用户过多修改起来会非常麻烦。 问题一：假设用户将指向都修改为backup路由器，那么master路由器修好了怎么办？问题二：假设Master网关故障，我们将backup网关配置为master网关的ip是否可以？ 其实是不行的，因为PC第一次通过ARP广播寻找到Master网关的MAC地址与IP地址后，会将信息写到ARP的缓存表中，那么PC之后连接都是通过那个缓存表的信息去连接，然后进行数据包的转发，即使我们修改了IP但是Mac地址是唯一的，pc的数据包依然会发送给master。（除非是PC的ARP缓存表过期，再次发起ARP广播的时候才能获取新的backup对应的Mac地址与IP地址） 如何才能做到出现故障自动转移，此时VRRP就出现了，我们的VRRP其实是通过软件或者硬件的形式在Master和Backup外面增加一个虚拟的MAC地址（VMAC）与虚拟IP地址（VIP），那么在这种情况下，PC请求VIP的时候，无论是Master处理还是Backup处理，PC仅会在ARP缓存表中记录VMAC与VIP的信息。 3、常用的工具121.硬件通常使用 F52.软件通常使用 keepalived 4、VRRP协议1VRRP协议会在一个局域网中进行广播， 5、部署keepalived1[root@lb01 conf.d]# yum install keepalived -y 6、Keepalived配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748! Configuration File for keepalived# 全局配置global_defs &#123; # 当前keepalived的唯一标识 router_id lb01&#125;# 检测脚本vrrp_script check_nginx &#123; # 指定脚本路径 script &quot;/etc/keepalived/checkNG.sh&quot; # 执行间隔 interval 5&#125;# 配置VRRP协议vrrp_instance VI_1 &#123; # 状态，MASTER和BACKUP state MASTER # 绑定网卡 interface eth0 # 虚拟路由标示，可以理解为分组 virtual_router_id 50 # 优先级 priority 100 # 监测心跳间隔时间 advert_int 1 # 配置认证 authentication &#123; # 认证类型 auth_type PASS # 认证的密码 auth_pass 1111 &#125; # 设置VIP virtual_ipaddress &#123; # 虚拟的VIP地址 192.168.15.3 &#125; # 调用检查 track_script &#123; check_nginx &#125;&#125;# 启动[root@lb01 ~]# systemctl enable --now keepalived 7、怎么解决keepalived的脑裂问题12345678910两台高可用服务器在指定时间内，无法互相检查到对方的心跳而各自启动故障转移功能。1、如果Nginx宕机怎么办？想办法告诉keepalived，Nginx的情况。2、局域网之内，keepalived无法相互广播，怎么办？判断VIP是否可以ping的通$? : 上一条命令执行的结果。 12345678910111213141516171819202122232425262728[root@lb01 ~]# cat checkNG.sh #!/bin/bash# 解决Nginx无法正常启动ps -ef | grep -q [n]ginx if [ $? -ne 0 ];then # 代表Nginx未正常启动 systemctl start nginx &amp;&gt;/dev/null sleep 2 ps -ef | grep -q [n]ginx if [ $? -ne 0 ];then systemctl stop keepalived fifi# 局域网之内，keepalived无法相互广播，怎么办？# VIP=192.168.15.3# ping -c 1 $VIP &amp;&gt;/dev/null # if [ $? -eq 0 ];then # 代表VIP还可以访问 # fi&amp; : 正确的标准输出和错误的标准输出 8、keepalived的非抢占式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950实现非抢占式。1、状态全部都有设置成backup2、增加 nopreempt [root@lb02 ~]# cat /etc/keepalived/keepalived.conf ! Configuration File for keepalivedglobal_defs &#123; router_id lb02&#125;# 检测脚本vrrp_script check_nginx &#123; # 指定脚本路径 script &quot;/etc/keepalived/checkNG.sh&quot; # 执行间隔 interval 5&#125;# 配置VRRP协议vrrp_instance VI_1 &#123; #状态，MASTER和BACKUP state BACKUP # 开启非抢占式 nopreempt #绑定网卡 interface eth0 #虚拟路由标示，可以理解为分组 virtual_router_id 50 #优先级 priority 90 #监测心跳间隔时间 advert_int 1 #配置认证 authentication &#123; #认证类型 auth_type PASS #认证的密码 auth_pass 1111 &#125; #设置VIP virtual_ipaddress &#123; #虚拟的VIP地址 192.168.15.3 &#125; # 调用检查 track_script &#123; check_nginx &#125;&#125; 9、四层负载均衡12345678910111213141、假设有三台MySQL数据库，请问怎样负载均衡？在非HTTP协议的情况下，采用的四层负载均衡的方式负载服务。注意：四层负载均衡中不支持域名。案例：使用四层负载均衡实现SSH的代理，端口为1122[root@lb01 stream]# cat ssh.conf server &#123; listen 1122; proxy_pass 172.16.1.5:22;&#125; 10、部署一个项目https://gitee.com/lylinux/DjangoBlog?_from=gitee_search","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"09、动静分离、Rewrite（概述、标记Flag）、HTTPS（模拟网站劫持、加密流程、证书对比、自签证书）","slug":"day10笔记 动静分离、rewrite、https","date":"2018-06-23T06:04:09.000Z","updated":"2022-05-13T12:31:01.564Z","comments":true,"path":"2018/06/23/day10笔记 动静分离、rewrite、https/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day10%E7%AC%94%E8%AE%B0%20%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%E3%80%81rewrite%E3%80%81https/","excerpt":"","text":"1、今日内容1231、资源分离2、Nginx的Rewrite重写3、HTTPS 2、动静分离123456789101112131415161、创建NFS挂载点mkdir /staticvim /etc/exports/static 172.16.1.0/20(rw,sync,all_squash,anonuid=666,anongid=666)systemctl restart nfs-serverchown -R www.www /static/2、将静态资源放置于挂载点内mkdir /opt/static/s[root@web01 static]# cp -r /opt/bbs/static/* /opt/static/s/3、挂载到lbyum install nfs-utils -ymount -t nfs 172.16.1.31:/static /opt/static/4、测试 3、Rewrite基本概述 Rewrite主要实现url地址重写，以及重定向，就是把传入web的请求重定向到其他url的过程。 3.1、Rewrite基本概述12341.地址跳转，用户访问www.linux.com这个URL是，将其定向至一个新的域名www.baidu.com。2.协议跳转，用户通过http协议请求网站时，将其重新跳转至https协议方式。3.伪静态，将动态页面显示为静态页面方式的一种技术，便于搜索引擎的录入，同时建上动态URL地址对外暴露过多的参数，提升更高的安全性。4.搜索引擎，SEO优化依赖于url路径，好记的url便于搜索引擎录入。 3.2、rewrite语法1234567891011121314Syntax: rewrite regex replacement [flag];Default: —Context: server, location, if rewrite # 模块命令regex # 请求的链接（支持正则表达式）replacement # 跳转的链接[flag]; # 标签 location /download/ &#123; rewrite ^(/download/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 break; rewrite ^(/download/.*)/audio/(.*)\\..*$ $1/mp3/$2.ra break; return 403;&#125; 3.3、Rewrite标记Flag rewrite指令根据表达式来重定向URL，或者修改字符串，可以应用于server，location，if环境下，每行rewrite指令最后跟一个flag标记，支持的flag标记有如下表格所示： flag 作用 last 本条规则匹配完成后，停止匹配，不再匹配后面的规则 break 本条规则匹配完成后，停止匹配，不再匹配后面的规则 redirect 返回302临时重定向，地址栏会显示跳转后的地址 permanent 返回301永久重定向，地址栏会显示跳转后的地址 3.3.1、last和break的区别1234567891011121314151617181920212223242526272829303132server &#123; server_name _; listen 80; location ~ ^/break &#123; rewrite (.*) /test break; &#125; location ~ ^/last &#123; rewrite (.*) /test last; &#125; location /test &#123; default_type text/html; return 200 &quot;test&quot;; &#125;&#125;break请求：1.请求linux.rewrite.com/break2.匹配 location ~ ^/break 会跳转到 linux.rewrite.com/test3.请求跳转后，回去查找本地站点目录下的 /test4.如果找到了，则返回/code/test/index.html的内容；5.如果没找到该目录则报错404，如果找到该目录没找到对应的文件则403 last请求:1.请求linux.rewrite.com/last2.匹配 location ~ ^/last 会跳转到 linux.rewrite.com/test3.如果找到了，则返回/code/test/index.html的内容；4.如果没有找到，会重新对当前server发起请求，这个时候访问地址就变成 linux.rewrite.com/test5.重新请求server会匹配到 location /test/ 直接返回该location的内容6.如果也没有location匹配，再返回404; 3.3.2、redirect和permanent的区别123456789重定向location /redirect &#123; rewrite (.*) http://www.baidu.com redirect;&#125;location /permanent &#123; rewrite (.*) http://www.baidu.com permanent;&#125;redirect: 每次请求都会询问服务器，如果当服务器不可用时，则会跳转失败。permanent: 第一次请求会询问，浏览器会记录跳转的地址，第二次则不再询问服务器，直接通过浏览器缓存的地址跳转。 3.3.3、案例1在负载均衡中，将小游戏动静分离。 4、HTTPS 为什么需要使用HTTPS，因为HTTP不安全，当我们使用http网站时，会遭到劫持和篡改，如果采用https协议，那么数据在传输过程中是加密的，所以黑客无法窃取或者篡改数据报文信息，同时也避免网站传输时信息泄露。 那么我们在实现https时，需要了解ssl协议，但我们现在使用的更多的是TLS加密协议。 那么TLS是怎么保证明文消息被加密的呢？在OSI七层模型中，应用层是http协议，那么在应用层协议之下，我们的表示层，是ssl协议所发挥作用的一层，他通过（握手、交换秘钥、告警、加密）等方式，是应用层http协议没有感知的情况下做到了数据的安全加密 4.1、模拟网站劫持4.1.1、正常的页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[root@web01 ~]# vim /code/index.html&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;学生信息注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3 align=&quot;center&quot;&gt;学生信息注册&lt;/h3&gt;&lt;form name=&quot;stu&quot;action=&quot;&quot;&gt;&lt;table&gt; &lt;tr&gt;&lt;td&gt;姓名:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot;name=&quot;stuName&quot;/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;性别:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;radio&quot;name=&quot;stuSex&quot;checked=&quot;checked&quot;&gt;男 &lt;input type=&quot;radio&quot;name=&quot;stuSex&quot;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;出生日期&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot;name=&quot;stuBirthday&quot;&gt;&lt;/td&gt; &lt;td&gt;按格式yyyy-mm-dd&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;学校:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot;name=&quot;stuSchool&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;专业:&lt;/td&gt; &lt;td&gt;&lt;select name=&quot;stuSelect2&quot;&gt; &lt;option selected&gt;计算机科学与技术&lt;/option&gt; &lt;option&gt;网络工程&lt;/option&gt; &lt;option&gt;物联网工程&lt;/option&gt; &lt;option&gt;应用数学&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;体育特长:&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;input type=&quot;checkbox&quot;name=&quot;stuCheck&quot; &gt;篮球 &lt;input type=&quot;checkbox&quot;name=&quot;stuCheck&quot; &gt;足球 &lt;input type=&quot;checkbox&quot;name=&quot;stuCheck&quot; &gt;排球 &lt;input type=&quot;checkbox&quot;name=&quot;stuCheck&quot; &gt;游泳 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td&gt;上传照片:&lt;/td&gt;&lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;file&quot; &gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;密码:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot;name=&quot;stuPwd&quot; &gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;个人介绍:&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;textarea name=&quot;Letter&quot;rows=&quot;4&quot;cols=&quot;40&quot;&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot;value=&quot;提交&quot; &gt;&lt;input type=&quot;reset&quot;value=&quot;取消&quot; &gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; [root@web01 ~]# chown -R www.www /code/index.html 4.1.2、网站劫持123456789101112131415161718192021[root@lb01 ~]# vim /etc/nginx/conf.d/linux.jc.com.conf server &#123; listen 80; server_name linux.jc.com; location / &#123; proxy_pass http://10.0.0.7:80; include proxy_params; sub_filter &#x27;&lt;title&gt;学生信息注册页面&lt;/title&gt;&#x27; &#x27;&lt;title&gt;澳门首家线上赌场&lt;/title&gt;&#x27;; sub_filter &#x27;&lt;h3 align=&quot;center&quot;&gt;学生信息注册&lt;/h3&gt;&#x27; &#x27;&lt;h3 align=&quot;center&quot;&gt;VIP用户信息注册&lt;/h3&gt;&#x27;; sub_filter &#x27;&lt;tr&gt;&lt;td&gt;性别:&lt;/td&gt;&#x27; &#x27;&lt;tr&gt;&lt;td&gt;爱好:&lt;/td&gt;&#x27;; sub_filter &#x27;&lt;option selected&gt;计算机科学与技术&lt;/option&gt;&#x27; &#x27;&lt;option selected&gt;按摩&lt;/option&gt;&#x27;; sub_filter &#x27;&lt;option&gt;网络工程&lt;/option&gt;&#x27; &#x27;&lt;option&gt;抽烟&lt;/option&gt;&#x27;; sub_filter &#x27;&lt;option&gt;物联网工程&lt;/option&gt;&#x27; &#x27;&lt;option&gt;喝酒&lt;/option&gt;&#x27;; sub_filter &#x27;&lt;option&gt;应用数学&lt;/option&gt;&#x27; &#x27;&lt;option&gt;烫头&lt;/option&gt;&#x27;; sub_filter &#x27;&lt;tr&gt;&lt;td&gt;上传照片:&lt;/td&gt;&lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;file&quot; &gt;&lt;/td&gt;&lt;/tr&gt;&#x27; &#x27;&lt;img src=&quot;https://blog.driverzeng.com/zenglaoshi/xingganheguan.gif&quot;&gt;&#x27;; &#125;&#125; [root@lb01 ~]# systemctl restart nginx 4.2、加密流程12345678910111、浏览器发起往服务器的443端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。 2、服务器收到请求，选择浏览器支持的加密算法和哈希算法。 3、服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。 4、浏览器进入数字证书认证环节，这一部分是浏览器内置的TLS完成的： 4.1 首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。 4.2 用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性（验证过程类似上面Bob和Susan的通信）。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。 4.3 浏览器生成一个随机数R，并使用网站公钥对R进行加密。5、浏览器将加密的R传送给服务器。 6、服务器用自己的私钥解密得到R。 7、服务器以R为密钥使用了对称加密算法加密网页内容并传输给浏览器。 8、浏览器以R为密钥使用之前约定好的解密算法获取网页内容。 4.3、证书对比 对比 域名型 DV 企业型 OV 增强型 EV 绿色地址栏 小锁标记+https 小锁标记+https 小锁标记+企业名称+https 一般用途 个人站点和应用； 简单的https加密需求 电子商务站点和应用； 中小型企业站点 大型金融平台； 大型企业和政府机构站点 审核内容 域名所有权验证 全面的企业身份验证； 域名所有权验证 最高等级的企业身份验证； 域名所有权验证 颁发时长 10分钟-24小时 3-5个工作日 5-7个工作日 单次申请年限 1年 1-2年 1-2年 赔付保障金 —— 125-175万美金 150-175万美金 4.4、自签证书1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#使用openssl命令充当CA权威机构创建证书（生产不使用此方式生成证书，不被互联网认可的黑户证书）[root@web01 ssl_key]# openssl genrsa -idea -out server.key 2048Generating RSA private key, 2048 bit long modulus...............................+++........+++e is 65537 (0x10001)Enter pass phrase for server.key: 123456Verifying - Enter pass phrase for server.key: 123456 [root@web01 ssl_key]# lltotal 4-rw-r--r--. 1 root root 1739 Dec 9 11:27 server.key#生成自签证书(公钥)，同时去掉私钥的密码[root@web01 ssl_key]# openssl req -days 36500 -x509 -sha256 -nodes -newkey rsa:2048 -keyout server.key -out server.crtGenerating a 2048 bit RSA private key.....................................+++ ............+++writing new private key to &#x27;server.key&#x27;-----You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#x27;.&#x27;, the field will be left blank.-----Country Name (2 letter code) [XX]:china string is too long, it needs to be less than 2 bytes longCountry Name (2 letter code) [XX]:CNState or Province Name (full name) []:meiguoLocality Name (eg, city) [Default City]:ribenOrganization Name (eg, company) [Default Company Ltd]:heishoudangOrganizational Unit Name (eg, section) []:oldboyCommon Name (eg, your name or your server&#x27;s hostname) []:oldboyEmail Address []:123@qq.com # req --&gt; 用于创建新的证书# new --&gt; 表示创建的是新证书 # x509 --&gt; 表示定义证书的格式为标准格式# key --&gt; 表示调用的私钥文件信息# out --&gt; 表示输出证书文件信息# days --&gt; 表示证书的有效期# sha256 --&gt; 加密方式#1.开启证书Syntax: ssl on | off;Default: ssl off;Context: http, server #2.指定证书文件Syntax: ssl_certificate file;Default: —Context: http, server #3.指定私钥文件Syntax: ssl_certificate_key file;Default: —Context: http, server[root@lb01 conf.d]# cat https.conf upstream ssl &#123; server 172.16.1.7; server 172.16.1.8; server 172.16.1.9;&#125;server &#123; listen 443 ssl; server_name _; ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key; location / &#123; proxy_pass http://ssl; include /etc/nginx/proxy_params; &#125;&#125;server &#123; listen 80; server_name _; rewrite (.*) https://192.168.15.5 permanent;&#125;","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"08、代理（方式、Nginx代理服务支持的协议、实践）、Nginx代理常用参数（添加发往后端服务器的请求头信息、代理到后端的TCP连接、响应、返回等待超时时间、proxy_buffer代理缓冲区、配置代理优化文件）、负载均衡（架构、实现）、负载均衡部署bbs","slug":"day09笔记 lb nginx实现负载均衡","date":"2018-06-23T06:04:08.000Z","updated":"2022-05-13T12:30:56.632Z","comments":true,"path":"2018/06/23/day09笔记 lb nginx实现负载均衡/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day09%E7%AC%94%E8%AE%B0%20lb%20nginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"1、今日内容121、代理2、负载均衡 2、代理 将流量平均分配。 2.1、代理的方式12345671、正向代理找完代理之后，还需要找服务器。应用：VPN2、反向代理只需要找代理，不需要找服务器。应用：负载均衡 2.2、Nginx代理服务支持的协议12345ngx_http_uwsgi_module : Pythonngx_http_fastcgi_module : PHP ngx_http_scgi_module : Javangx_http_v2_module : Golangngx_http_proxy_module : HTTP 2.3、Nginx代理实践1lb01 ---&gt; web01 2.3.1、部署web01123456789101112[root@web01 conf.d]# cat game5.conf server &#123; listen 80; server_name 192.168.15.7; location / &#123; root /opt/Super_Marie; index index.html; &#125; location ~ /images &#123; root /opt/image; &#125;&#125; 2.3.2、部署lb01 部署Nginx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 下载Nginx源代码包[root@lb01 ~]# wget https://nginx.org/download/nginx-1.20.2.tar.gz# 解压[root@lb01 ~]# tar -xf nginx-1.20.2.tar.gz# 进入源代码目录[root@lb01 ~]# cd nginx-1.20.2# 安装依赖包[root@lb01 nginx-1.20.2]# yum install openssl openssl-devel zlib zlib-devel -y# 设置编译参数[root@lb01 nginx-1.20.2]# ./configure --with-http_gzip_static_module --with-stream --with-http_ssl_module# 编译[root@lb01 nginx-1.20.2]# make # 安装[root@lb01 nginx-1.20.2]# make install # 优化[root@lb01 nginx]# mkdir /etc/nginx[root@lb01 nginx]# mv /usr/local/nginx/conf/* /etc/nginx/[root@lb01 nginx]# mkdir /etc/nginx/conf.d[root@lb01 nginx]# groupadd www -g 666[root@lb01 nginx]# useradd www -u 666 -g 666 -M -r -s /sbin/nologin[root@lb01 nginx]# vim /usr/lib/systemd/system/nginx.service[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network-online.target remote-fs.target nss-lookup.targetWants=network-online.target[Service]Type=forkingPIDFile=/var/run/nginx.pidExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.confExecReload=/bin/sh -c &quot;/bin/kill -s HUP $(/bin/cat /var/run/nginx.pid)&quot;ExecStop=/bin/sh -c &quot;/bin/kill -s TERM $(/bin/cat /var/run/nginx.pid)&quot;[Install]WantedBy=multi-user.target[root@lb01 sbin]# ln -s /etc/nginx/nginx.conf /usr/local/nginx/conf/nginx.conf[root@lb01 sbin]# mv /usr/local/nginx/sbin/nginx /usr/sbin/[root@lb01 sbin]# mkdir /var/log/nginx[root@lb01 sbin]# systemctl start nginx 部署反向代理 12345678[root@lb01 conf.d]# cat /etc/nginx/conf.d/game.conf server &#123; listen 80; server_name _; location / &#123; proxy_pass http://172.16.1.7:80; &#125;&#125; 2.4、Nginx代理常用参数2.4.1、添加发往后端服务器的请求头信息1234567891011Syntax: proxy_set_header field value;Default: proxy_set_header Host $http_host; proxy_set_header Connection close;Context: http, server, location # 用户请求的时候HOST的值是linux.proxy.com, 那么代理服务会像后端传递请求的还是linux.proxy.comproxy_set_header Host $http_host;# 将$remote_addr的值放进变量X-Real-IP中，$remote_addr的值为客户端的ipproxy_set_header X-Real-IP $remote_addr;# 客户端通过代理服务访问后端服务, 后端服务通过该变量会记录真实客户端地址proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 2.4.2、代理到后端的TCP连接、响应、返回等超时时间123456789101112131415161718#nginx代理与后端服务器连接超时时间(代理连接超时)Syntax: proxy_connect_timeout time;Default: proxy_connect_timeout 60s;Context: http, server, location #nginx代理等待后端服务器的响应时间Syntax: proxy_read_timeout time;Default: proxy_read_timeout 60s;Context: http, server, location #后端服务器数据回传给nginx代理超时时间Syntax: proxy_send_timeout time;Default: proxy_send_timeout 60s;Context: http, server, locationproxy_connect_timeout 1s;proxy_read_timeout 3s;proxy_send_timeout 3s; 2.4.3、proxy_buffer代理缓冲区12345678910111213141516#nignx会把后端返回的内容先放到缓冲区当中，然后再返回给客户端，边收边传, 不是全部接收完再传给客户端Syntax: proxy_buffering on | off;Default: proxy_buffering on;Context: http, server, location #设置nginx代理保存用户头信息的缓冲区大小Syntax: proxy_buffer_size size;Default: proxy_buffer_size 4k|8k;Context: http, server, location #proxy_buffers 缓冲区Syntax: proxy_buffers number size;Default: proxy_buffers 8 4k|8k;Context: http, server, location 2.4.4、配置代理优化文件1234567891011121314151617181920[root@lb01 ~]# vim /etc/nginx/proxy_params proxy_set_header Host $http_host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_connect_timeout 10s;proxy_read_timeout 10s;proxy_send_timeout 10s;proxy_buffering on;proxy_buffer_size 8k;proxy_buffers 8 8k;[root@lb01 conf.d]# cat game.conf server &#123; listen 80; server_name _; location / &#123; proxy_pass http://172.16.1.7:80; include /etc/nginx/proxy_params; &#125;&#125; 3、负载均衡 为什么要用负载均衡？ 3.1、负载均衡的架构通过代理将流量按照一定的比例，转发到后端。 3.2、负载均衡的实现3.2.1、实现12345678910111213141516171819202122232425262728293031323334将后端服务打包成一个IP连接池。1、反向代理server &#123; listen 80; server_name _; location / &#123; proxy_pass http://[连接池]; &#125;&#125;2、IP连接池upstream [连接池名称] &#123; server [ip]:[port]; server [ip]:[port]; server [ip]:[port];&#125;[root@lb01 conf.d]# cat game.conf upstream supermarie &#123; server 172.16.1.7:80; server 172.16.1.8:80; server 172.16.1.9:80;&#125;server &#123; listen 80; server_name _; location / &#123; proxy_pass http://supermarie; include /etc/nginx/proxy_params; &#125;&#125; 3.2.2、负载均衡的比例3.2.2.1、轮询123456# 默认情况下，Nginx负载均衡的轮询状态。upstream supermarie &#123; server 172.16.1.7:80; server 172.16.1.8:80; server 172.16.1.9:80;&#125; 3.2.2.2、权重123456# Nginx中的权重0-100，数字越大，权重越高。upstream supermarie &#123; server 172.16.1.7:80 weight=9; server 172.16.1.8:80 weight=5; server 172.16.1.9:80 weight=1;&#125; 3.2.2.3、ip_hash1234567# 每一个IP固定访问某一个后端。upstream supermarie &#123; server 172.16.1.7:80; server 172.16.1.8:80; server 172.16.1.9:80; ip_hash;&#125; 3.3、负载均衡后端状态 状态 概述 down 当前的server暂时不参与负载均衡 backup 预留的备份服务器 max_fails 允许请求失败的次数 fail_timeout 经过max_fails失败后, 服务暂停时间 3.3.1、down12345678910111213141516# 暂时不分配流量upstream supermarie &#123; server 172.16.1.7:80 down; server 172.16.1.8:80; server 172.16.1.9:80;&#125;server &#123; listen 80; server_name _; location / &#123; proxy_pass http://supermarie; include /etc/nginx/proxy_params; &#125;&#125; 3.3.2、backup123456789101112131415# 只有当所有的机器全部宕机，才能启动。upstream supermarie &#123; server 172.16.1.7:80 backup; server 172.16.1.8:80; server 172.16.1.9:80;&#125;server &#123; listen 80; server_name _; location / &#123; proxy_pass http://supermarie; include /etc/nginx/proxy_params; &#125;&#125; 3.3.3、max_fails、fail_timeout123456789101112131415161718192021# max_fails# proxy_next_upstream 后端错误标识[root@lb01 ~]# cat /etc/nginx/conf.d/game.conf upstream supermarie &#123; server 172.16.1.7:80 max_fails=3 fail_timeout=3s; server 172.16.1.8:80 max_fails=3 fail_timeout=3s; server 172.16.1.9:80 max_fails=3 fail_timeout=3s;&#125;server &#123; listen 80; server_name _; location / &#123; proxy_pass http://supermarie; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_404; include /etc/nginx/proxy_params; &#125;&#125; 1234567891011121314注意：proxy_next_upstream error timeout invalid_header http_500 http_503 http_404; error # 与服务器建立连接，向其传递请求或读取响应头时发生错误;timeout # 在与服务器建立连接，向其传递请求或读取响应头时发生超时;invalid_header # 服务器返回空的或无效的响应;http_500 # 服务器返回代码为500的响应;http_502 # 服务器返回代码为502的响应;http_503 # 服务器返回代码为503的响应;http_504 # 服务器返回代码504的响应;http_403 # 服务器返回代码为403的响应;http_404 # 服务器返回代码为404的响应;http_429 # 服务器返回代码为429的响应（1.11.13）;non_idempotent # 通常，请求与 非幂等 方法（POST，LOCK，PATCH）不传递到请求是否已被发送到上游服务器（1.9.13）的下一个服务器; 启用此选项显式允许重试此类请求;off # 禁用将请求传递给下一个服务器。 3.4、负载均衡部署BBS3.4.1、部署后端服务3.4.1.1、部署Python1234561、创建用户[root@web01 opt]# groupadd django -g 888[root@web01 opt]# useradd django -u 888 -g 888 -r -M -s /bin/sh2、安装依赖软件[root@web01 opt]# yum install python3 libxml* python-devel gcc* pcre-devel openssl-devel python3-devel -y 3.4.1.2、部署Django和uwsgi123456789101112131415161718192021222324253、安装Django和uwsgi[root@web01 opt]# pip3 install django==1.11[root@web01 opt]# pip3 install uwsgi[root@web01 opt]# pip3 install pymysql4、创建项目[root@web01 opt]# unzip bbs.zip [root@web03 bbs]# pwd/opt/bbs[root@web03 bbs]# vim bbs/settings.py ALLOWED_HOSTS = [&#x27;*&#x27;]DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;bbs&#x27;, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;PASSWORD&#x27;: &#x27;123456&#x27;, &#x27;HOST&#x27;: &#x27;172.16.1.61&#x27;, &#x27;PORT&#x27;: 3306, &#x27;CHARSET&#x27;: &#x27;utf8&#x27; &#125;&#125;# 启动测试[root@web01 bbs]# python3 manage.py runserver 0.0.0.0:8000 3.4.1.3、配置并启动1234567891011121314151617181920212223242526272829303132333435363738394041424344455、编辑项目配置文件[root@localhost ~]# cat /opt/linux/myweb_uwsgi.ini [uwsgi]# 端口号socket = :8000# 指定项目的目录chdir = /opt/bbs# wsgi文件路径wsgi-file = bbs/wsgi.py# 模块wsgi路径module = bbs.wsgi# 是否开启master进程master = true# 工作进程的最大数目processes = 4# 结束后是否清理文件vacuum = true6、启动uwsgi[root@web01 linux]# uwsgi -d --ini myweb_uwsgi.ini --uid 666-d : 以守护进程方式运行--ini : 指定配置文件路径--uid : 指定uidTCP 服务7、编辑Nginx配置文件[root@localhost ~]# cat /etc/nginx/conf.d/python.conf server &#123; listen 80; server_name py.test.com; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8000; uwsgi_read_timeout 2; uwsgi_param UWSGI_SCRIPT bbs.wsgi; uwsgi_param UWSGI_CHDIR /opt/bbs; index index.html index.htm; client_max_body_size 35m; &#125;&#125;8、重启Nginx配置systemctl restart nginx 3.4.2、部署负载均衡12345678910111213141516[root@lb01 conf.d]# cat python.conf upstream bbs &#123; server 172.16.1.7:80 max_fails=3 fail_timeout=3s; server 172.16.1.8:80 max_fails=3 fail_timeout=3s; server 172.16.1.9:80 max_fails=3 fail_timeout=3s;&#125;server &#123; listen 80; server_name py.test.com; location / &#123; proxy_pass http://bbs; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_404; include /etc/nginx/proxy_params; &#125;&#125;","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"07、Nginx（location配置）、LNMP架构（uwsgi简介与部署）、bbs项目部署","slug":"day08笔记 部署bbs项目","date":"2018-06-23T06:04:07.000Z","updated":"2022-05-13T12:30:53.430Z","comments":true,"path":"2018/06/23/day08笔记 部署bbs项目/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day08%E7%AC%94%E8%AE%B0%20%E9%83%A8%E7%BD%B2bbs%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"1、复习12345678910111、Nginx中常用的模块 autoindex stub_status allow 和 deny basic limit_conn limit_req2、配置步骤 1、创建连接池 2、调用 2、今日内容121、location2、LNMP架构 3、location1使用Nginx Location可以控制访问网站的路径, 但一个server可以有多个location配置, 多个location的优先级该如何区分。 3.1、location匹配符号 匹配符 匹配规则 优先级 &#x3D; 精确匹配 1 ^~ 以某个字符串开头 2 ~ 区分大小写的正则匹配 3 ~* 不区分大小写的正则匹配 3 &#x2F; 通用匹配，任何请求都会匹配到 4 123456789101112131415161718192021222324server &#123; listen 80; server_name _; location ~* /python &#123; default_type text/html; return 200 &quot;Location ~*&quot;; &#125; location ~ /Python &#123; default_type text/html; return 200 &quot;Location ~&quot;; &#125; location ^~ /python &#123; default_type text/html; return 200 &quot;Location ^~&quot;; &#125; location = /python &#123; default_type text/html; return 200 &quot;Location =&quot;; &#125;&#125; 4、LNMP架构12345678910LNMP是一套技术的组合，L=Linux、N=Nginx、M~=MySQL、P~=Python首先Nginx服务是不能处理动态请求，那么当用户发起动态请求时, Nginx又是如何进行处理的。 1.静态请求：请求的内容是静态文件就是静态请求 1）静态文件：文件上传到服务器，永远不会改变的文件就是静态文件 2）html就是一个标准的静态文件 2.动态请求：请求的内容是动态的就是动态请求 1）不是真实存在服务器上的内容，是通过数据库或者其他服务拼凑成的数据 当用户发起http请求，请求会被Nginx处理，如果是静态资源请求Nginx则直接返回，如果是动态请求Nginx则通过uwsgi协议转交给后端的Python程序处理 4.1、uwsgi123因为nginx不支持wsgi协议，无法直接调用py开发的webApp。在nginx+uWsgi+Django的框架里，nginx代理+webServer，uWsgi是wsgiServer，Django是webApp。nginx接收用户请求，并判定哪些转发到uWsgi，uWsgi再去调用pyWebApp。 4.2、uwsgi服务部署12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667681、创建用户[root@web01 opt]# groupadd django -g 888[root@web01 opt]# useradd django -u 888 -g 888 -r -M -s /bin/sh2、安装依赖软件[root@web01 opt]# yum install python3 libxml* python-devel gcc* pcre-devel openssl-devel python3-devel -y3、安装Django和uwsgi[root@web01 opt]# pip3 install django[root@web01 opt]# pip3 install uwsgi4、创建项目[root@web01 opt]# cd /opt[root@web01 opt]# django-admin startproject linux[root@web01 opt]# cd linux[root@web01 opt]# django-admin startapp app01[root@web01 linux]# vim linux/settings.pyALLOWED_HOSTS = [&#x27;*&#x27;]DATABASES = &#123;&#125;# 启动测试[root@web01 linux]# python3 manage.py runserver 0.0.0.0:80005、编辑项目配置文件[root@localhost ~]# cat /opt/linux/myweb_uwsgi.ini [uwsgi]# 端口号socket = :8000# 指定项目的目录chdir = /opt/linux# wsgi文件路径wsgi-file = linux/wsgi.py# 模块wsgi路径module = linux.wsgi# 是否开启master进程master = true# 工作进程的最大数目processes = 4# 结束后是否清理文件vacuum = true6、启动uwsgi[root@web01 linux]# uwsgi -d --ini myweb_uwsgi.ini --uid 666-d : 以守护进程方式运行--ini : 指定配置文件路径--uid : 指定uidTCP 服务7、编辑Nginx配置文件[root@localhost ~]# cat /etc/nginx/conf.d/python.conf server &#123; listen 80; server_name py.test.com; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8000; uwsgi_read_timeout 2; uwsgi_param UWSGI_SCRIPT linux.wsgi; uwsgi_param UWSGI_CHDIR /opt/linux; index index.html index.htm; client_max_body_size 35m; &#125;&#125;8、重启Nginx配置systemctl restart nginx 5、部署BBS项目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011、部署数据库[root@db01 ~]# yum install mariadb* -y2、启动数据库[root@db01 ~]# systemctl start mariadb 3、远程连接MySQL数据MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; CREATE DATABASE `bbs` DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci;Query OK, 1 row affected (0.00 sec)4、部署BBS4.1、上传代码[root@db01 ~]# unzip bbs.zip[root@db01 ~]# mv bbs /opt/4.2、数据库迁移[root@web01 migrations]# pwd/opt/bbs/app01/migrations[root@web01 migrations]# rm -rf 00*[root@web01 migrations]# rm -rf __pycache__/[root@web01 migrations]# cd /opt/bbs/[root@web01 bbs]# pwd/opt/bbs# 修改Django版本[root@web01 bbs]# pip3 uninstall django[root@web01 bbs]# pip3 install django==1.11# 安装MySQL数据库插件[root@web01 bbs]# pip3 install pymysql# 修改数据连接[root@web01 bbs]# vim bbs/settings.pyALLOWED_HOSTS = [&#x27;*&#x27;]DATABASES = &#123; &#x27;default&#x27;: &#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;bbs&#x27;, &#x27;USER&#x27;: &#x27;root&#x27;, &#x27;PASSWORD&#x27;: &#x27;123456&#x27;, &#x27;HOST&#x27;: &#x27;172.16.1.61&#x27;, &#x27;PORT&#x27;: 3306, &#x27;CHARSET&#x27;: &#x27;utf8&#x27; &#125;&#125;# 创建数据库迁移文件[root@web01 bbs]# python3 manage.py makemigrations# 数据库迁移[root@web01 bbs]# python3 manage.py migrate4.3、配置UWSGI[root@localhost ~]# cat /opt/bbs/myweb_uwsgi.ini [uwsgi]# 端口号socket = :8002# 指定项目的目录chdir = /opt/bbs# wsgi文件路径wsgi-file = bbs/wsgi.py# 模块wsgi路径module = bbs.wsgi# 是否开启master进程master = true# 工作进程的最大数目processes = 4# 结束后是否清理文件vacuum = true[root@web01 bbs]# uwsgi -d --ini myweb_uwsgi.ini --uid 6664.4、配置Nginx[root@localhost ~]# cat /etc/nginx/conf.d/python.conf server &#123; listen 80; server_name bbs.test.com; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8002; uwsgi_read_timeout 2; uwsgi_param UWSGI_SCRIPT bbs.wsgi; uwsgi_param UWSGI_CHDIR /opt/bbs; index index.html index.htm; client_max_body_size 35m; &#125;&#125;[root@web01 bbs]# systemctl restart nginx 4.5、测试访问BBS","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"06、Nginx虚拟主机、Nginx日志、Nginx访问控制模块、Nginx状态监控模块、访问连接控制模块","slug":"day07笔记 nginx","date":"2018-06-23T06:04:06.000Z","updated":"2022-05-13T12:30:51.016Z","comments":true,"path":"2018/06/23/day07笔记 nginx/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day07%E7%AC%94%E8%AE%B0%20nginx/","excerpt":"","text":"1、今日内容123456789101、Nginx虚拟主机 - 基于多IP的方式 - 基于多端口的方式 - 基于多域名的方式2、日志配置Nginx有非常灵活的日志记录模式，每个级别的配置可以有各自独立的访问日志。日志格式通过log_format命令定义格式3、Nginx访问控制模块4、Nginx状态监控模块5、Nginx访问连接控制模块 2、Nginx虚拟主机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561、基于多IP的方式[root@web01 conf.d]# cat game2.conf server &#123; listen 80; server_name 192.168.15.7; location / &#123; root /opt/Super_Marie; index index.html; &#125;&#125;server &#123; listen 80; server_name 172.16.1.7; location / &#123; root /opt/tank; index index.html; &#125;&#125;2、基于多端口的方式[root@web01 conf.d]# cat game3.conf server &#123; listen 80; server_name 192.168.15.7; location / &#123; root /opt/Super_Marie; index index.html; &#125;&#125;server &#123; listen 81; server_name 192.168.15.7; location / &#123; root /opt/tank; index index.html; &#125;&#125;3、基于多域名的方式[root@web01 conf.d]# cat game4.conf server &#123; listen 80; server_name www.game.com; location / &#123; root /opt/Super_Marie; index index.html; &#125;&#125;server &#123; listen 80; server_name www.game1.com; location / &#123; root /opt/tank; index index.html; &#125;&#125; 3、Nginx日志123456网站状态码是500的比例网站的访问来源网站排错$remote_addr ： 客户端IP$http_x_forwarded_for ： 真实的客户端IP（在反向代理中生效） 4、Nginx访问控制模块 ngx_http_access_module 123456789101112131415允许或者拒绝某些IP访问deny : 拒绝allow ：允许案例1：允许192.168.15.1访问，不允许其他IP访问 allow 192.168.15.1; deny all;案例2：允许192.168.15.0这个网段访问，不允许其他网段访问 allow 192.168.15.0/24; deny all;案例3：只允许通过VPN来访问 allow 172.16.1.81; deny all; ngx_http_auth_basic_module 123456789101112131415161718192021访问之前需要登录1、安装httpd-tools[root@web01 ~]# yum install httpd-tools -y2、生成用户名密码文件[root@web01 ~]# htpasswd -c /etc/nginx/auth chenyangNew password: Re-type new password: Adding password for user chenyang3、将文件路径加入Nginx配置[root@web01 ~]# vim /etc/nginx/conf.d/game4.conf auth_basic &quot;Welcome To Login&quot;; auth_basic_user_file /etc/nginx/auth;4、重启Nginx[root@web01 ~]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful[root@web01 ~]# systemctl restart nginx ngx_http_autoindex_module 12345展示目录索引。autoindex on;autoindex_exact_size on;autoindex_localtime on;autoindex_format json; 5、Nginx状态监控模块123456789监控Nginx运行状态。[root@web01 conf.d]# cat game5.conf server &#123; listen 80; server_name 192.168.15.7; location / &#123; stub_status; &#125;&#125; 6、访问连接控制模块123456789101112131415161718192021222324252627282930313233343536373839404142431、控制Nginx连接数 1、安装ab测试命令 yum install httpd-tools -y 2、ab 参数 -n : 总共需要访问多少次 -c : 每次访问多少个[root@web01 conf.d]# cat game5.conf # limit_req_zone $remote_addr zone=one:10m rate=1r/s;limit_conn_zone $remote_addr zone=addr:10m;server &#123; listen 80; server_name 192.168.15.7; # limit_req zone=one burst=5; limit_conn addr 1; location / &#123; root /opt/Super_Marie; index index.html; &#125;&#125;2、控制Nginx访问量 1、连接池 limit_req_zone $remote_addr zone=one:10m rate=1r/s; 声明连接池 变量 名称 连接池的大小 速率 2、限制数案例1：要求每秒只能有一个访问。[root@web01 conf.d]# cat game5.conf limit_req_zone $remote_addr zone=one:10m rate=1r/s;server &#123; listen 80; server_name 192.168.15.7; limit_req zone=one burst=5; location / &#123; root /opt/Super_Marie; index index.html; &#125;&#125;","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"05、什么是web服务、web服务器软件、部署Nginx、Nginx命令、Nginx配置文件、部署超级玛丽和象棋游戏","slug":"day06笔记 nginx","date":"2018-06-23T06:04:05.000Z","updated":"2022-05-13T12:30:48.758Z","comments":true,"path":"2018/06/23/day06笔记 nginx/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day06%E7%AC%94%E8%AE%B0%20nginx/","excerpt":"","text":"1、复习1234567891011121314151617181920211、NFS共享文件步骤- 服务端[root@backup ~]# yum install nfs-utils rpcbind -y[root@backup ~]# mkdir /backup[root@backup ~]# vim /etc/exports/backup 172.16.1.0/20(rw,sync,all_squash,anonuid=666,anongid=666)[root@backup ~]# groupadd www -g 666[root@backup ~]# useradd www -u 666 -g 666 -M -r -s /sbin/nologin[root@backup ~]# chown -R www.www /backup[root@backup ~]# systemctl start nfs-server rpcbind- 客户端[root@backup ~]# yum install nfs-utils -y[root@backup ~]# mount -t nfs 172.16.1.31:/backup /opt2、安装WEb服务的步骤[root@backup ~]# yum install httpd php php-devel -y[root@backup ~]# cd /var/www/html 2、今日内容1231、了解web服务2、部署Nginx Nginx和Apache的对比 3、什么是web服务1web就是B/S架构 4、web服务器软件123456789101、apache网络模型 select poll epoll2、Nginx官网：https://nginx.org/软件：https://nginx.org/download/ 5、部署Nginx12345678910111213141、yum安装 [root@web01 ~]# vim /etc/yum.repos.d/nginx.repo [root@web01 ~]# yum install nginx -y [root@web01 ~]# systemctl stop httpd [root@web01 ~]# systemctl start nginx2、二进制安装3、编译安装 [root@web01 ~]# wget https://nginx.org/download/nginx-1.20.2.tar.gz [root@web01 ~]# tar -xf nginx-1.20.2.tar.gz [root@web01 nginx-1.20.2]# ./configure [root@web01 nginx-1.20.2]# make [root@web01 nginx-1.20.2]# make install 6、平滑增加Nginx模块123456增加模块必须重新编译。[root@web01 ~]# tar -xf nginx-1.20.2.tar.gz[root@web01 ~]# cd nginx-1.20.2[root@web01 nginx-1.20.2]#./configure --with-http_ssl_module[root@web01 nginx-1.20.2]#make [root@web01 nginx-1.20.2]#make install 7、Nginx的命令123456789101112131415161718192021222324252627282930311、-v : 打印版本号[root@web01 ~]# nginx -vnginx version: nginx/1.20.22、-V ： 打印版本号和配置项[root@web01 ~]# nginx -Vnginx version: nginx/1.20.2built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) built with OpenSSL 1.0.2k-fips 26 Jan 2017TLS SNI support enabledconfigure arguments: --prefix=/etc/nginx 3、-t ： 检查配置文件[root@web01 ~]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful4、-T ： 测试配置文件并启动后退出5、-q ：打印错误日志6、-s : 操作进程 stop ：停止 quit ：退出 reopen ：重启 reload ：重载7、-p ： 指定nginx的工作目录8、-e : 指定错误日志路径9、-c : 指定配置文件的路径10、-g : 设置一个全局的Nginx配置项[root@web01 ~]# nginx -g &#x27;daemon off;&#x27; 8、Nginx配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445全局配置和模块配置1、全局配置 1、user ： 指定Nginx的启动用户 2、worker_processes ： 定义Nginx的worker进程数 auto === CPU数量 3、error_log ： 错误日志路径 4、pid ： pid的存放文件路径 5、events ： 模块配置 5.1、worker_connections ：每一个worker进程最多同时接入多少个请求 5.2、use : 指定Nginx的网络模型 6、http ： web服务的模块 6.1、include ： 加载外部的配置项 6.2、default_type ： 如果找不到文件的类型，则按照指定默认类型处理 6.3、log_format ： 定义日志格式 log_format json &#x27;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&#x27; &#x27;&quot;host&quot;:&quot;$server_addr&quot;,&#x27; &#x27;&quot;service&quot;:&quot;nginxTest&quot;,&#x27; &#x27;&quot;trace&quot;:&quot;$upstream_http_ctx_transaction_id&quot;,&#x27; &#x27;&quot;log&quot;:&quot;log&quot;,&#x27; &#x27;&quot;clientip&quot;:&quot;$remote_addr&quot;,&#x27; &#x27;&quot;remote_user&quot;:&quot;$remote_user&quot;,&#x27; &#x27;&quot;request&quot;:&quot;$request&quot;,&#x27; &#x27;&quot;http_user_agent&quot;:&quot;$http_user_agent&quot;,&#x27; &#x27;&quot;size&quot;:$body_bytes_sent,&#x27; &#x27;&quot;responsetime&quot;:$request_time,&#x27; &#x27;&quot;upstreamtime&quot;:&quot;$upstream_response_time&quot;,&#x27; &#x27;&quot;upstreamhost&quot;:&quot;$upstream_addr&quot;,&#x27; &#x27;&quot;http_host&quot;:&quot;$host&quot;,&#x27; &#x27;&quot;url&quot;:&quot;$uri&quot;,&#x27; &#x27;&quot;domain&quot;:&quot;$host&quot;,&#x27; &#x27;&quot;xff&quot;:&quot;$http_x_forwarded_for&quot;,&#x27; &#x27;&quot;referer&quot;:&quot;$http_referer&quot;,&#x27; &#x27;&quot;status&quot;:&quot;$status&quot;&#125;&#x27;; access_log /var/log/nginx/access.log json ; 6.4、sendfile ： 高效读取文件 6.5、keepalive_timeout ： 长连接保持连接的 HTTP 1.0 短链接 HTTP 1.1 长连接 6.6、server ： 网址模块 6.6.1、listen ： 监听的端口 6.6.2、server_name ： 定义域名 6.6.3、location ： 访问路径 6.6.3.1、root : 指定网址路径 6.6.3.2、index ： 指定网址的索引文件 9、超级玛丽和象棋123456789101112131415161718192021222324251、上传代码2、编辑配置文件[root@web01 conf.d]# vim /etc/nginx/conf.d/game.conf server &#123; listen 80; server_name game.test.com; location / &#123; root /opt/Super_Marie; index index.html; &#125;&#125;3、测试配置文件是否正常[root@web01 conf.d]# nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful4、重启Nginx[root@web01 conf.d]# systemctl restart nginx 5、域名解析C:\\Windows\\System32\\drivers\\etc\\hosts172.16.1.7 game.test.com","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"04、NFS（简介、应用、实践、配置详解）、搭建考试系统（搭建web服务、配合NFS实现文件共享）","slug":"day05笔记 NFS","date":"2018-06-23T06:04:04.000Z","updated":"2022-05-13T12:30:46.524Z","comments":true,"path":"2018/06/23/day05笔记 NFS/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day05%E7%AC%94%E8%AE%B0%20NFS/","excerpt":"","text":"1、今日内容123NFS 网络存储1、NFS的简介2、实现NFS多主机共享 2、NFS简介123NFS是Network File System的缩写及网络文件系统。NFS主要功能是通过局域网络让不同的主机系统之间可以共享文件或目录。NFS系统和Windows网络共享、网络驱动器类似, 只不过windows用于局域网, NFS用于企业集群架构中, 如果是大型网站, 会用到更复杂的分布式文件系统FastDFS,glusterfs,HDFS,ceph 3、NFS应用1234561.用户访问NFS客户端，将请求转化为函数2.NFS通过TCP/IP连接服务端3.NFS服务端接收请求，会先调用portmap进程进行端口映射4.Rpc.nfsd进程用于判断NFS客户端能否连接服务端；5.Rpc.mount进程用于判断客户端对服务端的操作权限6.如果通过权限验证，可以对服务端进行操作，修改或读取 4、NFS实践4.1、服务端12345678910111213141516171819202122232425262728293031323334351、安装NFS和rpcbind[root@nfs ~]# yum install nfs-utils rpcbind -y2、创建挂载点[root@nfs ~]# mkdir /web/nfs&#123;1..9&#125;3、配置挂载点[root@nfs ~]# vim /etc/exports格式：[挂载点] [可以访问的IP]([权限])/web/nfs1 172.16.1.0/20(rw,sync,all_squash)4、关闭selinux和防火墙[root@nfs ~]# setenforce 0[root@nfs ~]# systemctl disable --now firewalld5、启动Nfs和rpcbind服务[root@nfs ~]# systemctl start nfs-server [root@nfs ~]# systemctl start rpcbind6、检查服务端是否正常[root@nfs ~]# showmount -e [服务端的地址，默认是本机地址][root@nfs ~]# showmount -eExport list for nfs:/web/nfsv1 172.16.1.0/20[root@nfs ~]# showmount -e 172.16.1.31Export list for 172.16.1.31:/web/nfsv1 172.16.1.0/20[root@nfs ~]# cat /var/lib/nfs/etab7、给挂载点授权[root@nfs ~]# chown -R nfsnobody.nfsnobody /web 4.2、客户端123456789101、安装NFS[root@web01 opt]# yum install -y nfs-utils2、创建目录[root@web01 opt]# mkdir /opt/nfs/3、挂载NFS[root@web01 opt]# mount -t nfs 172.16.1.31:/web/nfs1 /opt/nfs/4、测试NFS文件同步功能 5、NFS配置详解 nfs共享参数 参数作用 rw 读写权限 (常用) ro 只读权限 (不常用) root_squash 当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户 (不常用) no_root_squash 当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员 (不常用) all_squash 无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户 (常用) no_all_squash 无论NFS客户端使用什么账户访问，都不进行压缩 (不常用) sync 同时将数据写入到内存与硬盘中，保证不丢失数据 (常用) async 优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据 (不常用) anonuid 配置all_squash使用,指定NFS的用户UID,必须存在系统 (常用) anongid 配置all_squash使用,指定NFS的用户GID,必须存在系统 (常用) 1234567891011121314151617181920212223242526271、控制读写rw、ro2、控制文件权限root_squashno_root_squashall_squashno_all_squash3、控制写模式syncasync4、控制用户anonuidanongid统一用户：1、创建用户[root@nfs nfs1]# groupadd www -g 666[root@nfs nfs1]# useradd www -u 666 -g 666 -M -r -s /sbin/nologin 2、修改挂载点权限[root@nfs nfs1]# chown -R www.www /web/3、使用 6、搭建考试系统6.1、搭建WEB服务12345678910111213141516171819202122232425262728291、安装web软件[root@web01 opt]# yum install httpd php php-devel -y2、将代码放置于网站的根目录[root@web01 opt]# cd /var/www/html/# 上传代码3、授权[root@web01 html]# chown -R www.www /var/www/html4、关闭selinux和防火墙[root@nfs ~]# setenforce 0[root@nfs ~]# systemctl disable --now firewalld5、修改web软件的用户[root@web01 html]# vim /etc/httpd/conf/httpd.confUser wwwGroup www6、启动web软件[root@web01 html]# systemctl start httpd7、测试 1、上传 2、访问 http://172.16.1.7/upload/1_linux.jpg 6.2、配合NFS实现文件共享12345678910111213141516171819202122231、修改NFS配置文件[root@nfs nfs1]# vim /etc/exports/web/upload 172.16.1.0/20(rw,sync,all_squash,anonuid=666,anongid=666)2、创建挂载点[root@nfs nfs1]# mkdir /web/upload[root@nfs nfs1]# chown www.www /web/upload3、重启NFS[root@nfs nfs1]# systemctl restart nfs-server rpcbind4、客户端安装NFS软件[root@web01 html]# yum install nfs-utils -y[root@web02 html]# yum install nfs-utils -y[root@web03 html]# yum install nfs-utils -y5、挂载[root@web01 html]# mount -t nfs 172.16.1.31:/web/upload /var/www/html/upload[root@web02 html]# mount -t nfs 172.16.1.31:/web/upload /var/www/html/upload[root@web03 html]# mount -t nfs 172.16.1.31:/web/upload /var/www/html/upload6、测试用web2上传，web3查看 7、遇到的问题1234567891011121、nfsnobody2、NFS挂载无法持久化 1、通过开机自启动脚本挂载 [root@web01 html]# vim /etc/rc.local /usr/bin/mount -t nfs 172.16.1.31:/web/upload /var/www/html/upload [root@web01 html]# chmod +x /etc/rc.d/rc.local 2、通过/etc/fstab配置文件 [root@web02 ~]# vim /etc/fstab # 挂载点 挂载的目录 类型 设置默认权限 0 不备份 1 备份 0 不检查 1 检查172.16.1.31:/web/upload /var/www/html/upload nfs defaults 0 0 [root@web02 ~]# mount -a","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"03、rsync（介绍、特性、应用场景、传输方式、传输模式、使用、守护进程模式、实时同步）","slug":"day04笔记 backup","date":"2018-06-23T06:04:03.000Z","updated":"2022-05-13T12:30:44.108Z","comments":true,"path":"2018/06/23/day04笔记 backup/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day04%E7%AC%94%E8%AE%B0%20backup/","excerpt":"","text":"1、今日内容12345678910111213141516171、rsync2、备份方式 cp : 本机复制 scp : 远程复制 推(本地上传到远程服务器)： scp 1.txt root@ip:[路径] [root@m01 ~]# scp 1.txt root@172.16.1.41:/opt/ 拉(把远程服务器文件下载到本地)： scp root@ip:[路径] ./ [root@m01 ~]# scp root@172.16.1.41:/opt/2.txt . 只支持全量复制 1TB 1GB rsync ：远程复制 增量复制 2、rsync介绍1234567rsync英文称为remote synchronizetion，从软件的名称就可以看出来，rsync具有可使本地和远程两台主机之间的数据快速复制同步镜像、远程备份的功能，这个功能类似于ssh带的scp命令，但是又优于scp命令的功能，scp每次都是全量拷贝，而rsync可以增量拷贝。当然，rsync还可以在本地主机的不同分区或目录之间全量及增量的复制数据，这又类似cp命令。但是同样也优于cp命令，cp每次都是全量拷贝，而rsync可以增量拷贝。rsync官方地址：https://rsync.samba.org/rsync监听端口：873rsync运行模式：C/S client/serverrsync简称叫做远程同步，可以实现不同主机之间的数据同步，还支持全量和增量 3、rsync特性1234567支持拷贝特殊文件，如连接文件、设备等。可以有排除指定文件或目录同步的功能，相当于打包命令tar的排除功能。可以做到保持原文件或目录的权限、时间、软硬链接、属主、组等所有属性均不改变 –p。可以实现增量同步，既只同步发生变化的数据，因此数据传输效率很高（tar-N）。可以使用rcp、rsh、ssh等方式来配合传输文件（rsync本身不对数据加密）。可以通过socket（进程方式）传输文件和数据（服务端和客户端）*****。支持匿名的活认证（无需系统用户）的进程模式传输，可以实现方便安全的进行数据备份和镜像。 4、rsync应用场景12全量备份增量备份 5、rsync的传输方式123456push 推：客户端将数据从本地推送至服务端 pull 拉：客户端将数据从服务端拉取到本地 6、Rsync传输模式1231.本地方式（类似于cp，不支持推送和拉取，只是单纯的复制）2.远程方式（类似于scp，又不同于scp），scp只支持全量备份，rsync支持增量备份和差异备份3.守护进程方式（客户端和服务端） 7、RSYNC使用12345678910111213141516171819202122232425262728293031323334353637383940-a #归档模式传输, 等于-tropgDl -t -r -o -p -g -D -l-v #详细模式输出, 打印速率, 文件数量等 [root@m01 ~]# rsync -v ./2.txt root@172.16.1.41:/opt/-z #传输时进行压缩以提高效率 [root@m01 ~]# rsync -vz ./2.txt root@172.16.1.41:/opt/-r #递归传输目录及子目录，即目录下得所有目录都同样传输。 [root@m01 ~]# rsync -vzr ./a root@172.16.1.41:/opt/-t #保持文件时间信息 [root@m01 ~]# rsync -vzrt ./a/b/c/2.txt root@172.16.1.41:/opt/-o #保持文件属主信息-g #保持文件属组信息 [root@m01 ~]# rsync -vzrtgo ./a/b/c/2.txt root@172.16.1.41:/opt/-p #保持文件权限 [root@m01 ~]# rsync -vzrtgop ./a/b/c/2.txt root@172.16.1.41:/opt/-l #保留软连接 [root@m01 ~]# rsync -vzrtgopl ./* root@172.16.1.41:/opt/-P #显示同步的过程及传输时的进度等信息 [root@m01 ~]# rsync -vzrtgoplP ./* root@172.16.1.41:/opt/-D #保持设备文件信息 [root@m01 dev]# rsync -vzrtgDopl /dev/tty1 root@172.16.1.41:/opt/-L #保留软连接指向的目标文件-e #使用的信道协议,指定替代rsh的shell程序--append # 指定文件接着上次传输中断处继续传输--append-verify # 使用参数续传（在断点续传之后，验证一下文件，如果不同，修复文件）--exclude=PATTERN # 指定排除不需要传输的文件 [root@m01 ~]# rsync -avzP --append-verify --exclude=2.txt ./* root@172.16.1.41:/opt/--exclude-from=file # 按照文件指定内容排除 [root@m01 ~]# rsync -avzP --append-verify --exclude-from=/tmp/exclude.txt ./* root@172.16.1.41:/opt/--bwlimit=100 # 限速传输（单位：MB） [root@m01 ~]# rsync -avzP --append-verify --bwlimit=10 ./* root@172.16.1.41:/opt/--delete # 让目标目录和源目录数据保持一致--password-file=xxx # 使用密码文件--port # 指定端口传输 8、rsync守护进程模式8.1、服务端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501、安装[root@backup ~]# yum install -y rsync2、修改配置文件[root@m01 ~]# vim /etc/rsyncd.conf uid = rsyncgid = rsyncport = 873fake super = yesuse chroot = nomax connections = 200timeout = 600ignore errorsread only = falselist = falseauth users = rsync_backupsecrets file = /etc/rsync.passwdlog file = /var/log/rsyncd.log#####################################[backup]comment = welcome to backup!path = /backup[linux]comment = welcome to linux!path=/tmp/linux3、创建系统用户[root@backup opt]# groupadd rsync -g 666[root@backup opt]# useradd rsync -u 666 -g 666 -M -s /sbin/nologin -r4、创建密码文件[root@backup opt]# echo &quot;rsync_backup:123456&quot; &gt; /etc/rsync.passwd5、授权（必须授权为600）[root@backup opt]# chmod 600 /etc/rsync.passwd6、创建备份目录[root@backup opt]# mkdir /backup[root@backup opt]# mkdir /tmp/linux7、目录授权[root@backup opt]# chown rsync.rsync /backup/[root@backup opt]# chown rsync.rsync /tmp/linux/8、关闭防火墙和selinux[root@backup opt]# systemctl disable --now firewalld[root@backup opt]# setenforce 09、启动rsyncd服务[root@backup opt]# systemctl start rsyncd 8.2、客户端1234567891011121314151617181920212223242526方法一：自己输入密码 [root@m01 ~]# rsync -avzP ./* rsync_backup@172.16.1.41::backup rsync_backup ： 虚拟用户，只在数据传输时使用 172.16.1.41 ： backup服务端的IP backup ： 模块名称 方法二：设置密码文件，运行时读取 1、编写密码文件 [root@backup opt]# echo &quot;123456&quot; &gt; /etc/rsync.passwd 2、授权 [root@m01 ~]# chmod 600 /etc/rsync.passwd 3、连接 [root@m01 ~]# rsync -avzP --password-file=/etc/rsync.passwd ./* rsync_backup@172.16.1.41::linux方法三：添加环境变量 1、定义环境变量 export RSYNC_PASSWORD=123456 2、同步 [root@m01 ~]# rsync -avzP ./* rsync_backup@172.16.1.41::linux 9、rsync实时同步1234567891011121314151617181920212223242526272829303132rsync是不支持实时同步的，通常我们借助于inotify这个软件来实时监控文件变化，一旦inotify监控到文件变，则立即调用rsync进行同步。1、安装inotify(装在客户端)[root@web01 ~]# yum -y install inotify-tools2、inotify参数介绍-m 持续监控-r 递归-q 静默，仅打印时间信息--timefmt 指定输出时间格式--format 指定事件输出格式 %Xe 事件 %w 目录 %f 文件-e 指定监控的事件 access 访问 modify 内容修改 attrib 属性修改 close_write 修改真实文件内容 open 打开 create 创建 delete 删除 umount 卸载 3、开始监控[root@m01 ~]# /usr/bin/inotifywait -mrq --format &#x27;%Xe %w %f&#x27; -e create,modify,delete,attrib,close_write /root4、实时监控并同步[root@m01 ~]# /usr/bin/inotifywait -mrq --format &#x27;%Xe %w %f&#x27; -e create,modify,delete,attrib,close_write /root | while read line;do cd /root rsync -avzP --delete --password-file=/etc/rsync.passwd ./* rsync_backup@172.16.1.41::backupdone","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"02、VPN（简介、作用、种类）、OpenVPN（简介、部署）、客户端证书、创建链接配置文件","slug":"day03笔记 VPN","date":"2018-06-23T06:04:02.000Z","updated":"2022-05-13T12:30:41.856Z","comments":true,"path":"2018/06/23/day03笔记 VPN/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day03%E7%AC%94%E8%AE%B0%20VPN/","excerpt":"","text":"1、复习1234567891011121314151617181920212223241、画iptables的三个模型图2、只允许windows连接本机的iptables规则iptables -t filter -A INPUT -p tcp -s 192.168.15.1 --dport 22 -j ACCEPTiptables -t filter -A INPUT -p tcp --dport 22 -j DROP3、只允许192.168.15.0网段的IP连接本机，用两种方式实现。iptables -t filter -A INPUT -p tcp -m iprange --src-range 192.168.15.1-192.168.15.254 -j ACCEPTiptables -t filter -A INPUT -p tcp --dport 22 -j DROPiptables -t filter -A INPUT -p tcp -i eth0 --dport 22 -j ACCEPTiptables -t filter -A INPUT -p tcp --dport 22 -j DROP4、要求本机流出的数据中包含“元旦快乐”iptables -t filter -A OUTPUT -p tcp --dport 80 -m string --string &quot;元旦快乐&quot; --algo kmp -j ACCEPTiptables -t filter -A OUTPUT -p tcp --dport 80 -j DROP5、要求每天的九点到17点之间可以正常访问iptables -t filetr -A INPUT -p tcp -m time --timestart 1:00 --timestop 9:00 -j ACCEPTiptables -t filter -A INPUT -p tcp -j DROP6、要求只允许windows通过ssh连接192.168.15.81，其他的拒绝iptables -t filter -A INPUT -p TCP -s 192.168.15.1 -d 192.168.15.81 --dport 22 -j ACCEPTiptables -t filter -A INPUT -p TCP --dport 22 -j DROP 2、vpn的简介1VPN(全称：Virtual Private Network)虚拟专用网络，是依靠ISP和其他的NSP，在公共网络中建立专用的数据通信的网络技术，可以为企业之间或者个人与企业之间提供安全的数据传输隧道服务。在VPN中任意两点之间的链接并没有传统专网所需的端到端的物理链路，而是利用公共网络资源动态组成的，可以理解为通过私有的隧道技术在公共数据网络上模拟出来的和专网有同样功能的点到点的专线技术，所谓虚拟是指不需要去拉实际的长途物理线路，而是借用了公共Internet网络实现的。 3、VPN的作用1VPN的功能是帮助公司里的远程用户（出差，在家）、公司的分支机构、商业合作伙伴及供应商等公司和自己的公司内部网络之间建立可信的安全连接或者是局域网连接，确保数据的加密安全传输和业务访问，对于运维工程师来说，还可以连接不同的机房为局域网来处理相关事宜。 4、VPN的种类123456789101112131415161718192021222324252627### PPTP点对点协议（PPTP）是由包括微软和3Com等公司组成的PPTP论坛开发的一种点对点隧道协议，基于拨号使用的PPP协议，使用PAP或CHAP之类的加密算法，或者使用Microsoft的点对点加密算法MPPE。其通过跨越基于TCP/IP的数据网络创建VPN实现了从远程客户端到专用企业服务器之间数据的安全传输。PPTP支持通过公共网络建立按需的、多协议的、虚拟专用网络。PPTP允许加密IP通讯，然后在跨域公司IP网络或公共IP网络发送的IP头中对其进行封装。典型的Linux平台的开源软件为PPTP。PPTP属于点对点应用，比较合适远程的企业用户拨号到企业进行办公等应用。### L2TPL2TP第2等隧道协议（L2TP）是IETF基于L2F（Cisco的第二层转发协议）开的的PPTP的后续版本。是一种工业标准Internet隧道协议，其可以为跨越面向数据包的媒体发送点到点的协议（PPP）框架提供封装。PPTP和L2TP都使用PPP协议对数据进行封装，然后添加附加爆头用于数据在互联网上传输。PPTP只能在两端点间建立单一隧道。L2TP支持在两端点间使用多隧道，用户可以针对不同的服务质量创建不同隧道。L2TP可以提供隧道验证，而PPTP则不支持隧道验证。但是当L2TP或PPTP与IPSEC共同使用时，可以由IPSEC提供隧道验证，不需要在第二层协议上验证隧道使用L2TP。PPTP要求互联网络为IP网络。L2TP只要求隧道媒介提供面向数据包的点对点的链接，L2TP可以在IP（使用UDP），祯中继续永久虚拟电路（PVCs）,X.25虚拟电路（VCs）或ATM VCS网络上使用。### IPSecIP安全协议实际上是一套协议包而不是一个单独的协议。从1995年开始IPSec的研究以来，IETF IPSec工作组在它的主页上发布了几十个Internet草案文献和12个RFC文件。其中比较重要的有RFC2409IKE（互联网秘钥交换）、RFC2401 IPSec协议、RFC2402AH验证包头、RFC2406ESP加密数据等文件。IPSec隧道模式隧道是封装、路由与解封的整个过程。隧道将原始数据包隐藏（或封装）在新的数据包内部。该新的数据包可能会有新的寻址与路由信息，从而使其能够通过网络传输。隧道与数据保密性结合使用时，在网络上窃听通讯的人将无法获取原始数据包数据（以及原始的源和目标）。封装的数据包到达目的地后，会删除封装，原始数据包头用于将数据包路由到最终目的地。隧道本身是封装数据经过的逻辑数据路径，对原始的源和目的的端，隧道是不可见的，而只能看到网络路径中的点对点连接。将隧道和数据保密性结合使用时，可用于提供VPN。封装的数据包在网络中的隧道内部传输。再次示例中，该网络是Internet。网关可以是外部Internet与专用网络之间的周边网关。周界网关可以是路由器、防火墙、代理服务器或其他安全网关。另外，在专用网络内部可以使用两个网关来保护网络中不信任的通讯。当以隧道模式使用IPSEC时，其只为IP通讯提供封装。使用IPSec隧道模式主要是为了与其他不支持IPSec上的L2TP或PPTP VPN隧道技术的路由器、网关或终端系统之间的相互操作。### SSL VPNSSL协议提供了数据私密性、端点验证、信息完整性等特性。SSL协议由许多子协议组成，其中两个主要的子协议是握手协议和记录协议。握手协议允许服务器和客户端在应用协议传输第一个数据字节以前，彼此确认，协商一种加密算法和密码钥匙。在数据传输期间，记录协议利用握手协议生成的秘钥加密和解密后来交换的数据。SSL独立应用，因此任何一个应用程序都可以享受它的安全性而不必理会执行细节。SSL置身于网络结构体系的传输层和应用层之间。此外，SSL本身就被几乎所有的WEB浏览器支持。这意味着客户端不需要为了支持SSL链接安装额外的软件。这两个特征就是SSL能应用于VPN的关键点。典型的SSL VPN应用：Open VPN，这是一个比较好的开源软件。Open VPN允许参与建立VPN的单点使用预设的私钥，第三方证书，或者用户名/密码来进行身份验证。它大量使用了OpenSSL加密库，以及SSLv3/TLSv1协议。OpenVPN能在Linux、xBSD、MacOS 上运行。它并不是一个基于Web的VPN软件，也不能与IPSec及其他VPN软件包兼容。 5、介绍OpenVPN1234567官网：https://openvpn.net/专用网：专用网就是在两个网络（例如，北京和广州）之间架设一条专用线路，但是它并不需要真正地去铺设光缆之类的物理线路。虽然没有亲自去铺设，但是需要向电信运营商申请租用专线，在这条专用的线路上只传输自己的信息,所以安全稳定,同时也费用高昂在众多的VPN产品中，OpenVPN无疑是Linux下开源VPN的经典产品，他提供了良好的访问性能和友好的用户GUI。Open VPN是一个用于创建虚拟专用网络加密通道的软件包，最早由James Yonan编写。一个实现VPN的开源软件，OpenVPN 是一个健壮的、高度灵活的 VPN 守护进程。它支持 SSL/TLS 安全、Ethernet bridging、经由代理的 TCP 或 UDP 隧道和 NAT。另外，它也支持动态 IP 地址以及DHCP，可伸缩性足以支持数百或数千用户的使用场景，同时可移植至大多数主流操作系统平台上。 6、部署OpenVPN1OpenVPN 分为客户端和服务端 1、服务端1234567891011121314151617181920212223242526272829303132# 安装openvpn和证书工具[root@m01 ~]# yum -y install openvpn easy-rsa# 生成服务器配置文件[root@m01 ~]# cp /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/# 准备证书签发相关文件[root@m01 ~]# cp -r /usr/share/easy-rsa/ /etc/openvpn/easy-rsa-server# 准备签发证书相关变量的配置文件[root@m01 ~]# cp /usr/share/doc/easy-rsa-3.0.8/vars.example /etc/openvpn/easy-rsa-server/3/vars# 初始化PKI生成PKI相关目录和文件[root@m01 3]# cd /etc/openvpn/easy-rsa-server/3# 初始化数据,在当前目录下生成pki目录及相关文件[root@m01 3]# ./easyrsa init-pki# 创建CA机构[root@m01 3]# ./easyrsa build-ca nopass# 验证CA证书[root@m01 3]# openssl x509 -in pki/ca.crt -noout -text# 创建服务端证书申请[root@m01 3]# ./easyrsa gen-req server nopass# 创建证书[root@m01 3]# ./easyrsa sign server server# 验证证书[root@m01 3]# diff pki/certs_by_serial/ADBFFB9F45E5CEF861E7F642BA6C447E.pem pki/issued/server.crt 2、创建 Diffie-Hellman 密钥12345方式一：[root@m01 3]# ./easyrsa gen-dh方式二：[root@m01 3]# openssl dhparam -out /etc/openvpn/dh2048.pem 2048 7、客户端证书1234567891011121314151617181920212223[root@m01 3]# cp -r /usr/share/easy-rsa/ /etc/openvpn/easy-rsa-client[root@m01 3]# cp /usr/share/doc/easy-rsa-3.0.8/vars.example /etc/openvpn/easy-rsa-client/3/vars[root@m01 3]# cd /etc/openvpn/easy-rsa-client/3# 初始化证书目录[root@m01 3]# ./easyrsa init-pki# 生成客户端证书[root@m01 3]# ./easyrsa gen-req chenxiao nopass# 将客户端证书请求文件复制到CA的工作目录[root@m01 3]# cd /etc/openvpn/easy-rsa-server/3[root@m01 3]# ./easyrsa import-req /etc/openvpn/easy-rsa-client/3/pki/reqs/chenxiao.req chenxiao# 签发客户端证书[root@m01 3]# pwd/etc/openvpn/easy-rsa-server/3[root@m01 3]# ./easyrsa sign client chenxiao# 验证[root@m01 3]# cat pki/index.txtV 240401022739Z ADBFFB9F45E5CEF861E7F642BA6C447E unknown /CN=serverV 240401023724Z 47765AD8225E12A13FB1EEBAC769B999 unknown /CN=chenxiao[root@m01 3]# ll pki/certs_by_serial/total 16-rw------- 1 root root 4438 Dec 28 10:37 47765AD8225E12A13FB1EEBAC769B999.pem-rw------- 1 root root 4552 Dec 28 10:27 ADBFFB9F45E5CEF861E7F642BA6C447E.pem 8、创建链接配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485861、修改openvpn配置文件[root@m01 3]# vim /etc/openvpn/server.confport 1194proto tcpdev tunca /etc/openvpn/certs/ca.crtcert /etc/openvpn/certs/server.crtkey /etc/openvpn/certs/server.keydh /etc/openvpn/certs/dh.pemserver 10.8.0.0 255.255.255.0push &quot;route 172.16.1.0 255.255.255.0&quot;keepalive 10 120cipher AES-256-CBCcompress lz4-v2push &quot;compress lz4-v2&quot;max-clients 2048user openvpngroup openvpnstatus /var/log/openvpn/openvpn-status.loglog-append /var/log/openvpn/openvpn.logverb 3mute 20# 创建日志文件目录[root@m01 3]# mkdir -p /var/log/openvpn# 创建权限[root@m01 ~]# chown openvpn.openvpn /var/log/openvpn# 创建存放证书目录[root@m01 ~]# mkdir -p /etc/openvpn/certs# 复制证书[root@m01 ~]# cp /etc/openvpn/easy-rsa-server/3/pki/dh.pem /etc/openvpn/certs/[root@m01 ~]# cp /etc/openvpn/easy-rsa-server/3/pki/ca.crt /etc/openvpn/certs/[root@m01 ~]# cp /etc/openvpn/easy-rsa-server/3/pki/private/server.key /etc/openvpn/certs/[root@m01 ~]# cp /etc/openvpn/easy-rsa-server/3/pki/issued/server.crt /etc/openvpn/certs/[root@m01 ~]# ll /etc/openvpn/certs/total 20-rw------- 1 root root 1172 Dec 28 10:54 ca.crt-rw------- 1 root root 424 Dec 28 10:54 dh.pem-rw------- 1 root root 4552 Dec 28 10:54 server.crt-rw------- 1 root root 1704 Dec 28 10:54 server.key2、启动OpenVPN# 开启系统内核网络转发功能[root@m01 ~]# echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf[root@m01 ~]# sysctl -p# 安装防火墙[root@m01 ~]# yum install iptables-services -y[root@m01 ~]# systemctl disable --now firewalld[root@m01 ~]# systemctl start iptables[root@m01 ~]# iptables -F[root@m01 ~]# iptables -F -t nat# 添加iptables规则[root@m01 ~]# iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE# 永久保存Iptables规则[root@m01 ~]# service iptables save# 启动OpenVPN[root@m01 ~]# systemctl enable --now openvpn@server3、创建链接文件[root@m01 ~]# mkdir -p /etc/openvpn/client/chenxiao/# 准备证书[root@m01 chenyang]# cp /etc/openvpn/easy-rsa-server/3/pki/ca.crt /etc/openvpn/client/chenxiao/[root@m01 chenyang]# cp /etc/openvpn/easy-rsa-server/3/pki/issued/chenxiao.crt /etc/openvpn/client/chenxiao/[root@m01 chenyang]# cp /etc/openvpn/easy-rsa-client/3/pki/private/chenxiao.key /etc/openvpn/client/chenxiao/# 准备链接文件[root@m01 ~]# vim /etc/openvpn/client/chenxiao/client.ovpn clientdev tunproto tcpremote 192.168.15.81 1194resolv-retry infinitenobindca ca.crtcert chenxiao.crtkey chenxiao.keyremote-cert-tls servercipher AES-256-CBCverb 3compress lz4-v2 附录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#server.conf文件中以#或;开头的行都为注释[root@instance-gvpb80ao ~]# grep -Ev &quot;^#|^$&quot; /etc/openvpn/server.conf;local a.b.c.d #本机监听IP,默认为本机所有IPport 1194 #端口;proto tcp #协议,生产推荐使用TCPproto udp #默认协议;dev tap #创建一个以太网隧道，以太网使用tap,一个tap设备允许完整的以太网帧通过Openvpn隧道，可提供非ip协议的支持，比如IPX协议和AppleTalk协议,tap等同于一个以太网设备，它操作第二层数据包如以太网数据帧。dev tun #创建一个路由IP隧道，生产推存使用tun.互联网使用tun,一个tun设备大多时候，被用于基于IP协议的通讯。tun模拟了网络层设备，操作第三层数据包比如IP数据封包。;dev-node MyTap #TAP-Win32适配器。非windows不需要配置ca ca.crt #ca证书文件cert server.crt #服务器证书文件key server.key #服务器私钥文件dh dh2048.pem #dh参数文件;topology subnetserver 10.8.0.0 255.255.255.0 #客户端连接后分配IP的地址池，服务器默认会占用第一个IP 10.8.0.1将做为客户端的网关ifconfig-pool-persist ipp.txt #为客户端分配固定IP，不需要配置,建议注释;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100 #配置网桥模式，不需要配置,建议注释;server-bridge;push &quot;route 192.168.10.0 255.255.255.0&quot; #给客户端生成的到达服务器后面网段的静态路由，下一跳为openvpn服务器的10.8.0.1;push &quot;route 192.168.20.0 255.255.255.0&quot; #推送路由信息到客户端，以允许客户端能够连接到服务器背后的其它私有子网;client-config-dir ccd #为指定的客户端添加路由，此路由通常是客户端后面的内网网段而不是服务端的，也不需要设置;route 192.168.40.128 255.255.255.248 ;client-config-dir ccd ;route 10.9.0.0 255.255.255.252;learn-address ./script #运行外部脚本，创建不同组的iptables规则，无需配置;push &quot;redirect-gateway def1 bypass-dhcp&quot; #启用后，客户端所有流量都将通过VPN服务器，因此生产一般无需配置此项;push &quot;dhcp-option DNS 208.67.222.222&quot; #推送DNS服务器，不需要配置;push &quot;dhcp-option DNS 208.67.220.220&quot;;client-to-client #允许不同的client直接通信,不安全,生产环境一般无需要配置;duplicate-cn #多个用户共用一个证书，一般用于测试环境，生产环境都是一个用户一个证书,无需开启keepalive 10 120 #设置服务端检测的间隔和超时时间，默认为每10秒ping一次，如果 120 秒没有回应则认为对方已经downtls-auth ta.key 0 #访止DoS等攻击的安全增强配置,可以使用以下命令来生成：openvpn --genkey --secret ta.key #服务器和每个客户端都需要拥有该密钥的一个拷贝。第二个参数在服务器端应该为’0’，在客户端应该为’1’cipher AES-256-CBC #加密算法;compress lz4-v2 #启用Openvpn2.4.X新版压缩算法;push &quot;compress lz4-v2&quot; #推送客户端使用新版压缩算法,和下面的comp-lzo不要同时使用;comp-lzo #旧户端兼容的压缩配置，需要客户端配置开启压缩,openvpn2.4.X等新版可以不用开启;max-clients 100 #最大客户端数;user nobody #运行openvpn服务的用户和组;group nobodypersist-key #重启VPN服务时默认会重新读取key文件，开启此配置后保留使用第一次的key文件,生产环境无需开启persist-tun #启用此配置后,当重启vpn服务时，一直保持tun或者tap设备是up的，否则会先down然后再up,生产环境无需开启status openvpn-status.log #openVPN状态记录文件，每分钟会记录一次;log openvpn.log #第一种日志记录方式,并指定日志路径，log会在openvpn启动的时候清空日志文件,不建议使用;log-append openvpn.log #第二种日志记录方式,并指定日志路径，重启openvpn后在之前的日志后面追加新的日志,生产环境建议使用verb 3 #设置日志级别，0-9，级别越高记录的内容越详细,0 表示静默运行，只记录致命错误,4 表示合理的常规用法,5 和 6 可以帮助调试连接错误。9 表示极度冗余，输出非常详细的日志信息;mute 20 #相同类别的信息只有前20条会输出到日志文件中explicit-exit-notify 1 #通知客户端，在服务端重启后自动重新连接，仅能用于udp模式，tcp模式不需要配置即可实现断开重新连接,且开启此项后tcp配置后将导致openvpn服务无法启动,所以tcp时必须不能开启此项","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"01、架构图、Iptables介绍、包过滤防火墙概念与实现、Iptables链、Iptables流程图、Iptables使用、Iptables动作、Iptables基本的条件匹配、（-s、-d 源地址 目标地址）、（--sport源端口、--dport目标端口）、（-i，-o，-m，-j动作）、案例、模块、-m案例","slug":"day02笔记 防火墙","date":"2018-06-23T06:04:01.000Z","updated":"2022-05-13T15:13:01.780Z","comments":true,"path":"2018/06/23/day02笔记 防火墙/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/23/day02%E7%AC%94%E8%AE%B0%20%E9%98%B2%E7%81%AB%E5%A2%99/","excerpt":"","text":"1、画架构图 2、Iptables12345678910111.1 什么是防火墙 防止别人恶意访问。1.2 防火墙种类 硬件防火墙 F5 软件防火墙 iptables firewalld 安全组 3.Iptables基本介绍 1用户 ---&gt; 调用iptables ---&gt; ip_tables内核模块 ---&gt; Netfilter（系统安全框架） ---&gt; 过滤请求 4、 什么是包过滤防火墙123451、什么是包 在数据传输过程，并不是一次性传输完成的；而是将数据分成若干个数据包，一点一点的传输。2、 什么是包过滤防火墙 过滤数据包的防火墙。 5、包过滤防火墙如何实现1通过系统安全框架，过滤数据包。 6.Iptables链的概念1234567891011121314151617181920212223四表五链1、那四个表，有哪些作用 具备某种功能的集合叫做表。 filter： 负责做过滤功能呢 ： INPUT、OUTPUT、FORWARD nat： 网络地址转换 PREROUTING、INPUT、OUTPUT、POSTROUTING mangle： 负责修改数据包内容 PREROUTING、INPUT、OUTPUT、POSTROUTING、FORWARD raw： 负责数据包跟踪 PREROUTING、OUTPUT2、那五条链，运行在那些地方 PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING 1） PREROUTING: 主机外报文进入位置，允许的表mangle, nat（目标地址转换，把本机地址转换为真正的目标机地址，通常指响应报文） 2） INPUT：报文进入本机用户空间位置，允许的表filter, mangle 3） OUTPUT：报文从本机用户空间出去的位置，允许filter, mangle, nat 4） FOWARD：报文经过路由并且发觉不是本机决定转发但还不知道从哪个网卡出去，允许filter, mangle 5） POSTROUTING：报文经过路由被转发出去，允许mangle，nat（源地址转换，把原始地址转换为转发主机出口网卡地址） 流入本机：PREROUTING --&gt; INPUT --&gt; PROCESS(进程) 经过本机：PREROUTING --&gt; FORWARD --&gt; POSTROUTING 从本机流出：PROCESS(进程) --&gt; OUTPUT --&gt; POSTROUTING 7、Iptables流程图12345678流入本机： A ---&gt; PREROUTING ---&gt; INPUT ---&gt; B流出本机：OUTPUT ---&gt; POSTROUTING ---&gt; B经过本机： A ---&gt; OUTPUT ---&gt; POSTROUTING | ---&gt; PREROUTING ---&gt; FORWARD ---&gt; POSTROUTING ---&gt; C ---&gt; PREROUTING ---&gt; INPUT ---&gt; Bfilter : INPUT 、FORWARD、 OUTPUT nat : PREROUTING 、 INPUT、 OUTPUT、 POSTROUTINGraw : PREROUTING、 OUTPUTmangle : PREROUTING INPUT FORWARD OUTPUT POSTROUTING 8、Iptables的使用12345678910111213141516171819202122232425262728293031321、安装Iptables [root@m01 ~]# yum install iptables*2、启动Iptables [root@m01 ~]# systemctl start iptables3、关闭firewalld [root@m01 ~]# systemctl disable --now firewalld格式：iptables -t 表名 选项 链名称 条件 动作-t： 指定操作的表-L, --list 列出当前的规则-v 显示数据包和数据包大小-n 不反解地址-A, --append 追加一条规则到链中-I, --insert 插入一条规则，插入到顶部-F, --flush 清空-Z, --zero 清空计数器（ 包数量 、包大小）-D, --delete 删除链中的规则-R, --replace 修改-S, --list-rules 列出所有的规则-N, --new-chain 创建一个自定义 链-X, --delete-chain 删除一个自定义链-P, --policy 指定链的默认策略 9、iptables动作1234ACCEPT 将数据包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链。REJECT 拦阻该数据包，并传送数据包通知对方。DROP 丢弃包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。REDIRECT 将包重新导向到另一个端口，进行完此处理动作后，将会继续比对其它规则。 10、Iptables基本的条件匹配1234TCP(http)UDPICMP(ping)ALL 11、-s、-d 源地址、目标地址123源地址：发送请求的地址目标地址 : 访问的地址 12、–sport源端口、–dport 目标端口123源端口：发送请求的端口目标端口：访问的端口 13、-i、-o、-m、-j 动作12345-i : 进来的网卡-o : 出去的网卡-m : 指定模块-j : 转发动作-p ：指定协议 14、案例123456789101112131415161718192021222324252627282930313233343536373839案例1：只允许22端口可以访问，其他端口全部无法访问。 iptables -t filter -A INPUT -p TCP --dport 22 -j ACCEPTiptables -t filter -A INPUT -p TCP -j DROP案例2：只允许22，80，443端口可以访问，其他端口全部无法访问。 iptables -t filter -A INPUT -p TCP --dport 22 -j ACCEPTiptables -t filter -A INPUT -p TCP --dport 80 -j ACCEPTiptables -t filter -A INPUT -p TCP --dport 443 -j ACCEPTiptables -t filter -A INPUT -p TCP -j DROP案例3：只允许22，80，443端口可以访问，其他端口全部无法访问，但是本机可以访问百度。 案例4：要求使用192.168.15.81能够通过22端口链接，但是其他的不行iptables -t filter -A INPUT -p TCP -d 192.168.15.81 --dport 22 -j ACCEPTiptables -t filter -A INPUT -p TCP -j DROP案例5：只允许192.168.15.71能够通过22端口链接，其他的不行。iptables -t filter -A INPUT -p TCP -s 192.168.15.71 -d 192.168.15.81 --dport 22 -j ACCEPTiptables -t filter -A INPUT -p TCP -j DROP案例6：要求192.168.15.71对外部不可见iptables -t filter -A INPUT -p TCP -d 192.168.15.71 -j DROP案例7：要求使用eth0网卡的所有请求全部拒绝iptables -t filter -A INPUT -p TCP -i etho -j DROP使用172.16.1.71登录进来的窗口，不允许访问百度。iptables -t filter -I OUTPUT -p TCP -o eth1 -j DROP案例8：要求访问服务器的8080端口转发至80端口iptables -t nat -A PREROUTING -p TCP --dport 8080 -j REDIRECT --to-port 80案例9：要求只允许windows通过ssh连接192.168.15.81，其他的拒绝iptables -t filter -A INPUT -p TCP -s 192.168.15.1 -d 192.168.15.81 --dport 22 -j ACCEPTiptables -t filter -A INPUT -p TCP --dport 22 -j DROP知识储备： 查看本机端口占用的命令： netstat -nutlp 15、模块123456789101112131415161718192021222324252627282930313233343536拓展iptables的功能的。-m : 指定模块1、连续匹配多个端口（multiport） --dports : 指定多个端口(不同端口之间以逗号分割，连续的端口使用冒号分割)。 2、指定一段连续的ip地址范围(iprange) --src-range from[-to]: 源地址范围 --dst-range from[-to] 目标地址范围3、匹配指定字符串(string) --string pattern # 指定要匹配的字符串 --algo &#123;bm|kmp&#125; # 匹配的查询算法 4、根据时间段匹配报文(time) --timestart hh:mm[:ss] # 开始时间 --timestop hh:mm[:ss] # 结束时间 --monthdays day[,day...] # 指定一个月的某一天 --weekdays day[,day...] # 指定周 还是 周天 5、禁ping, 默认本机无法ping别人 、别人无法ping自己 --icmp-type &#123;type[/code]|typename&#125; echo-request (8) 请求 echo-reply (0) 回应6、限制链接数，并发连接数（connlimit） --connlimit-upto n # 如果现有连接数小于或等于 n 则 匹配 --connlimit-above n # 如果现有连接数大于n 则匹配7、针对 报文速率 进行限制。 秒、分钟、小时、天。 --limit rate[/second|/minute|/hour|/day] # 报文数量 --limit-burst number # 报文数量（默认：5） 16、-m案例12345678910111213141516171819202122232425261、要求将22,80,443以及30000-50000之间所有的端口向外暴露，其他端口拒绝 iptables -t filter -A INPUT -p TCP -m multiport --dports 22,80,443,30000:50000 -j ACCEPT iptables -f filter -A INPUT -p TCP -j DROP2、要求访问数据包中包含HelloWorld的数据不允许通过。 iptables -t filter -A INPUT -p TCP -m string --string &quot;HelloWorld&quot; --algo kmp -j DROP3、要求192.168.15.1 - 192.168.15.10之间的所有IP能够连接192.168.15.81，其他拒绝 iptables -t filter -A INPUT -p TCP -m iprange --src-range 192.168.15.1-192.168.15.10 -j ACCEPT iptables -f filter -A INPUT -p TCP -j DROP4、要求每天的12到13之间，不允许访问 iptables -t filter -A INPUT -p TCP -m time --timestart 4:00 --timestop 5:00 -j DROP 必须使用UTC时间5、要求别人不能ping本机，但是本机可以ping别人 iptables -t filter -A INPUT -p TCP -m icmp --icmp-type &quot;echo-request&quot; -j DROP 6、要求主机连接最多有2个 iptables -t filter -A INPUT -p TCP --dport 22 -m connlimit --connlimit-above 2 -j DROP 7、要求限制速率在500k/s左右 iptables -t filter -A INPUT -p TCP -m limit 333/s -j ACCEPT iptables -t filter -A INPUT -p TCP -j DROP","categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"}]},{"title":"13、Linux基础练习题","slug":"Linux基础--day13考试","date":"2018-06-13T06:04:13.000Z","updated":"2022-05-13T12:30:27.858Z","comments":true,"path":"2018/06/13/Linux基础--day13考试/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day13%E8%80%83%E8%AF%95/","excerpt":"","text":"考试1、找出&#x2F;proc&#x2F;meminfo文件中以s开头的行，至少用三种方式忽略大小写1234[root@localhost ~]# grep -E &#x27;^[sS]&#x27; /proc/meminfo [root@localhost ~]# sed -r -n &#x27;/^[sS]/p&#x27; /proc/meminfo[root@localhost ~]# awk &#x27;/^[sS]/&#123;print $0&#125;&#x27; /proc/meminfo[root@localhost ~]# grep -iE &#x27;^s&#x27; /proc/meminfo 2、显示当前系统上的以root,centos或者user开头的信息1[root@localhost ~]# grep -rE &#x27;^(root|centos|user)&#x27; /etc/ 3、找出&#x2F;etc&#x2F;init.d&#x2F;functions文件下包含小括号的行1[root@localhost ~]# grep -E &#x27;\\(|\\)&#x27; /etc/init.d/functions 4、输出指定目录的基名1[root@localhost /etc/sysconfig]# pwd | awk -F/ &#x27;&#123;print $NF&#125;&#x27; 5、找出网卡信息中包含的数字1[root@localhost /etc/sysconfig]# grep -oE &#x27;[0-9]+&#x27; /etc/sysconfig/network-scripts/ifcfg-ens3[23] 6、找出&#x2F;etc&#x2F;passwd下每种解析器的用户个数123&#123;&quot;bash&quot;: 10, &quot;sh&quot;: 9, &quot;zsh&quot;: 1&#125;数组[root@localhost /etc/sysconfig]# awk -F: &#x27;&#123;arr[$NF]++&#125;END&#123;for(i in arr)&#123;print i,arr[i]&#125;&#125;&#x27; /etc/passwd 7、获取网卡中的ip，用三种方式实现123[root@localhost /etc/sysconfig]# ip a | grep -oE &#x27;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;[root@localhost /etc/sysconfig]# ip a | sed -r -n &#x27;/([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;/p&#x27;[root@localhost /etc/sysconfig]# ip a | awk &#x27;/([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;/&#123;if(NR==3)&#123;print $2&#125;else&#123;print $2,$4&#125;&#125;&#x27; 8、搜索&#x2F;etc目录下，所有的.html或.php文件中main函数出现的次数1[root@localhost ~]# grep -rE &#x27;main&#x27; `find /etc/ -name &quot;*.html&quot; -o -name &quot;*.php&quot; | xargs ` | wc -l 9、过滤掉php.ini中注释的行和空行12[root@localhost ~]# yum install php php-devel[root@localhost ~]# grep -vE &#x27;^\\ *;|^$&#x27; /etc/php.ini 10、找出文件中至少有一个空格的行1[root@localhost ~]# grep -E &#x27;\\ +&#x27; /etc/php.ini 11、过滤文件中以#开头的行，后面至少有一个空格1[root@localhost ~]# grep -E &#x27;^#\\ +&#x27; /etc/fstab 12、查询出&#x2F;etc目录中包含多少个root1[root@localhost ~]# grep -roE &#x27;root&#x27; /etc/ | wc -l 13、查询出所有的qq邮箱1[root@localhost ~]# grep -E &#x27;[0-9a-zA-Z-_]+@qq\\.com&#x27; 14、查询系统日志中所有的error1[root@localhost ~]# grep -E &#x27;error&#x27; /var/log/messages 15、删除某文件中以s开头的行的最后一个词1[root@localhost ~]# grep -Ei &#x27;^s&#x27; 11.txt | grep -oE &#x27;[0-9a-zA-Z]+&#x27; | xargs | awk &#x27;&#123;for(i=0;i&lt;(NF-1);i++)&#123;print $i&#125;&#125;&#x27; 16、删除一个文件中的所有数学1[root@localhost ~]# sed -r &#x27;s/[0-9]//g&#x27; 11.txt 17、显示奇数行1[root@localhost ~]# awk -F: &#x27;NR%2==1&#123;print $0&#125;&#x27; /etc/passwd 18、删除passwd文件中以bin开头的行到nobody开头的行1[root@localhost ~]# sed -r &#x27;/^bin/,/^nobody/d&#x27; /etc/passwd 19、从指定行开始，每隔两行显示一次空行1[root@localhost ~]# awk -F: &#x27;&#123;n=5;if(NR&lt;n)&#123;print $0&#125;else&#123;if((NR-5)%2==0)&#123;print &quot;---&quot;&#125;;print $0&#125;&#125;&#x27; /etc/passwd 20、每隔5行打印一个空行1[root@localhost ~]# awk -F: &#x27;&#123;if(NR%5==0)&#123;print &quot; &quot;&#125;; print $0&#125;&#x27; /etc/passwd 21、不显示指定字符的行1[root@localhost ~]# grep -vE &#x27;g&#x27; 2.txt 22、将文件中1到5行中aaa替换成AAA1[root@localhost ~]# sed -r &#x27;1,5s/aaa/AAA/g&#x27; 13.txt 23、显示用户id为奇数的行1[root@localhost ~]# awk -F: &#x27;$3%2==1&#123;print $0&#125;&#x27; /etc/passwd 24、显示系统普通用户，并打印系统用户名和id1[root@localhost ~]# awk -F: &#x27;$3&gt;=1000&#123;print $1, $3&#125;&#x27; /etc/passwd 25、统计nginx日志中独立用户数(ip维度计算)1[root@localhost ~]# awk &#x27;/([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;/&#123;arr[$1]++&#125;END&#123;for(i in arr)&#123;print i&#125;&#125;&#x27; access.log 26、统计php.ini中每个词的个数1[root@localhost ~]# grep -oE &#x27;[0-9a-zA-Z]+&#x27; /etc/php.ini | awk &#x27;&#123;arr[$1]++&#125;END&#123;for(i in arr)&#123;printf &quot;%-15s | %-5d\\n&quot;, i, arr[i]&#125;&#125;&#x27; 27、实时打印nginx的访问ip 28、统计1分钟内访问nginx次数超过10次的ip30、统计访问nginx前10的ip","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"12、磁盘管理、awk","slug":"Linux基础--day12","date":"2018-06-13T06:04:12.000Z","updated":"2022-05-13T12:30:25.126Z","comments":true,"path":"2018/06/13/Linux基础--day12/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day12/","excerpt":"","text":"笔记1、晨考123456789101112131、用两种方法，实现将文件中的以# 开头的行把# 去掉 sed -r &#x27;s/^#//g&#x27; /etc/fstab cat /etc/fstab | tr -d &#x27;^#&#x27;2、将文件中的Hello World 替换成 World Hello sed -r &#x27;s/Hello World/World Hello/g&#x27; 7.txt awk &#x27;&#123;print $2,$1&#125;&#x27; 7.txt 3、删除一个文本中所有的数字 sed -r &#x27;s/[0-9]+//g&#x27; 8.txt cat 8.txt | tr -d &#x27;[0-9]+&#x27; 2、昨日问题123451、sed包含几个部分sed [参数] [匹配规则] [操作对象] 1、定位 2、编辑模式 3、今日内容12345678910111213141516171、磁盘管理2、awk 1、参数 2、匹配规则 BEGIN &#123;&#125; // END&#123;&#125; FS NR NF if for 自定义变量 4、磁盘管理123456789101112131415161718192021222324252627282930313233343536Linux系统中磁盘管理就是将硬盘通过挂载的方式挂载到linux文件系统中。1、挂载磁盘的步骤 1、磁盘分区 2、挂载2、磁盘分区 fdisk：分区2TB以下的磁盘，最多可以分4个分区 gdisk：分区2TB以上的磁盘，最多可以分128个分区3、添加一块磁盘 lsblk ： 查看本机的磁盘 df -h : 查看本机的分区4、磁盘分区 n : 新建一个分区 p : 打印分区表 w : 写入磁盘并退出 q : 退出 d : 删除一个分区 5、挂载磁盘分区 1、格式化文件系统 mkfs.xfs /dev/sdb1 6、总结 1、关机 2、添加硬盘 3、创建分区 fdisk /dev/sdb 或 gdisk /dev/sdb 4、格式化文件系统 mkfs.xfs /dev/sdb1 5、挂载 mount /dev/sdb1 /mnt 5、awk123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144awk主要是用来格式化文本。1、awk的语法 awk [参数] [处理规则] [操作对象]2、参数 -F : 指定文本分隔符（默认是以空格作为分隔符） awk -F&#x27;f&#x27; &#x27;&#123;print $NF&#125;&#x27; 9.txt 案例：打印系统所有用户的解析器 awk -F: &#x27;&#123;print $NF&#125;&#x27; /etc/passwd3、awk的生命周期 grep、sed和awk都是读一行处理一行，直至处理完成。 1、接收一行作为输入 2、把刚刚读入进来得到文本进行分解 3、使用处理规则处理文本 4、输入一行，赋值给$0，直至处理完成 5、把处理完成之后的所有的数据交给END&#123;&#125;来再次处理4、awk中的预定义变量 $0 : 代表当前行 [root@localhost ~]# awk -F: &#x27;&#123;print $0, &quot;---&quot;&#125;&#x27; /etc/passwd $n ：代表第n列 [root@localhost ~]# awk -F: &#x27;&#123;print $1&#125;&#x27; /etc/passwd NF ：记录当前行的字段数 [root@localhost ~]# awk -F: &#x27;&#123;print NF&#125;&#x27; /etc/passwd [root@localhost ~]# awk -F: &#x27;&#123;print $NF&#125;&#x27; /etc/passwd NR ：用来记录行号 [root@localhost ~]# awk -F: &#x27;&#123;print NR&#125;&#x27; /etc/passwd FS ：指定文本内容分隔符（默认是空格） [root@localhost ~]# awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $NF, $1&#125;&#x27; /etc/passwd FS 的优先级要高于 -F OFS ：指定打印分隔符（默认空格） [root@localhost ~]# awk -F: &#x27;BEGIN&#123;OFS=&quot; &gt;&gt;&gt; &quot;&#125;&#123;print $NF, $1&#125;&#x27; /etc/passwd5、awk处理规则的执行流程 BEGIN&#123;&#125; // &#123;&#125; END&#123;&#125; 6、awk中的函数 print : 打印 printf ：格式化打印 %s : 字符串 %d ：数字 - ：左对齐 + ：右对齐 15 : 至少占用15字符 [root@localhost ~]# awk -F: &#x27;BEGIN&#123;OFS=&quot; | &quot;&#125;&#123;printf &quot;|%+15s|%-15s|\\n&quot;, $NF,$1&#125;&#x27; /etc/passwd7、awk中的定位 1、正则表达式 [root@localhost ~]# awk -F: &#x27;/root/&#123;print $0&#125;&#x27; /etc/passwd [root@localhost ~]# awk -F: &#x27;/^root/&#123;print $0&#125;&#x27; /etc/passwd 2、比较表达式 &gt; &lt; &gt;= &lt;= ~ 正则匹配 !~ 正则匹配（取反） 案例：要求打印属组ID大于属主ID的行 [root@localhost ~]# awk -F: &#x27;$4 &gt; $3&#123;print $0&#125;&#x27; /etc/passwd 案例：结尾包含bash [root@localhost ~]# awk -F: &#x27;$NF ~ /bash/&#123;print $0&#125;&#x27; /etc/passwd 案例：结尾不包含bash [root@localhost ~]# awk -F: &#x27;$NF !~ /bash/&#123;print $0&#125;&#x27; /etc/passwd 3、逻辑表达式 &amp;&amp; : 逻辑与 || ：逻辑或 ! ：逻辑非 [root@localhost ~]# awk -F: &#x27;$3 + $4 &gt; 2000 &amp;&amp; $3 * $4 &gt; 2000&#123;print $0&#125;&#x27; /etc/passwd [root@localhost ~]# awk -F: &#x27;$3 + $4 &gt; 2000 || $3 * $4 &gt; 2000&#123;print $0&#125;&#x27; /etc/passwd [root@localhost ~]# awk -F: &#x27;!($3 + $4 &gt; 2000)&#123;print $0&#125;&#x27; /etc/passwd 4、算术表达式 + - * / % 案例：要求属组 + 属主的ID 大于 2000 [root@localhost ~]# awk -F: &#x27;$3 + $4 &gt; 2000&#123;print $0&#125;&#x27; /etc/passwd 案例：要求属组 * 属主的ID 大于 2000 [root@localhost ~]# awk -F: &#x27;$3 * $4 &gt; 2000&#123;print $0&#125;&#x27; /etc/passwd 案例：要求打印偶数行 [root@localhost ~]# awk -F: &#x27;NR % 2 == 0&#123;print $0&#125;&#x27; /etc/passwd 案例：要求打印奇数行 [root@localhost ~]# awk -F: &#x27;NR % 2 == 1&#123;print $0&#125;&#x27; /etc/passwd 5、条件表达式 == &gt; &lt; &gt;= &lt;= 案例：要求打印第三行 [root@localhost ~]# awk -F: &#x27;NR == 3&#123;print $0&#125;&#x27; /etc/passwd 6、范围表达式 [root@localhost ~]# awk -F: &#x27;/^root/,/^ftp/&#123;print $0&#125;&#x27; /etc/passwd8、流程控制 只存在循环之中。 if [root@localhost ~]# awk -F: &#x27;&#123;if($3&gt;$4)&#123;print &quot;大于&quot;&#125;else&#123;print &quot;小于或等于&quot;&#125;&#125;&#x27; /etc/passwd if()&#123;&#125; if()&#123;&#125;else&#123;&#125; if()&#123;&#125;else if()&#123;&#125;else&#123;&#125; for [root@localhost ~]# awk -F: &#x27;&#123;for(i=10;i&gt;0;i--)&#123;print $0&#125;&#125;&#x27; /etc/passwd for(i=&quot;初始值&quot;;条件判断;游标)&#123;&#125; while [root@localhost ~]# awk -F: &#x27;&#123;i=1; while(i&lt;10)&#123;print $0, i++&#125;&#125;&#x27; /etc/passwd while(条件判断)&#123;&#125; 每隔5行，打印一行横线 ------------------------------------------------------------------------- [root@localhost ~]# awk -F: &#x27;&#123;if(NR%5==0)&#123;print &quot;----------------&quot;&#125;print $0&#125;&#x27; /etc/passwd","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"11、文本处理命令、Linux三剑客之sed","slug":"Linux基础--day11","date":"2018-06-13T06:04:11.000Z","updated":"2022-05-13T12:30:22.771Z","comments":true,"path":"2018/06/13/Linux基础--day11/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day11/","excerpt":"","text":"笔记1、晨考123456789101112131、写出过滤手机号的正则表达式 1[0-9]&#123;10&#125;2、写出过滤邮箱的正则表达式 chenyang@123.com [a-zA-Z0-9-_]+@[a-z0-9]+\\.(com|cn|com\\.cn|net)3、过滤密码，要求必须要大写字母、小写字母、数字以及下划线，长度在 8 到 16 之间 ([A-Z]+[a-z]+[0-9]+_+)&#123;8,16&#125;4、过滤本地的IP ip a | grep -E &#x27;([(1[0-9]&#123;2&#125;)&#123;3&#125;(2[0-4][0-9])&#123;3&#125;(25[0-4])&#123;3&#125;[0-9]&#123;1,2&#125;]\\.)&#123;3&#125;[(1[0-9]&#123;2&#125;)&#123;3&#125;(2[0-4][0-9])&#123;3&#125;(25[0-4])&#123;3&#125;[0-9]&#123;1,2&#125;]&#x27; ([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125; 2、昨日问题1 3、今日内容1231、文本处理命令2、linux三剑客之sed 2.1、定位 4、文本处理命令1234567891011121314151617181920212223242526272829303132333435361、sort命令 用于将文件内容加以排序 -n # 依照数值的大小排序 -r # 以相反的顺序来排序 -k # 以某列进行排序 -t # 指定分割符，默认是以空格为分隔符 cat 3.txt | sort -n -r -k3 -t &#x27;|&#x27;2、uniq 命令 用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用 -c # 在每列旁边显示该行重复出现的次数。 -d # 仅显示重复出现的行列。 -u # 仅显示出一次的行列3、cut 命令 cut命令用来显示行中的指定部分，删除文件中指定字段 -d # 指定字段的分隔符，默认的字段分隔符为&quot;TAB&quot;； -f # 显示指定字段的内容；4、tr命令 替换或删除命令 -d # 删除字符5、wc命令 统计，计算数字 -c # 统计文件的Bytes数； -l # 统计文件的行数； -w # 统计文件中单词的个数，默认以空白字符做为分隔符 注：在Linux系统中，一段连续的数字或字母组合为一个词。 5、linux三剑客之sed123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960sed是linux中，流媒体编辑器、流处理工具。grep ： 过滤文本sed : 修改文本awk : 处理文本sed与awk的区别： 参考：https://www.zhihu.com/question/2978587141、sed的格式 sed [参数] &#x27;处理规则&#x27; [操作对象]2、参数 -e ： 允许多项编辑 -n : 取消默认输出 -i : 就地编辑 -r : 支持拓展正则 -f : 指定sed匹配规则脚本文件3、定位 1、数字定位法 指定行号。 sed &#x27;3d&#x27; 4.txt sed &#x27;2,3d&#x27; 4.txt 2、正则定位法 指定正则定位。 sed &#x27;/^g/d&#x27; 2.txt 3、数字和正则定位法 sed &#x27;3,/^g/d&#x27; 2.txt 4、正则正则定位法 sed &#x27;/^g/,/^j/d&#x27; 2.txt 4、sed的编辑模式： d ：删除 p ：打印 a : 在当前行后添加一行或多行 sed &#x27;2axxx&#x27; 4.txt c ：用新文本修改（替换）当前行 sed &#x27;2cxxx&#x27; 4.txt i : 在当前行之前，插入文本（单独使用时） sed &#x27;2ixxx&#x27; 4.txt r : 在文件中读内容 sed &#x27;2r r.txt&#x27; 2.txt w : 将指定行写入文件 sed &#x27;2w w.txt&#x27; 2.txt y : 将字符转换成另一个字符 sed &#x27;2y/fa/FA/&#x27; 2.txt s : 将字符串转换成另一个字符串（每一行只替换一次） sed &#x27;s/11/22/&#x27; 6.txt g : 全部执行 sed &#x27;s/11/22/g&#x27; 6.txt i : 忽略大小写（跟 s 模式一起使用时） &amp; ：代表前面匹配到的内容 6、案例12345678910111213141、将nginx.conf中的注释行全部去掉 [root@localhost ~]# sed &#x27;/^ *#/d&#x27; /etc/nginx/nginx.conf2、将nginx.conf中每一行之前增加注释 [root@localhost ~]# sed &#x27;s/.*/# &amp;/g&#x27; /etc/nginx/nginx.conf3、要求一键修改本机的ip， 192.168.15.100 ---&gt; 192.168.15.101 172.16.1.100 ---&gt; 172.16.1.101 sed -i &#x27;s#.100#.101#g&#x27; /etc/sysconfig/network-scripts/ifcfg-eth[01] 4、将/etc/passwd中的root修改成ROOT sed -i &#x27;s#root#ROOT#g&#x27; /etc/passwd","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"10、find、grep、正则表达式","slug":"Linux基础--day10","date":"2018-06-13T06:04:10.000Z","updated":"2022-05-13T12:30:20.246Z","comments":true,"path":"2018/06/13/Linux基础--day10/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day10/","excerpt":"","text":"笔记1、晨考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551、每个月的3号、5号和15号，而且这天是星期六时执行 00 00 3,5,15 * 6 2、每天的3点到15点，每隔3分钟执行一次 */3 3-15 * * * 3、每周六早上2点半执行 30 02 * * 6 4、每隔两个月的一号下午10点执行 00 22 01 */2 * 5、root密码忘记了的解决办法 1、重启 2、在启动选择系统内核界面，按 e 键进入单用户模式 3、找到 linux16 开头行，删除 ro ， 并且在 ro 处添加 rw init=/sysroot/bin/sh 4、按 ctrl + x 进行系统重新引导 5、执行 chroot /sysroot 6、执行 passwd root 7、执行 touch /.autorelabel 8、执行 Ctrl + D 重启系统6、yum私有仓库的搭建步骤 1、安装工具 yum install createrepo yum-utils nginx -y 2、创建目录 mkdir /opt/test 3、创建包目录 mkdir /opt/test/Packages 4、下载安装包 下载到Packages目录中 https://repo.huaweicloud.com/centos/7/os/x86_64/Packages/zsh-5.0.2-34.el7_8.2.x86_64.rpm 5、初始化仓库 createrepo /opt/test 7、修改nginx的配置文件 [root@localhost /mnt]# vim /etc/nginx/nginx.conf # include /etc/nginx/conf.d/*.conf; root /opt/test; autoindex on; 8、启动Nginx systemctl start nginx 9、添加yum源 yum-config-manager --add-repo=http://192.168.15.101 10、测试 yum install zsh -y 2、昨日问题3、今日内容1231、find2、正则表达式3、linux三剑客之grep 4、find12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061根据文件的名称或者属性查找文件。语法格式： find [查找范围] [参数]参数： -name : 按照文件的名字查找文件 * ：通配符 -iname : 按照文件的名字查找文件(忽略大小写) -size : 按照文件的大小查询文件 + ： 大于 - ： 小于 没符号 ： 等于 -mtime : 按照修改时间去查询 +（可以省略） ： n 天以前 - ： n 天以内 -atime -ctime -user :按照用户的属主查询 -group : 按照用户的属组查询 -type : 按照文件的类型查询 d ： 文件夹 l : 链接文件 s : 套接字文件 p ： 管道文件 c : 字符文件 b ：磁盘文件 f : 普通文件 -perm : 按照文件的权限查询 -inum : 根据index node号码查询 -a : 并且（可以省略，默认时并且） -o : 或者 -maxdepth : 查询的目录深度（必须放置与第一个参数位） -exec : 将find处理好的结果交给其他命令继续处理。知识储备： dd : 生成文件 if ：从什么地方读 of : 写入到什么文件 bs : 每次写入多少内容 count : 写入多少次案例： 案例1：查询/etc目录下hosts文件 [root@localhost ~]# find /etc/ -name &#x27;hosts&#x27; /etc/hosts 案例2：查询/etc目录下名称中包含hosts文件 [root@localhost ~]# find /etc/ -name &#x27;*hosts*&#x27; 案例3：要求把/etc目录下，所有的普通文件打包压缩到/tmp目录 [root@localhost /tmp]# tar -czPf /tmp/etcv2.tar.gz `find /etc/ -type f | xargs`知识储备 | ： 前面一个命令的结果交给后面一个命令处理 xargs ： 把处理的文本变成以空格分割的一行 `` : 提前执行命令，然后将结果交给其他命令来处理 5、grep123456789101112131415161718192021222324252627282930linux三剑客之一，文本过滤器（根据文本内容过滤文件）。语法格式： grep [参数] [匹配规则] [操作对象]参数： -n : 过滤文本时，将过滤出来的内容在文件内的行号显示出来 -A ： 匹配成功之后，将匹配行的后n行显示出来 -B ： 匹配成功之后，将匹配行的前n行显示出来 -C ： 匹配成功之后，将匹配行的前后各n行显示出来 -c : 只显示匹配成功的行数 -o : 只显示匹配成功的内容 -v : 反向过滤 -q : 静默输出 -i ： 忽略大小写 -l : 匹配成功之后，将文本的名称打印出来 -R|-r : 递归匹配 -E ： 使用拓展正则 等价于 egrep知识储备： $? ： 上一行命令执行的结果，0代表执行成功，其他数字代表执行失败。 wc : 匹配行数 -l : 打印匹配行数 -c : 打印匹配的字节数 在/etc目录下，有多少个文件包含root。 grep -rl &#x27;root&#x27; /etc/ | wc -l 6、正则表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481、正则表达式的分类（grep） 1、普通正则表达式 2、拓展正则表达式2、普通正则表达式 ^ : 以某字符开头 $ : 以某字符结尾 . : 匹配除换行符之外的任意单个字符 * ：匹配前导字符的任意个数 [] : 某组字符串的任意一个字符 [^] : 取反 [a-z] : 匹配小写字母 [A-Z] : 匹配大写字母 [a-zA-Z] : 匹配字母 [0-9] : 匹配数字 \\ : 取消转义 () : 分组 \\n : 代表第n个分组3、拓展正则 &#123;&#125; ：匹配的次数 &#123;n&#125; : 匹配n次 &#123;n,&#125; ：至少匹配n次 &#123;n,m&#125; ：匹配 n 到 m 次 &#123;,m&#125; ：最多匹配m次 + ：匹配至少有一个前导字符 ? : 匹配一个或零个前导字符 | ：或案例： 案例1：在/etc/passwd文件中，匹配以ftp开头的行 grep &#x27;^ftp&#x27; /etc/passwd 案例2：在/etc/passwd文件中，匹配以bash结尾的行 grep &#x27;bash$&#x27; /etc/passwd 案例3：匹配本机中有哪些ip ip a | grep -oE &#x27;([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;&#x27; 案例4：要求将/etc/fstab中的去掉包含 # 开头的行，且要求 # 后至少有一个空格 grep -vE &#x27;^#\\ +&#x27; /etc/fstab 案例5：找出文件中至少有一个空格的行 grep -E &#x27;\\ +&#x27; xxx 案例6：将 nginx.conf 文件中以#开头的行和空行，全部删除 grep -vE &#x27;^\\ *#|^$&#x27; /etc/nginx/nginx.conf","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"09、编译安装、压缩打包、定时任务","slug":"Linux基础--day09","date":"2018-06-13T06:04:09.000Z","updated":"2022-05-13T12:30:17.957Z","comments":true,"path":"2018/06/13/Linux基础--day09/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day09/","excerpt":"","text":"笔记1、晨考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081821、搭建yum私有仓库的步骤 1、安装工具 yum install createrepo yum-utils nginx -y 2、创建目录 mkdir /opt/test 3、创建包目录 mkdir /opt/test/Packages 4、下载安装包 下载到Packages目录中 https://repo.huaweicloud.com/centos/7/os/x86_64/Packages/zsh-5.0.2-34.el7_8.2.x86_64.rpm 5、初始化仓库 createrepo /opt/test 6、安装远程软件 vim /etc/yum.repos.d/nginx.repo [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true yum install nginx -y 7、修改nginx的配置文件 [root@localhost /mnt]# vim /etc/nginx/nginx.conf # include /etc/nginx/conf.d/*.conf; root /opt/test; autoindex on; 8、启动Nginx systemctl start nginx 9、添加yum源 yum-config-manager --add-repo=http://192.168.15.101 10、测试 yum install zsh -y 2、将index文件添加属主 : 可读可写可执行、属组 ：可读可写、其他人：没有任何权限 chmod 760 index3、将baidu下的所有文件设置rwxr--r-- chmod -R 744 baidu4、RPM安装、卸载与升级 rpm -ivh rpm -e rpm -Uvh5、yum安装、卸载升级的命令 yum install yum remove yum update6、yum的生命周期 1、执行yum install 2、在/etc/yum.repos.d找源 3、去对应的仓库下载软件 4、安装 5、清除缓存7、将系统设置中文编码 export LANG=zh_CN.UTF-8 vim /etc/locale.conf 2、昨日问题3、今日内容1231、编译安装2、压缩打包3、定时任务管理 4、编译安装12345678910111213141516171819202122232425262728293031323334353637使用源代码，编译打包软件。1、特点 1、可以自定制软件 2、按需构建软件啊2、编译安装 1、下载源代码包 wget https://nginx.org/download/nginx-1.20.2.tar.gz yum install pcre pcre-devel zlib zlib-devel -y 2、解压 tar -xf nginx-1.20.2.tar.gz 3、设置系统参数 cd nginx-1.20.2 # 自定制 vim ./src/core/nginx.h ./configure 4、编译 make 5、安装 make install 6、启动 /usr/local/nginx/sbin/nginx # 关闭 /usr/local/nginx/sbin/nginx -s stop systemctl stop nginx知识储备： tar -xf [压缩包名称] 5、压缩打包123456789101112131415161718192021222324252627282930313233343536win中的压缩包：zip rarLinux常见的压缩包有哪些？ gzip bzip21、gzip压缩 压缩命令：gzip [压缩文件] 解压命令：gzip -d [压缩包]2、bzip2压缩 压缩命令：bzip2 [压缩文件] 解压命令：bzip2 -d [压缩包] 无法压缩目录3、打包 tar : 打包的命令 参数： -f : 指定打包的包名称 -c : 打包 -v : 显示打包的过程 -z : 使用gzip压缩压缩包 -j : 使用bzip2压缩压缩包 -x : 解压（解压不需要指定压缩类型） -t : 查看压缩包内部的内容 -P ：忽略使用绝对路径时报出的错误 注意： 1、压缩时是什么路径，解压缩时就是什么路径，所以为了安全不要使用绝对路径压缩。 2、-f参数后面永远跟压缩包名称 6、定时任务123456789101112131415161718192021222324252627282930313233343536373839* * * * * ： crontab表达式分 时 日 月 周1、增加定时任务(crontab -e) 每天的凌晨2：50执行/root/1.sh 50 02 * * * /root/1.sh2、查看crontab定时任务 crontab -l3、每一个用户的定时任务是相对隔离，在/var/spool/cron目录下，以当前用户的用户名命名的文件。4、常用命令 head: 从头部开始查看文件，默认查看10行 -n ： 指定查看多少行 tail: 从尾部开始查看文件，默认查看10行 -n ： 指定查看多少行 -f : 实时监控文件变化 less: 类似于vim的方式查看文件 cat grep egrep5、定时任务格式 * * * * * 每隔2分钟执行 */2 * * * * 每天的2，4，6，8，10这4个小时的1分钟执行 01 2,4,6,10 * * * 每天的2到6点执行 00 2-6 * * * 每天的2到6点中每隔2小时执行 00 2-6/2 * * * 00 02 * * 02 : 每天的2点时执行，但是这天必须时周二","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"08、Linux安装软件的三种方式、系统安全优化、防止系统乱码","slug":"Linux基础--day08","date":"2018-06-13T06:04:08.000Z","updated":"2022-05-13T12:30:15.524Z","comments":true,"path":"2018/06/13/Linux基础--day08/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day08/","excerpt":"","text":"笔记1、晨考1234567891011121314151617181920212223242526272829303132333435361、文件的三种时间属性，每一种时间属性在什么情况下改变 atime : 访问时间 mtime ：修改时间 ctime ：修改属性时间2、权限的类型 可读（r, 4） 可写（w, 2） 可执行（x, 1）3、linux中的权限有三个权限位，分别对应谁的 属主 属组 其他人4、权限归属有几种，分别是什么？ 属主（u） 属组（g） 其他人（o）5、查看系统名称，内核版本以及硬件位数 uname -a6、设置用户密码的两种方式 passwd [用户名] echo &#x27;密码&#x27; | passwd --stdin [用户名]7、查看当前登录系统的用户 whoami 2、昨日问题12yum私有仓库nginx的问题 3、今日内容12341、linux中安装软件的三种方式2、yum私有仓库3、selinux和firewalld(iptables)4、怎么解决系统乱码 4、Linux中安装软件的三种方式1234567891、哪三种方式？ rpm安装 yum安装 源代码编译安装 2、区别 rpm安装类似于windows中的安装包，下载下来之后直接安装。缺点是不能自己解决依赖。 yum安装基于rpm安装，也就是在rpm上增加了自动解决依赖的功能。 源代码安装：通过编译源代码，得到软件包。优点是可以自定制软件包，缺点是比较复杂。 4.1、RPM安装1234567891011121314151617181920212223242526272829303132333435363738394041424344安装：rpm -ivh [软件包名称]卸载：rpm -e [软件包名称]升级：rpm -Uvh [软件包名称]1、下载安装包2、安装 [root@localhost ~]# rpm -ivh zsh-5.0.2-34.el7_8.2.x86_64.rpm Preparing... ################################# [100%] Updating / installing... 1:zsh-5.0.2-34.el7_8.2 ################################# [100%]3、卸载 [root@localhost ~]# rpm -e zsh4、更新 [root@localhost ~]# rpm -Uvh zsh-5.0.2-34.el7_8.2.x86_64.rpm Preparing... ################################# [100%] Updating / installing... 1:zsh-5.0.2-34.el7_8.2 ################################# [100%]5、软件包名称 zsh-5.0.2-34.el7_8.2.x86_64.rpm 软件包名称：zsh 版本号：5.0.2 第多少次编译：34 适用的平台：el7_8（CentOS 7） 适用的系统位数：x86_64 扩展名：rpm6、查看软件包的配置文件 [root@localhost ~]# rpm -qc zsh7、查看是否安装某软件 [root@localhost ~]# rpm -q zsh8、查看当前系统安装了哪些软件 [root@localhost ~]# rpm -qa 9、查看软件的安装路径，查看安装了哪些东西 [root@localhost ~]# rpm -ql zsh上传与下载：yum install lrzsz -y 4.2、yum安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114基于rpm安装，自动解决依赖。1、安装 yum install [软件包的名称] 参数： -y : 免交互 --nogpgcheck : 忽略公钥认证2、卸载 yum remove [软件包名称] 参数： -y : 免交互3、更新 yum update [软件包名称] 参数： -y : 免交互 注意：如果跟具体的软件包名称，就会更新指定软件包；如果没有指定，则更新系统所有的需要更新的软件包。 4、yum安装的生命周期 1、执行yum install zsh -y 2、去 /etc/yum.repos.d/ 找以 .repo 结尾的文件 3、通过 .repo 文件中的链接，找到对应的软件仓库 4、在对应的软件仓库中下载指定的软件包 5、缓存至 /var/cache/yum/ 6、根据缓存，安装软件包 7、删除软件包（keepcache 是否保存缓存，0 代表不保存 ， 1 代表保存） 注：/etc/yum.conf 是yum的配置文件。5、yum私有仓库 1、本地版 1、下载必须的软件包 yum install yum-utils createrepo -y 2、创建软件仓库 mkdir -p /opt/repos 3、下载对应的软件 mkdir -p /opt/repos/Packages 把对应的软件包复制到 Packages 目录中 4、初始化软件仓库 createrepo /opt/repos 5、添加yum源 cd /etc/yum.repos.d/ mkdir backup mv *.repo backup/ [root@localhost ~]# yum-config-manager --add-repo=file:///opt/repos [root@localhost /etc/yum.repos.d]# cat opt_repos.repo [opt_repos] # 源的名称 name=added from: file:///opt/repos # 源的简介 baseurl=file:///opt/repos # 源的下载地址 enabled=1 # 是否启用：1启用 ， 0不启用 6、生成缓存 yum clean all yum makecache 7、测试 yum install zsh 2、远程版 参考本地版前6步 7、安装远程访问软件（Nginx） [root@localhost ~]# curl -o /etc/yum.repos.d/CentOS-Base.repo https://repo.huaweicloud.com/repository/conf/CentOS-7-reg.repo [root@localhost ~]# yum-config-manager --add-repo=https://repo.huaweicloud.com/epel/7/x86_64/ [root@localhost ~]# yum install nginx --nogpgcheck 8、修改nginx的配置文件 https://nginx.org/en/docs/http/ngx_http_autoindex_module.html [root@localhost ~]# vim /etc/nginx/nginx.conf # include /etc/nginx/conf.d/*.conf; root /opt/repos; autoindex on; # 测试更改是否成功 [root@localhost ~]# nginx -t # 启动nginx [root@localhost ~]# systemctl start nginx # 关闭selinux和firewalld [root@localhost ~]# systemctl disable --now firewalld [root@localhost ~]# setenforce 0 9、在测试机 [root@localhost yum.repos.d]# yum install yum-utils -y # 备份源 [root@localhost yum.repos.d]# mkdir backup [root@localhost yum.repos.d]# mv *.repo backup/ # 添加源 [root@localhost yum.repos.d]# yum-config-manager --add-repo=http://192.168.15.101/ # 刷新缓存 [root@localhost yum.repos.d]# yum clean all [root@localhost yum.repos.d]# yum makecache 10、测试 [root@localhost ~]# yum install zsh -y 5、系统安全优化123456781、selinux2、firewalld systemctl disable --now firewalld --now : 立即执行firewalld ---&gt; iptables ---&gt; 系统安全框架安全组vpn iptables 6、防止系统乱码优化123456789en_US.UTF-8 : 美式英文，utf-8zh_CN.UTF-8zh_HK.UTF-8临时优化export LANG=zh_CN.UTF-8 : 设置编码永久优化vim /etc/locale.conf","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"07、权限、系统用户信息","slug":"Linux基础--day07","date":"2018-06-13T06:04:07.000Z","updated":"2022-05-13T12:30:13.361Z","comments":true,"path":"2018/06/13/Linux基础--day07/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day07/","excerpt":"","text":"笔记1、晨考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465661、Linux系统中的文件“身份证号”是什么 index node 号码2、什么是硬链接，什么是软连接 硬链接是文件的入口，软连接是快捷方式。3、硬链接中保存的是什么，软连接中保存的又是什么？ 硬链接中保存的 index node 号码，软连接中保存的路径。4、删除文件的底层原理是什么？ 删除硬链接，当硬链接个数为0时，删除文件内容。5、Linux系统中常见的文件类型 d : 文件夹 f : 普通文件 b : 设备文件 c : 字符文件 s : 套接字文件 p : 管道文件 l ：链接文件6、创建用户的命令及其参数 useradd 参数： -g ： 指定用户组 -r : 创建系统用户 -M ：不创建家目录 -u : 指定用户ID -s : 指定解析器7、创建用户涉及到的文件有哪些 /etc/passwd : /etc/group /etc/shadow : 用户密码 /etc/gshadow /etc/skel 创建用户： 1、添加用户 vim /etc/passwd test08:x:2001:2001:自建用户:/home/test08:/bin/bash 2、添加组 vim /etc/group test08:x:2001: 3、添加用户密码密码 vim /etc/shadow test08:$6h4j93wta/:18974:0:99999:7::: 4、添加用户组密码 vim /etc/gshadow test08:!:: 5、家目录 mkdir test08 cp /etc/skel/.bash* /home/test08/ chown -R test08.test08 test08 chmod 700 test08/ 2、昨日问题1231、硬链接只针对文件，不针对文件夹。2、index node号码必须时同一个文件系统内唯一。3、在/etc/passwd添加了用户，代表用户创建了，但是不完全。 3、今天内容121、权限2、系统优化 4、权限12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788某一个用户针对某一个文件的权限。1、权限分为3个部分 可读(r) 可写(w) 可执行(x) 没有对应权限（-） 执行脚本 == 运行脚本2、权限位 权限位主要分为三个部分，分别是属主、属组以及其他人 rwx ： 属主 r-x ： 属组 r-x ： 其他人 可读 可写 可执行3、每一个权限拥有一个数字编号 可读(r) ： 4 可写(w) ： 2 可执行(x) ： 1 没有对应权限（-） ： 0 4、在添加权限的时候，可以将权限加起来 index 属主 : 可读可写可执行 属组 ：可读可写 其他人：没有任何权限 rwxrw---- 等价于 760 5、添加权限 chmod 格式： chmod [参数] [权限表达式] [操作对象] 参数： -R : 递归增加权限 6、权限的归属 属主：u 属组：g 其他人：o7、测试权限对于用户的意义 1、普通用户是严格遵守权限的 2、root用户是高于权限 3、权限需要重新登才生效（su和su - 都可以）8、测试权限对于目录的意义 1、文件可读，路径的最小权限是必须拥有可执行权限。 2、文件可写，路径的最小权限是必须拥有可执行权限。 3、文件可执行，路径的最小权限是必须拥有可读可执行权限。9、创建文件的默认权限，创建文件夹的默认权限是从哪里来的 在Linux中，常用的文件的权限是666, 目录的权限是777。 1、文件的权限是跟 umask 值相减，遇到奇数加一；遇到偶数则不变。 2、文件夹的权限只要跟 umask 值相减即可。 root ： umask 022 test09 : umask 002 默认文件权限：644 默认的文件夹权限：755 &amp;&amp; and || or umask 123 644 664 需求： 要求把1个月之前修改过的日志文件删除。案例: 案例1：将index文件添加属主 : 可读可写可执行、属组 ：可读可写、其他人：没有任何权限 chmod 760 index 案例2：将baidu下的所有文件设置rwxr--r-- chmod -R 744 baidu/ 案例3：将index这个文件的属组增加一个可执行权限。 chmod g+x index chmod g+x,o-r index 5、系统用户信息12whoami : 当前窗口登录的用户who ：当前用户登录系统的终端 作业121、搭建yum私有仓库 yum install zsh -y","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"06、文件类型概念说明、文件类型、用户与用户组","slug":"Linux基础--day06","date":"2018-06-13T06:04:06.000Z","updated":"2022-05-13T12:30:10.629Z","comments":true,"path":"2018/06/13/Linux基础--day06/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day06/","excerpt":"","text":"笔记1、晨考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511、解析映射文件 /etc/hosts2、磁盘挂载文件 /etc/fstab3、设置开机自启动脚本的步骤 1、修改/etc/rc.local 2、设置可执行权限 chmod +x /etc/rc.d/rc.local4、系统启动级别有哪些 0、关机 1、单用户 2、多用户无网络 3、完全多用户 4、待定 5、桌面模式 6、重启5、变量加载文件有哪些？ /etc/profile /etc/profile.d /etc/bashrc ~/.bashrc ~/.bash_profile6、添加环境变量的格式 export PARAMNAME=&quot;VALUE&quot;7、登录提示文件 /etc/motd /etc/issue8、修改系统root密码的方式 1、重启 2、在启动选择系统内核界面，按 e 键进入单用户模式 3、找到 linux16 开头行，删除 ro ， 并且在 ro 处添加 rw init=/sysroot/bin/sh 4、按 ctrl + x 进行系统重新引导 5、执行 chroot /sysroot 6、执行 passwd root 7、执行 touch /.autorelabel 8、执行 Ctrl + D 重启系统 2、昨日问题121、Linux严格区分大小写2、Linux区分中文和英文字符 3、今日内容1234561、文件类型概念说明2、文件软硬链接说明3、存储数据相关-inode和block4、文件用户和用户组5、文件相关权限6、文件时间信息 4、文件类型概念说明1234567891011121314151617181920212223242526272829301、文件详细信息详解 134319695 -rw-------. 1 root root 1.7K Dec 8 12:08 anaconda-ks.cfg 134319707 -rw-r--r-- 1 root root 12 Dec 13 11:48 index2、inode编号 Linux系统中文件的唯一编号，就相当于身份证号。3、硬链接和软连接 1、什么是硬链接 硬链接直接指向index node编号。 2、什么是软连接 相当于Windows中的快捷方式 主要用来指向对应文件的路径。 3、创建命令 ln ln命令是linux系统中一个非常重要命令，英文全称是“link”，即链接的意思，它的功能是为某一个文件在另 外一个位置建立一个同步的链接。一种是hard link，又称为硬链接；另一种是symbolic link，又称为符号链 接。 硬链接以文件副本的形式存在，但不占用实际空间 参数： 默认创建硬链接 -s ： 创建的就是软连接 4、删除文件的底层逻辑 1、删除的是硬链接 2、判断该文件硬链接数是否为0 3、如果为0，则在磁盘中将其删除 4、如果不为0，则只删除一个硬链接 5、文件类型12345678910111213141516171819202122232425普通文件 ：f(-)文件夹 : d链接文件 : l设备文件 : b c b : 磁盘文件 c : 字符文件套接字文件（socket） ：s yum install mariadb* -y管道文件 : p注意：不能以颜色判断文件类型。# 断点续传.conf 配置文件.py user_nameusernameuserNameUserNameINDEX = INDEX 6、用户和用户组12345678910111213141516171819202122232425262728293031323334353637383940414243444546用户：相当于账号 root test用户组：某些具有相同属性的账号的集合 root创建用户的命令： useradd 参数： -g : 指定用户组（用户必须存在） -r : 创建系统用户 -M ：不创建家目录 -u ：指定创建用户的ID的 系统用户：uid在 0 - 999 之间的用户，我们就看作系统用户 系统用户一般用在启动应用程序上，一般不需要登录系统。 普通用户：uid在 1000及以上的用户，我们就看作普通用户 一般用在登录上。创建用户组的命令： groupadd 参数： -g ： 指定用户组的ID切换用户 su - [用户名] su [用户名]查看用户的ID或组的IDid [用户名]查看用户详情的文件[root@localhost ~]# cat /etc/passwdtest01:x:1001:1001:用户简介:/home/test01:/bin/bash用户名 ： test01密码占位符 ：x1001 : userid1001 : 组id/home/test01 ： 家目录/bin/bash ：默认的解析器 bashshzsh 作业11、不使用 useradd 创建用户","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"05、解析映射文件、磁盘挂载文件、开机加载脚本、系统启动级别、变量加载文件、登陆提示文件、编译安装文件、系统日志目录、保存系统运行状态的目录","slug":"Linux基础--day05","date":"2018-06-13T06:04:05.000Z","updated":"2022-05-13T12:30:08.156Z","comments":true,"path":"2018/06/13/Linux基础--day05/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day05/","excerpt":"","text":"笔记1、晨考123456789101112131415161718192021222324252627282930311、存放系统配置文件的目录 /etc 2、存储系统实时运行状态的目录 /proc 3、存储系统硬件接口的目录 /dev 4、查看系统挂载情况的命令 df -h 5、系统网卡文件路径 /etc/sysconfig/network-script/ifcfg-[网卡名称] 6、重新加载网络有几种方式 systemctl restart network 7、修改系统DNS有几种方式，分别是什么 vim /etc/resolv.conf(临时) vim /etc/sysconfig/network-script/ifcfg-[网卡名称] 8、修改本机主机名有几种方式，区别是什么 hostname [主机名] : 临时修改 hostnamectl set-hostname [主机名] ：永久修改并且立即生效 vim /etc/hostname ：永久修改，重启生效 9、查看本机网络信息的命令 ip a ip address show ifconfig 2、昨日问题3、今日内容12341、系统中重要的文件系统2、使用单用户模式修改root密码 1、加盐 &amp;hPEqI%8WJnnmuKPXBn5129xqdzDUD^kta5@TCfA4iST*VRmBxVNM56AbQdh&amp;AL^ 4、解析映射文件12345/etc/hostsC:\\Windows\\System32\\drivers\\etc\\hosts本地的DNS192.168.15.101 www.baidu.com 5、磁盘挂载文件12/etc/fstab磁盘挂载文件。 6、开机加载脚本1234567/etc/rc.local1、编辑开机自启动脚本 vim /etc/rc.local 应该是个软连接2、设置开机自启动权限 chmod +x /etc/rc.d/rc.local3、重启系统 7、系统启动级别12345678910111213141516171819202122系统启动级别： 0、关机 1、单用户模式(无法通过xshell的方式使用) 2、多用户无网络模式 3、完全多用户模式 4、待定 5、桌面模式 6、重启设置系统级别： init [编号] 临时设置 systemctl set-default [系统启动级别]通过单用户模式修改密码 1、重启 2、在启动选择系统内核界面，按 e 键进入单用户模式 3、找到 linux16 开头行，删除 ro ， 并且在 ro 处添加 rw init=/sysroot/bin/sh 4、按 ctrl + x 进行系统重新引导 5、执行 chroot /sysroot 6、执行 passwd root 7、执行 touch /.autorelabel 8、执行 Ctrl + D 重启系统 8、变量加载文件1234567891011121314151617181920212223242526272829303132333435在Linux中添加环境变量怎么添加呢？文件 /etc/profile /etc/bashrc ~/.bash_profile ~/.bashrc文件夹 /etc/profile.d/增加环境变量有两种方式： 1、临时添加 2、永久添加增加环境变量的格式： export PYTHON_HOME=&#x27;D:/python&#x27; 查看本机的环境变量： echo $PYTHON_HOME ： 查看某一个环境变量 printenv : 查看所有的环境变量读取环境变量的几种情况，并且测试出使用文件的先后顺序 1、重启 /etc/profile.d --&gt; /etc/profile --&gt; /etc/bashrc --&gt; ~/.bashrc --&gt; ~/.bash_profile 2、切换用户 /etc/profile.d --&gt; /etc/bashrc --&gt; ~/.bashrc 知识储备： useradd [用户名] su [用户名] 3、重新登录用户 1、su - [用户名] /etc/profile.d --&gt; /etc/profile --&gt; /etc/bashrc --&gt; ~/.bashrc --&gt; ~/.bash_profile 2、ssh root@192.168.15.101 /etc/profile.d --&gt; /etc/profile --&gt; /etc/bashrc --&gt; ~/.bashrc --&gt; ~/.bash_profile 9、登录提示文件12345登录成功之后显示的信息。/etc/motd登录之前显示的信息。/etc/issue 10、编译安装目录12345# 安装第三方软件的目录/usr/local下载rpm安装包yum安装python：yum install python3 11、系统日志目录1/var 12、保存系统运行状态的目录12345678910111213141516保存CPU运行状态的：/proc/cpuinfo lscpu top cpu使用率保存内存的状态的：/proc/meminfo free 保存系统负载的：/proc/loadavg w 0.00 ： 1分钟内的CPU负载 0.01 ： 5分钟内的CPU负载 0.05 ：15分钟内的CPU负载 负载：当前系统的所有进程占用CPU的时间比 保存系统挂载信息：/proc/mounts mount umount","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"04、系统目录结构介绍、目录结构详述","slug":"Linux基础--day04","date":"2018-06-13T06:04:04.000Z","updated":"2022-05-13T12:30:05.743Z","comments":true,"path":"2018/06/13/Linux基础--day04/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day04/","excerpt":"","text":"笔记1、晨考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778791、移动文件的命令 mv2、删除文件的命令及其参数 rm 参数： -r : 递归删除 -f : 不提示删除 -i : 提示删除3、复制文件的命令及其参数 cp 参数： -r : 递归复制 -a : 保持原来属性并且递归复制4、编辑文件的命令 vi/vim echo cat + tee5、vim的三种模式 命令模式 末行模式 编辑模式6、vim的快捷键 ctrl + r : 撤回回撤 gg : 首行 G ：末行 0 ：行首 $ : 行尾 yy : 复制一行 nyy: 向下复制n行 dd : 删除一行 ndd: 向下删除n行 P : 在光标上一行粘贴 p : 在光标下一行粘贴 u : 回撤 aio: 进入编辑模式 :n : 跳转到第n行 :set nu : 显示行号 :set nonu : 取消行号 :set ic ：忽略大小写7、vim中的搜索 1、进入命令模式 2、输入/ 3、输入搜索内容 4、回车8、vim删除多行有几种方式 ndd 可视化编辑9、vim中在前10行之前加上# 可视化编辑 1、进入末行模式 2、输入要操作的指定行数 1,n 指定的是操作1到n行，%代表的是文本的最后一行的行号 s/被替换的内容/替换的新内容/g :1,10 s/\\(.*\\)/# \\1/g 10、正则表达式 * ：匹配任意字符的任意个数，除换行符(\\n)之外 . : 匹配某一个字符 ? ：匹配零次或一次前导字符 + : 匹配一次或多次前导字符 ^ : 匹配以某个字符开头 $ : 以某个字符结尾 \\ : 取消转义 (): 分组 []: 或者（里面包含的任意一个字符） | ：或者（两边的字符整体） &#123;&#125;：指定匹配个数 &#123;n&#125; : 匹配n次 &#123;n,m&#125; ：匹配n到m次 &#123;n,&#125; ：匹配至少n &#123;,m&#125; ：匹配最多n次 2、今日内容121、系统目录结构介绍2、目录结构知识详述 3、系统目录结构介绍12345678910111213141516171819202122232425261、目录结构特点 linux系统中的目录一切从根开始。 Linux系统中的目录结构拥有层次。 Linux系统中的目录需要挂载使用。2、目录挂载初识 挂载的命令：mount mount [磁盘路径] [挂载的路径] 查看本机挂载的命令 [root@localhost dev]# df -h 卸载挂载的磁盘 [root@localhost dev]# umount /mnt/3、目录结构发展 第一块磁盘：/ 第二块磁盘：存储数据（数据盘） 4、关闭selinux 临时关闭 [root@localhost ~]# setenforce 0 永久关闭 [root@localhost ~]# vim /etc/selinux/config SELINUX=disabled 4、目录结构知识详述1234567891011121314151617181920212223242526272829303132331、网卡配置文件 /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth1 /etc/sysconfig/network-scripts/ifcfg-ens32 /etc/sysconfig/network-scripts/ifcfg-ens332、重载网卡信息 systemctl restart network ifdown [网卡名称] &amp;&amp; ifup [网卡名称] 关闭网络管理器（因为已经有了network） systemctl stop NetworkManager systemctl disable NetworkManager 或 systemctl disable --now NetworkManager 判断SSH服务是否开启 [root@localhost ~]# systemctl status sshd 解析配置文件 /etc/resolv.conf ： 临时dns配置文件 dns将域名/网址解析为ip返回 114.114.114.114 中国电信 223.5.5.5/223.6.6.6 中国阿里云 8.8.8.8 谷歌 主机名称文件 临时修改 hostname baidu 永久修改 [root@baidu ~]# vim /etc/hostname # 需要重启生效 [root@baidu ~]# hostnamectl set-hostname oldboy # 立即生效","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"03、复制文件、移动文件、删除文件、系统别名、vi/vim编辑器","slug":"Linux基础--day03","date":"2018-06-13T06:04:03.000Z","updated":"2022-05-13T12:30:03.547Z","comments":true,"path":"2018/06/13/Linux基础--day03/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day03/","excerpt":"","text":"笔记1、考试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364651、判断网络是否通畅的命令 ping2、定义系统提示组成的变量 PS13、Linux中目录从什么开始 根（/）4、系统中目录路径类型有哪些，解释一下 绝对路径：以根目录作为参照物。 相对路径：以当前目录作为参照物。5、关机和重启系统的命令有哪些，请说明不同点 shutdown : 正常的关机 halt ：禁用CPU poweroff ：切断电源 init ：设置系统启动模式 0 ： 关机 1 ： 单用户 2 ： 多用户无网络模式 3 ： 多用户 4 ： 待定 5 ： 桌面 6 ： 重启 reboot ：重启6、查看系统帮助信息的命令 man -h --help help 7、系统命令行快捷键有哪些，尽可能多的写 8、Linux系统中特殊的路径有哪些 . : 当前路径 .. : 上一级目录 - ： 返回上一次路径 ~ ： 家目录9、打印当前所在的目录路径 pwd10、创建文件的命令以及创建文件夹的命令及其常用参数 touch mkdir -p : 递归创建 -v : 打印创建过程11、两种重定向方式是那些，请解释异同 覆盖重定向（&gt;） : 先清空，然后再写入 追加重定向（&gt;&gt;） : 在文件末尾添加 2、今日问题123451、克隆之后，ip冲突 net.ifnames=0 biosdevname=02、xshell连接不上 1、虚拟机未开机 3、今日内容123451、复制文件2、移动文件3、删除文件4、vi/vim编辑器5、linux目录结构 4、复制文件1234567891011121314151617181920212223242526272829copy的缩写cp。格式： cp [参数] [被复制文件的路径] [复制到的新路径]参数： -r : 递归复制。 -a : 保证某些属性不变。 案例： 案例1：将/root目录下anaconda-ks.cfg复制到/tmp目录 [root@localhost ~]# cp /root/anaconda-ks.cfg /tmp 案例2：将/root目录下的test文件夹及其内部的文件复制到/tmp中 [root@localhost ~]# cp -r /root/test /tmp 补充：在linux中，文件夹是不可以直接复制。 案例3：将/etc/hosts和/etc/resolv.conf 复制到/tmp目录中 [root@localhost ~]# cp /etc/hosts /etc/resolv.conf /tmp注意：在linux没有提示就是做好的结果补充：Esc + . : 上一条命令的最后一个元素 ls -l 等价于 ll知识储备： linux中的链接相当于快捷方式。 stat : 查看文件详细属性。 4、移动文件1234567891011移动文件相当于剪切。格式： mv [移动文件的原路径] [移动文件的新路径] 案例： 案例1：将/root目录下的1.txt移动到/opt目录中 [root@localhost ~]# mv /root/1.txt /opt # 移动文件夹 [root@localhost ~]# mv test/ /mnt/ 5、删除文件12345678910111213141516171819202122232425262728293031删除文件有两种方式： 1、物理删除：直接删除文件。 2、逻辑删除：将文件隐藏，没有直接删除。rm 是一个物理删除的命令格式： rm [参数] [需要删除文件的路径]参数： -f : 不提示直接删除 -r : 递归删除目录及其内容 -i : 每次移除前提示 案例： 案例1：将/root目录下的1.txt删除 [root@localhost ~]# rm 1.txt [root@localhost ~]# rm -f 1.txt 案例2：删除/root目录下的test文件夹及其内部所有的文件 [root@localhost ~]# rm -r /root/test/ [root@localhost ~]# rm -rf /root/test/补充： 在linux系统中，不能够直接删除文件夹。 linux系统中禁止使用：rm -rf /*解决rm命令误操作 将rm命令改一个名称。 知识储备： 查看命令存放路径：which 6、系统别名12345678910alias格式： alias xxx=&#x27;命令&#x27; alias ： 查看系统别名 alias rm=&#x27;xxx&#x27; ： 设置系统别名不使用别名，就在命令之前增加\\ [root@localhost ~]# \\rm 1.txt 7、vi&#x2F;vim编辑器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108vim是vi的升级版编辑器。1、安装vim yum install vim -y 2、打开编辑文件 [root@localhost ~]# vim 1.txt 3、vi编辑器中有三种模式 命令模式 末行模式 编辑模式4、进入编辑模式 i : 在光标之前输入 o ：在光标处新创建一行 a ：在光标之后输入5、保存并退出 1、进入末行模式 2、操作 w : 保存 q : 退出 ! : 强制（编写的内容全部放弃）6、解决vim编辑异常 1、删除.1.txt.swp 2、继续编辑（-r） [root@localhost ~]# vim -r 1.txt 3、放弃编辑（-n） [root@localhost ~]# vim -n 1.txt7、光标快速移动快捷方式 ①. 快速切换光标到底行 G ②. 快速切换光标到首行 gg ③. 快速跳转到行首 0 ④. 快速跳转到行尾 $ ⑤. 快速跳转到指定行 1、进入末行模式 2、输入跳转的行数 3、回车 ⑥. 快速复制文本内容信息 yy nyy : 向下复制n行 ⑦. 快速粘贴文本内容 p : 在光标的下一行粘贴 P ：在光标的上一行粘贴 ⑧. 删除文本内容 dd : 删除光标所在行 ndd : 向下删除n行 ⑨. 回撤 u ⑩. 撤回回撤 ctrl + r ⑪. 显示行号 1、进入末行模式 2、输入set nu 3、回车 ⑫. 取消行号 1、进入末行模式 2、输入set nonu 3、回车 ⑬. 搜索内容 1、进入命令模式 2、输入/ 3、输入搜索的内容 4、回车 n : 下一个 N ：上一个 :set ic : 忽略大小写 ⑭. 可视化编辑 1、ctrl + v 方向键控制操控地方 2、编辑：Shift + i 3、按 Esc键退出即可知识储备 实时监控文件内容变化： tail -f [要监控的文件] 演示vim编辑异常 1、查看vim进程 [root@localhost ~]# ps -ef | grep vim 2、杀死vim进程 [root@localhost ~]# kill -9 pid 批量复制 [root@localhost ~]# while true;do echo &quot;Hello World&quot; &gt;&gt; 1.txt; done","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"02、虚拟机快照、系统介绍、系统命令语法格式、系统目录结构、系统路径类型、系统运行命令、查看系统命令帮助、系统快捷命令方式、常用系统命令","slug":"Linux基础--day02","date":"2018-06-13T06:04:02.000Z","updated":"2022-05-13T12:30:00.821Z","comments":true,"path":"2018/06/13/Linux基础--day02/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day02/","excerpt":"","text":"笔记1、昨日问题12345678910111、mac系统虚拟机的问题2、虚拟机连不上网 1、xshell连接不上 1、虚拟网络编辑器和vmnat8网卡设置错误 2、ping不通百度 1、DNS IP编写错误 2、网卡的网关写错了 3、系统不完全：vcruntime140_1.dll 4、网卡和虚拟机之间网络转发异常3、系统镜像文件 推荐使用DVD版的系统镜像文件 2、今日内容12345671、虚拟机快照2、基础命令 1、系统介绍 2、系统运行命令 3、系统帮助命令 4、系统快捷方式 5、实践部分 3、虚拟机快照1234567891011121314151617181、拍摄快照 关机 ---&gt; 拍摄快照2、克隆主机 管理 ---&gt; 克隆3、改ip 最后一位3 - 254 # 查看网卡名称，或者查看本机IP [root@localhost ~]# ip a # 修改网卡 [root@localhost ~]# sed -i &#x27;s#.100#.101#g&#x27; /etc/sysconfig/network-scripts/ifcfg-ens3[23] [root@localhost ~]# sed -i &#x27;s#.100#.101#g&#x27; /etc/sysconfig/network-scripts/ifcfg-eth[01] # 重启系统网络 [root@localhost ~]# systemctl restart network 4、系统介绍12345678910111213141516171819202122231、ping 格式： ping [网址]2、主机登录用户信息 [root@localhost ~]# root : 登录当前系统的用户名 @ : 分隔符，没有特殊含义 localhost : 当前系统的主机名 ~ ： 当前所在的目录（~ 代表的是当前的家目录， /root） # : 没有实际含义 3、自定义系统登录用户信息 PS1 环境变量 [root@localhost ~]# echo $PS1 [\\u@\\h \\W]\\$ [root@localhost ~]# PS1=&#x27;[\\u@\\h --- \\W]\\$&#x27; 知识储备： print(&#x27;Hello World&#x27;) echo &quot;Hello World!&quot; 5、系统命令语法格式12通常系统命令语法格式： 命令 [参数] [选项] [路径] 6、系统目录结构1234Linux中一切从根(/)开始。知识储备： cd : 切换目录 7、系统路径的类型12绝对路径：参照物是根（/）路径相对路径：参照物是当前路径 8、系统运行命令12345678910111213141516171819202122231、关机 shutdown ： 关机或重启 参数：-h : 指定关机的延时时间 -c : 取消关机 halt ： 禁用CPU资源 poweroff ： 关闭电源 init ：设置系统启动模式 0 ： 关机 1 ： 单用户模式 2 ： 多用户无网络模式 3 ： 多用户模式 4 ： 待定 5 ： 桌面模式 6 ： 重启 reboot 2、重启 reboot init shutdown 参数： -r : 指定重启的延时时间 9、查看系统命令帮助123456789101112格式： man [需要查看帮助的命令] 命令解释说明信息：NAME 命令语法说明信息：SYNOPSIS 命令描述详细说明：DESCRIPTION 命令参数详细说明：OPTIONS q : 退出 /[搜索内容] ： 搜索内容 推荐网址：https://www.linuxcool.com/ 10、系统快捷方式12345678910111、历史命令信息：上下键2、清屏命令：ctrl + l | clear3、中断取消命令执行过程 ： ctrl + c4、快速移动光标到行首尾：ctrl + a/e5、将光标到行首信息剪切：ctrl + u6、将剪切的内容进行粘贴：ctrl + y7、将光标到行尾信息剪切：ctrl + k8、锁定系统窗口信息状态：ctrl + s9、解锁系统窗口信息状态：ctrl + q10、命令行中快速移动光标：ctrl + 方向键11、系统命令信息补全功能：tab 11、常用系统命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601、目录路径相关命令 1、显示当前路径信息 pwd 2、切换目录路径信息 cd 特殊路径： 1、- ： 上一次访问的路径 2、. : 代表当前路径 3、.. : 上一层路径 4、~ ： 家目录 绝对路径和相对路径 3、进行目录创建操作 mkdir 参数： -p : 自动创建上级目录 -v : 显示创建文件夹的过程 案例：要求在上一层目录中的data目录下的test目录中创建一个v1目录 [root@localhost ~]# mkdir -p ../data/test/v1 注：mkdir创建文件夹时，该文件夹的上一层目录必须存在 2、文件目录相关命令 1、创建文件信息命令 touch [root@localhost ~]# touch 1.txt 2、查看数据信息命令 ls 查看指定目录下的文件信息，默认查看当前目录下文件信息。 参数： -l : 显示文件的详细信息 -a : 显示隐藏文件夹（以.开头的文件或文件夹就称之为隐藏文件夹） -h : 格式化文件大小（必须跟-l参数配合使用） [root@localhost ~]# ls -l total 4 -rw-r--r--. 1 root root 0 Dec 9 12:15 1.txt -rw-r--r--. ： 文件的权限 1 ：文件硬链接数 root ：所属用户 root ：所属组 0 ：大小（字节） Dec 9 12:15 : 创建的时间 1.txt ：文件名称 1B =&gt; 8字节 1024字节 = 1kB 1024kb = 1MB 3、输出打印字符信息 echo 覆盖重定向（&gt;）：将文件中所有内容删除之后再写入 追加重定向（&gt;&gt;）：在文件的末尾写入信息 4、查看文件数据信息 cat [需要查看文件的路径] 预习：https://blog.sholdboyedu.com/?cat=37","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"01、虚拟机安装、网络配置、Linux操作系统安装、xshell安装","slug":"Linux基础--day01","date":"2018-06-13T06:04:01.000Z","updated":"2022-05-13T12:29:53.251Z","comments":true,"path":"2018/06/13/Linux基础--day01/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/13/Linux%E5%9F%BA%E7%A1%80--day01/","excerpt":"","text":"虚拟机安装123双击虚拟机软件 ---&gt; 下一步 直至安装完毕vmware16 密钥：ZF3R0-FHED2-M80TY-8QYGC-NPKYF 配置网络 Linux操作系统安装1234567891011121314151、下载系统安装包软件 下载网址：https://developer.aliyun.com/mirror/ 下载链接：https://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso2、安装操作系统 1、修改好网络 1、配置windows网络 2、配置虚拟机网络 2、安装Linux操作系统 1、创建虚拟机 2、安装操作系统 修改内核参数：net.ifnames=0 biosdevname=03、安装远程连接工具（xshell） 下一步直至安装完毕 xshell安装","categories":[],"tags":[{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"08、jQuery（阻止后续事件执行、事件冒泡、文档加载、事件委托、动画效果）、基于jQuery的前端框架bootstrap（布局容器、栅格系统、图标）","slug":"day08","date":"2018-06-02T06:04:08.000Z","updated":"2022-05-13T13:53:43.054Z","comments":true,"path":"2018/06/02/day08/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/02/day08/","excerpt":"","text":"阻止后续事件执行1234567$(&#x27;#d1&#x27;).click(function (e) &#123; alert(123) // 1.阻止该标签后续事件的执行 方式1 推荐 // return false // 2.阻止该标签后续事件的执行 方式2 了解 // e.preventDefault() &#125;) 事件冒泡1234567891011121314151617181920# 子标签的事件完成后会向父标签提交信号，父标签如有相同类型事件则也会执行，然后再向父标签的父标签提交信号。# 下面有三个事件，如果是div套p套span标签，那么当点击span时，会依次触发span、p、div标签绑定的点击事件# 依次会弹出span、p、div$(&#x27;div&#x27;).click(function (e) &#123; alert(&#x27;div&#x27;)&#125;)$(&#x27;p&#x27;).click(function (e) &#123; alert(&#x27;p&#x27;) // 阻止事件冒泡的方式1 // return false // 阻止事件冒泡的方式2 // e.stopPropagation()&#125;)$(&#x27;span&#x27;).click(function (e) &#123; alert(&#x27;span&#x27;)&#125;) 文档加载123456// 原生js文档加载方式 window.onload = function () &#123;&#125;// jQuery文档加载方式01 $(document).ready(function () &#123;&#125;)// jQuery文档加载方式02 $(function()&#123;&#125;) 事件委托123456789101112131415// 将body内部所有的点击事件委托给button按钮执行$(&#x27;body&#x27;).on(&#x27;click&#x27;,&#x27;button&#x27;,function () &#123; // 创建一个button标签 var btnEle = document.createElement(&#x27;button&#x27;) // 设置内部文本 btnEle.innerText = &#x27;点我&#x27; // 将button标签添加到body内部 $(&#x27;body&#x27;).append(btnEle)&#125;)/*将事件复制有两个方式： 1、clone 后面参数加true 2、事件委托*/ 动画效果12345678$(&quot;#d1&quot;).on(&quot;click&quot;, function () &#123; var newI = document.createElement(&quot;i&quot;); newI.innerText = &quot;+1&quot;; $(this).append(newI); $(this).children(&quot;i&quot;).animate(&#123; opacity: 0 &#125;, 1000) // 创建的i标签（+1效果）1秒后消失（变透明）&#125;) 前端框架bootstrap12345678910111213141516171819Bootstrap框架 2.X 3.X 4.X # 推荐使用3.X版本使用框架调整页面样式一般都是操作标签的class属性即可bootstrap需要依赖于jQuery才能正常执行(动态效果)引入方式 本地引入(最完整的) 1.引入jQuery 2.引入bootstrap的css文件 3.引入bootstrap的js文件 CDN引入 1.引入jQuery CDN 2.引入bootstrap css的 CDN 3.引入bootstrap js的 CDN注意：第一次引入bootstrap框架最好从本地引入，防止写代码没有提示 让pycharm记住bootstrap的关键字 布局容器12container 左右留白container-fluid 左右不留白 栅格系统12345row 行 # 一个row就是一行 一行是固定的12份col-md-1 占1份 md: middlecol-sm-n 占n份 sm: smallcol-xs-n 占n份 xs: extra small(特小)col-lg-n 占n份 lg: large 图标12345bootstrap自带的 通过span标签的class属性值来选择不同图标fontawesome 专门提供图标的库 # 完美兼容bootstrap框架 通过i标签的class属性值选择不同图标","categories":[],"tags":[{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"07、jQuery（简介、基本选择器、基本筛选器、属性选择器、表单选择器、筛选器方法、节点操作、事件）","slug":"day07","date":"2018-06-02T06:04:07.000Z","updated":"2022-05-13T13:53:14.391Z","comments":true,"path":"2018/06/02/day07/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/02/day07/","excerpt":"","text":"jQuery简介1234567891011121314151617181920212223宗旨:Write less, do more.内部封装了js代码 是编程更加简单并且兼容所有的主流浏览器版本:1.x 2.x 3.x # 可以使用3.x最新版是第三方的类库:使用jQuery需要提前导入 # 实际中很容易遗忘了导入 jQuery下载 压缩之后的版本将很多变量名全部使用英文字母代替了导入方式 本地导入 缺点在于需要提前下载文件 优点在于不会受到网络的影响 CDN导入 # CDN:内容分发网络 网站:bootcdn jquery最好使用3.4.1版本 基本使用 很多时候jQuery都是一行代码搞定所有 &quot;&quot;&quot; 使用jQuery需要有关键字声明 jQuery 或者 $ (推荐) &quot;&quot;&quot; 基本选择器1234567891011121314151617/*如何通过变量名来区分指代的是js对象还是jQuery对象 eg: 原生的js对象 var pEle = ... jQuery的对象 var $pEle = ...*/$(&#x27;#d1&#x27;) // js：document.getElementById(&#x27;d1&#x27;)$(&#x27;.c1&#x27;) // js：document.getElementsByClassName(&#x27;d1&#x27;)$(&#x27;p&#x27;) // js：document.getElementsByTagName(&#x27;p&#x27;)$(&#x27;div.c1&#x27;) // 查找class含有c1的div标签$(&quot;#d1, .c1, p&quot;) // 并列查找$(&quot;x y&quot;) // x的所有后代y（子子孙孙）$(&quot;x &gt; y&quot;) // x的所有儿子y（儿子）$(&quot;x + y&quot;) // 找到所有紧挨在x后面的y$(&quot;x ~ y&quot;) // x之后所有的兄弟y 基本筛选器123456789:first // 第一个:last // 最后一个:eq(index)// 索引等于index的那个元素:even // 匹配所有索引值为偶数的元素，从 0 开始计数:odd // 匹配所有索引值为奇数的元素，从 0 开始计数:gt(index)// 匹配所有大于给定索引值的元素:lt(index)// 匹配所有小于给定索引值的元素:not(元素选择器)// 移除所有满足not条件的标签:has(元素选择器)// 选取所有包含一个或多个标签在其内的标签(指的是从后代元素找) 属性选择器123$(&#x27;[name]&#x27;)$(&#x27;[name=&quot;jason&quot;]&#x27;)$(&#x27;input[name=&quot;jason&quot;]&#x27;) 表单筛选器12$(&#x27;:text&#x27;) // 查找属性值是text的form表单内的标签$(&#x27;:checked&#x27;) // 会连同option默认的selected一起找到 筛选器方法12345678910111213141516171819202122232425/*使用原生js代码批量查找到标签之后 结果是一个数组需要索引取值之后才可以调用标签的一些方法使用jQuery代码批量查找到标签之后 结果是一个jQuery对象(像数组)不需要索引取值 就可以直接调用封装的方法两者对象的转换 js对象转jQuery对象 $(js对象) jQuery对象转jd对象 jQuery对象索引取值*/.next().nextAll().nextUntil().prev().prevAll().prevUntil().parent().parents().parentsUntil().children().siblings().find() 节点操作1234567891011121314151617181920212223242526272829303132333435363738394041424344# 样式类操作 addClass() # classList.add() removeClass() # classList.remove() hasClass() # classList.contains() toggleClass() # classList.toggle() # 样式操作 css(&#x27;属性名&#x27;,&#x27;属性值&#x27;) $(window).scroll(function () &#123; if ($(window).scrollTop() &gt; 100) &#123; $(&quot;#b2&quot;).removeClass(&quot;hide&quot;); &#125;else &#123; $(&quot;#b2&quot;).addClass(&quot;hide&quot;); &#125; &#125;);# 文本操作 text() # innerText html() # innerHTML val() # value jQuery对象先转js对象之后.files &#x27;&#x27;&#x27; 括号内 不写参数：获取值 写参数： 设置值 &#x27;&#x27;&#x27; # 属性操作 attr() # setAttribute() &#x27;&#x27;&#x27;适用于属性为静态的情况(不经常修改动态变化的)&#x27;&#x27;&#x27; prop() $($(&#x27;:checkbox&#x27;)[1]).prop(&#x27;checked&#x27;,true) &quot;&quot;&quot;适用于动态变化的情况 尤其是选择类标签&quot;&quot;&quot; # 文档处理 append() # 内部的尾部追加元素 prepend() # 内部的头部追加元素 after() # 同级别下面添加元素 before() # 同级别上面添加元素 remove() # 移除当前元素 empty() # 清空当前元素内部所有的数据 clone() # 克隆标签 括号内可以加true来克隆事件 事件12345678910111213141516171819绑定事件的两种方式 方式1 jQuery对象.事件名(function()&#123;&#125;) $(&#x27;#d1&#x27;).click(function()&#123;alert(123)&#125;) 方式2 jQuery对象.on(&#x27;事件名&#x27;,function()&#123;&#125;) $(&#x27;#d1&#x27;).on(&#x27;click&#x27;,function()&#123;alert(123)&#125;)&quot;&quot;&quot;有时候绑定事件可能没有效果 这个时候可以考虑切换绑定方式 方式1不行就方式2 方式2不行就方式1&quot;&quot;&quot;click(function()&#123;...&#125;) # 点击hover(function()&#123;...&#125;) # 悬浮blur(function()&#123;...&#125;) # 失去焦点focus(function()&#123;...&#125;) # 焦点change(function()&#123;...&#125;) # 文本域变化keyup(function()&#123;...&#125;) # 按钮被松开触发","categories":[],"tags":[{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"06、JavaScript之DOM操作（查找标签、节点操作、获取值操作、class操作、样式操作、事件、内置参数this、事件练习）","slug":"day06","date":"2018-06-02T06:04:06.000Z","updated":"2022-05-13T13:52:43.901Z","comments":true,"path":"2018/06/02/day06/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/02/day06/","excerpt":"","text":"DOM操作之查找标签12345678910111213141516171819前缀关键字&gt;&gt;&gt;:document # 基本查找(核心)document.getElementById 根据ID获取一个标签document.getElementsByClassName 根据class属性获取document.getElementsByTagName 根据标签名获取标签合集&quot;&quot;&quot;如果我们的js代码需要页面上某个标签加载完毕那么该js代码应该写在body内部最下方或者引入外部js文件&quot;&quot;&quot;# 间接查找(重要)parentElement 父节点标签元素children 所有子标签firstElementChild 第一个子标签元素lastElementChild 最后一个子标签元素nextElementSibling 下一个兄弟标签元素previousElementSibling 上一个兄弟标签元素 节点操作12345678910111213141516var aEle = document.createElement(&#x27;a&#x27;); # 创建标签aEle.setAttribute(&#x27;href&#x27;,&#x27;https://www.mmzztt.com/&#x27;) # 设置属性aEle.innerText = &#x27;好不好看?&#x27; # 设置内容文本document.getElementsByTagName(&#x27;p&#x27;)[0].appendChild(aEle) # 动态添加&quot;&quot;&quot;一定要明确当前手上是什么对象&quot;&quot;&quot;imgEle.getAttribute(&#x27;title&#x27;) # 获取标签属性innerText 不加赋值符号是获取内部文本 加了赋值符号是设置内置文本 # 不可以识别HTML标签innerHTML 不加赋值符号是获取内部标签+文本 加了赋值符号是设置内置标签+文本 # 可以识别HTML标签 获取值操作123456# 普通的文本数据获取 标签对象.value# 特殊的文件数据获取 标签对象.value &#x27;&#x27;&#x27;仅仅获取一个文件地址而已&#x27;&#x27;&#x27; 标签对象.files[0] &#x27;&#x27;&#x27;获取单个文件数据&#x27;&#x27;&#x27; 标签对象.files &#x27;&#x27;&#x27;获取所有文件数据&#x27;&#x27;&#x27; class操作12345classList 查看所有的类classList.remove(cls) 删除指定类classList.add(cls) 添加类classList.contains(cls) 存在返回true，否则返回falseclassList.toggle(cls) 存在就删除，否则添加 样式操作1标签对象.style.属性名 = 属性值 事件12345678910111213141516171819# 就是给HTML元素添加自定义的功能绑定事件的方式1 &lt;button onclick=&quot;func()&quot;&gt;点我&lt;/button&gt; &lt;script&gt; function func() &#123; alert(123) &#125; &lt;/script&gt; 绑定事件的方式2 &lt;button id=&quot;d1&quot;&gt;选我&lt;/button&gt; &lt;script&gt; // 1.先查找标签 var btnEle = document.getElementById(&#x27;d1&#x27;) // 2.绑定事件 btnEle.onclick = function () &#123; alert(456) &#125; &lt;/script&gt; 内置参数this123456# this指代的就是当前被操作对象本身在事件的函数体代码内部使用 btnEle.onclick = function () &#123; alert(456) console.log(this) &#125; 事件练习12345678onclick单击事件onfocus聚焦事件onblur失去焦点事件onchange文本域变化事件onload等待...加载完毕后执行的事件# 定时器# 数据校验# 省市联动 补充1# 如果某个标签已经有事件了 那么绑定会冲突","categories":[],"tags":[{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"05、JavaScript（变量与常量、5种借本数据类型、运算符、流程控制、三元运算符、函数、自定义函数、内置对象、BOM与DOM操作简介、BOM操作）","slug":"day05","date":"2018-06-02T06:04:05.000Z","updated":"2022-05-13T13:52:14.419Z","comments":true,"path":"2018/06/02/day05/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/02/day05/","excerpt":"","text":"变量与常量1234567891011121314151617181920在JS中声明变量需要使用关键字 老版本 var(全部都是全局变量) 新版本 let(可以声明局部变量) # 推荐使用let(其实问题不大)在JS中声明常量也需要使用关键字 const # 声明一个真正意义上的常量 如何创建变量 var name = &#x27;jason&#x27; let name = &#x27;jason01&#x27;如何创建常量 const pi = 3.14 &quot;&quot;&quot;可以编写js代码的地方 1.pycharm提供的js文件 2.直接使用浏览器提供的编程环境&quot;&quot;&quot;ps:pycharm在使用上述关键字的时候如果出现了报错说明js版本没有选择6需要我们自定义设置 settings&gt;&gt;&gt;l f&gt;&gt;&gt;js 5种基本数据类型12345678python基本数据类型 int、float、str、list、dict、bool、tuple、setjs基本数据类型 number、string、boolean、undefined、object() 查看数据类型 python中使用type() js中使用typeof 1、number类型12345# 数值类型:包含了整型与浮点型parseInt、parseFloat NaN:Not A Number&quot;&quot;&quot;NaN属于数值类型 表示的意思是 不是一个数字&quot;&quot;&quot; 2、string类型12345678910111213141516# 定义字符类型的方式 1.单引号 2.双引号 3.反引号 var s1 = ` jason老师 tony老师 kevin老师 ` # 在js中字符串的拼接推荐使用+号 # 格式化输出(模板字符串的功能) var name1 = &#x27;jason&#x27; var age = 18 `my name is $&#123;name1&#125; my age is $&#123;age&#125; ` 3、boolean类型1234在python中布尔值类型首字母大写 True False在js中布尔值类型全部小写 true false 4、null与undefined类型123null表示的意思是空undefined表示的意识是未定义 eg:null意思是厕纸用完了 undefined意思是厕纸都没装 5、对象之数组类型123# 对应到python中就是列表listl2.splice(2,1) # 第一个参数是起始位置 第二个参数是删除元素的个数 运算符1234567891.比较运算符 == 弱等于 # 会自动转换数据类型至相同状态 === 强等于 # 不会自动转换数据类型2.逻辑运算符 python中 and or not js中 &amp;&amp; || ! 流程控制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x27;&#x27;&#x27;if判断&#x27;&#x27;&#x27;python中 if 条件: 条件成立之后执行的代码 else: 条件不成立执行的代码js中 if(条件)&#123; 条件成立之后执行的代码 &#125;else&#123; 条件不成立执行的代码 &#125; if(条件1)&#123; 条件1成立之后执行的代码 &#125;else if(条件2)&#123; 条件2成立之后执行的代码 &#125;else&#123; 条件都不成立执行的代码 &#125;&#x27;&#x27;&#x27;switch&#x27;&#x27;&#x27; var day = new Date().getDay(); switch (day) &#123; case 0: console.log(&quot;Sunday&quot;); break; case 1: console.log(&quot;Monday&quot;); break; default: console.log(&quot;...&quot;) &#125;&quot;&quot;&quot;for循环&quot;&quot;&quot; for(起始值;循环条件;每次循环后执行的操作)&#123; for循环体代码 &#125; for (var i=0;i&lt;10;i++) &#123; console.log(i); &#125; # 练习:如何使用for循环取出数组内的每个元素 var l1 = [111,222,333,444,555,666] for(let i=0;i&lt;l1.length;i++)&#123; console.log(l1[i]) &#125;&quot;&quot;&quot;while循环&quot;&quot;&quot; while(循环条件)&#123; 循环体代码 &#125; 三元运算符1234在python中 res = &#x27;吃饭&#x27; if 18 &gt; 10 else &#x27;喝水&#x27;在js中 res = 18 &gt; 10 ? &#x27;吃饭&#x27;:&#x27;喝水&#x27; 函数123456789101112131415161718192021在python中 def 函数名(参数1,参数2,...): &#x27;&#x27;&#x27;函数注释&#x27;&#x27;&#x27; 函数体代码 return 返回值在js中 function 函数名(参数1,参数2,...)&#123; // 函数注释 函数体代码 return 返回值 &#125;&quot;&quot;&quot;arguments参数 可以获取传入的所有数据 也支持return和匿名函数&quot;&quot;&quot;var f = v =&gt; v;// 等同于var f = function(v)&#123; return v;&#125; 自定义对象12345678910111213141516# 相当于python中的字典类型 方式1: var d = &#123;&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:18&#125; 方式2: var d = Object(&#123;&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:18&#125;)class MyDict(dict): def __getattr__(self, item): return self.get(item) def __setattr__(self, key, value): self[key] = valueres = MyDict(name=&#x27;jason&#x27;,age=18)print(res.name)print(res.age)res.xxx = 123print(res.xxx)print(res) 内置对象1234567891011121314151617181920212223242526272829303132333435363738394041424344# 如果需要使用内置对象 需要关键字 new在python中 import date date()在js中 new date() ##########################################################序列化 python中 import json json.dumps() # 序列化 json.loads() # 反序列化 js中 JSON.stringify() # 序列化 JSON.parse() # 反序列化&quot;&quot;&quot;如果当前js中有一个布尔值true需要基于网络发送给python程序并且让python转换成布尔值 如何操作 1.在js中使用JSON.stringify()序列化成json格式字符串 2.基于网络发送给python程序(自动编码) 3.python接收 解码并反序列化&quot;&quot;&quot;##########################################################regexp对象 方式1:var reg1 = new RegExp(&quot;^[a-zA-Z][a-zA-Z0-9]&#123;5,11&#125;&quot;); 方式2:var reg2 = /^[a-zA-Z][a-zA-Z0-9]&#123;5,9&#125;/;全局匹配 正则表达式的最后不加g则表示匹配成功就结束 加g表示全局匹配 # 全局匹配会有一个lastindex属性 reg2 /^[a-zA-Z][a-zA-Z0-9]&#123;5,9&#125;$/g reg2.test(&#x27;jason666&#x27;) true reg2.test(&#x27;jason666&#x27;) false reg2.lastIndex 0 reg2.test(&#x27;jason666&#x27;) true reg2.lastIndex 8校验时不传参数默认传的是undefined BOM与DOM操作12BOM 浏览器对象模型&gt;&gt;&gt;:使用js操作浏览器DOM 文档对象模型&gt;&gt;&gt;:使用js操作前端页面 BOM操作12345678910111213window.open() // 打开新窗口window.close() // 关闭当前窗口window.history.forward() // 前进一页window.history.back() // 后退一页window.location.href // 获取URLwindow.location.href=&quot;URL&quot; // 跳转到指定页面window.location.reload() // 重新加载页面setTimeout() // 定时事件clearTimeout() // 清除定时事件setInterval() // 周期事件clearInterval() // 清除周期事件","categories":[],"tags":[{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"04、css（浮动、定位、是否脱离文档流、溢出属性、z-index属性、透明度）、JavaScript简介","slug":"day04","date":"2018-06-02T06:04:04.000Z","updated":"2022-05-13T13:52:00.653Z","comments":true,"path":"2018/06/02/day04/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/02/day04/","excerpt":"","text":"浮动1234567891011121314151617# ps:html代码时没有缩进一说的 全部写在一行也可以&quot;&quot;&quot;浮动主要就是用于页面布局的!!!&quot;&quot;&quot;# 浮动带来的负面影响&quot;&quot;&quot;会造成父标签塌陷!!!&quot;&quot;&quot;解决浮动的负面影响 1.再写一个div撑场面(不可取) 2.关键字clear(可以使用) 3.通用解决策略(推荐使用):只要父标签塌陷就使用 .clearfix:after &#123; content: &#x27;&#x27;; clear: both; display: block; &#125;# 谁塌陷就给谁加class属性 # 浏览器默认都是文本优先展示 定位123456789101112131.静态定位 static 所有的标签默认都是静态定位即不能改变位置2.相对定位 relative 相对标签原来的位置做定位3.绝对定位 absolute 相对已经定位过的父标签做定位(没有则参考body标签) eg:小米官网导航条内购物车4.固定定位 fixed 相对浏览器窗口做定位 eg:小米官网右边回到顶部如何使用css完成定位 定位关键字position 位置关键字left、right、top、bottom 是否脱离文档流123456789# 标签位置改变之后 原来的位置是否会空出来 如果空出来了被其他标签自动占有 那么表示脱离否则不脱离 浮动、定位 脱离文档流 浮动、绝对定位、固定定位 不脱离文档流 相对定位 溢出属性1234567891011121314151617181920# 圆形头像#d1 &#123; width: 200px; height: 200px; border: 3px solid darkgray; border-radius: 50%; overflow: hidden;&#125;#d1 img &#123; /* 1 宽 max-width: 100%; 1.1 简写 width: 100%; 2 高 max-height:100%; 2.1 简写 height:100%; */&#125; z-index属性12# 浏览器平面不是一个二维坐标系而是一个三维坐标系eg:百度登录或者退出界面&gt;&gt;&gt;:三明治结构(模态框) 透明度1234rgba(124,124,124,0.5) 只影响颜色opacity:0.5 影响颜色和字体 JavaScript12345678# JavaScript简称JS 与Java一点关系都没有!!! 完全是为了蹭Java的热度# JS也是一门编程语言 IT行业鄙视链&gt;&gt;&gt;前端意淫着想摆脱后端的约束 写出了使用JS编写后端代码的方案&gt;&gt;&gt;NodeJs# JS虽然是一门编程语言但是逻辑非常的不严谨 据传该语言最初的版本是由一个程序员花了七天时间写出来的# JS很容易学习 JavaScript补充123456789101112类中引入方式 1.script标签内部直接编写(学习的时候使用) 2.script标签src属性导入外部js文件(最正规) 注释语法 html:&lt;!--注释语法--&gt; css:/**/ JS://单行注释 /*多行注释*/ # 模板语法注释 &#123;##&#125; 结束符号 分号作为结束符号(;) 但是不用写问题也不大 页面布局12345基本步骤 1.先使用div和span占位(主要是div) 2.再添加文本内容 3.最好再考虑样式# 在给标签添加id、class的时候最好是见名知意","categories":[],"tags":[{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"03、css（伪元素选择器、选择器优先级、字体相关、背景属性、边框属性、display属性、盒子模型）","slug":"day03","date":"2018-06-02T06:04:03.000Z","updated":"2022-05-13T15:13:07.280Z","comments":true,"path":"2018/06/02/day03/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/02/day03/","excerpt":"","text":"伪元素选择器123456789101112131415161718192021# 首字调整&gt;&gt;&gt;:也是一种文档布局的方式p:first-letter &#123; font-size: 48px; /*字体大小*/ color: red; &#125;# 在文本的前面通过css动态渲染文本&gt;&gt;&gt;:特殊文本无法选中p:before &#123; content: &#x27;嘿嘿&#x27;; color: red; &#125;&lt;p&gt;::before言而有信 品行端正 光明磊落 待人以诚&lt;/p&gt;# 在文本的后面通过css动态渲染文本&gt;&gt;&gt;:特殊文本无法选中p:after &#123; content: &#x27;呵呵&#x27;; color: greenyellow; &#125;&lt;p&gt;言而有信 品行端正 光明磊落 待人以诚::after&lt;/p&gt;&quot;&quot;&quot;以后我们在编写爬虫程序爬取页面内容的时候如果没有正常文本那么可能是因为伪元素选择器的问题&quot;&quot;&quot; 选择器的优先级12345678910&quot;&quot;&quot;我们学习了三种css引入方式并且学习了很多选择器那么如果出现多个选择器修改同一个标签样式 会优先参考谁的 研究基本选择器即可 标签选择器 类选择器 id选择器 行内选择器&quot;&quot;&quot;# 相同选择器不同导入方式 选择器系统遵循就进原则 从上往下谁离标签更近谁说了算# 不同选择器不遵循就近原则&gt;&gt;&gt;:优先级 行内选择器 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 字体相关123456789101112131415161718192021221.宽和高 只有块儿级标签可以设置 行内标签无法设置 p &#123; height: 1000px; width: 50px; &#125;2.字体大小 font-size: 99px; # 字体大小一般有固定的大小参考(肉眼适应)3.粗细 font-weight: bolder; font-weight: lighter;4.文本颜色 color:red; # 第一种 color:#4e4e4e; # 第二种 color:rgb(88,88,88) # 第三种 rgba(88,88,88,0.2) # 最后一个参数调整透明度(0-1)5.文字对齐 text-align: center; # 居中展示6.文字装饰(很常用!!!) text-decoration: none; # 主要用于去除a标签默认的下划线7.首行缩进 text-indent: 32px; # 默认文字大小是16px 背景属性123456789background-color: orange; # 背景颜色background-image: url(&#x27;url&#x27;); # 背景图片background-repeat: no-repeat; # 是否铺满background-position:左右 上下; # 图片位置&quot;&quot;&quot;多个属性名前缀相同 那么可以简写&quot;&quot;&quot;background:orange url(&#x27;url&#x27;); # 一个个编写即可 不写就默认 # 如何实时修改图片位置 浏览器找到标签的css代码 然后方向键上下按住即可动态调整 边框属性12345678910111213141516171819p &#123; /*border-left-color: red;*/ /*border-left-style: solid;*/ /*border-left-width: 3px;*/ /*多个属性有相同的前缀 一般都可以简写*/ /*border-left: 5px red solid; !*没有顺序*!*/ /*border-top:orange 10px dotted;*/ /*border-right: black dashed 5px;*/ /*border-bottom: deeppink 8px solid;*/ /*多个属性有相同的前缀 一般都可以简写*/ border: 5px red solid; /*上下左右一致*/ &#125; div &#123; height: 500px; width: 500px; border: 5px solid red; /*画圆*/ border-radius: 50%; &#125; display属性123456789101112131415161718192021div &#123; display: inline; /*行内*/&#125;span &#123; /*display: block; !*块级*!*/ display: none; /* 隐藏标签 页面上看不见也不再占用页面位置 但是通过浏览器查找标签是可以看到的 到后面学习django会讲跨站请求伪造(钓鱼网站) */ &#125;p &#123; display: inline-block; /* 具备块级标签可以修改长宽的特性 也具备行内标标签文本多大就占多大的特性 */ &#125; 盒子模型1234567891011121314151617181920212223&quot;&quot;&quot;以快递盒为例 1.快递盒与快递盒之间的距离 外边距(标签之间的距离) 2.快递盒的厚度 边框 3.内部物品到盒子的距离 内边距(文本内容到边框的距离) 4.物品本身的大小 文本大小&quot;&quot;&quot;# body标签默认自带8px的外边距 在编写的时候应该提前去掉 body &#123; margin: 0; &#125;1.外边距(标签之间的距离) margin简写 margin:0px; # 上下左右都一致 margin:10px 10px; # 第一个控制上下 第二个控制左右 margin:20px 10px 20px; # 上 左右 下 margin:10px 2px 3px 5px; # 上 右 下 左2.内边距(文本内容到边框的距离) padding简写 padding:0px; # 上下左右都一致 padding:10px 10px; # 第一个控制上下 第二个控制左右 padding:20px 10px 20px; # 上 左右 下 padding:10px 2px 3px 5px; # 上 右 下 左","categories":[],"tags":[{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"02、初次前后端交互、css（简介、基本选择器、组合选择器、属性选择器、分组与嵌套、伪类选择器）","slug":"day02","date":"2018-06-02T06:04:02.000Z","updated":"2022-05-13T15:12:59.316Z","comments":true,"path":"2018/06/02/day02/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/02/day02/","excerpt":"","text":"初次体验前后端交互123456789101112131415161718192021# 代码无需掌握 只看效果即可&quot;&quot;&quot;后端框架:可以简单的理解为别人写好的一个非常牛逼的TCP服务端&quot;&quot;&quot;以flask框架为例&gt;&gt;&gt;:第三方框架 pip3 install flask 前端通过标签获取用户数据发送给后端的过程中 标签需要有name属性 相当于字典的key 用户输入的数据会存储到标签的value属性中 相当于字典的value 如果是选择型标签需要自行加上name和valuefrom flask import Flask,requestapp = Flask(__name__)@app.route(&#x27;/index/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def index(): print(request.form) # 获取普通数据 print(request.files) # 获取文件数据 # print(request.form.get(&#x27;name&#x27;)) file_obj = request.files.get(&#x27;file&#x27;) # 获取文件对象 file_obj.save(&#x27;xxx.md&#x27;) # 保存文件 return &#x27;flask框架真简单&#x27;app.run() css简介1234567891011121314151617181920# 层叠样式表&gt;&gt;&gt;:就是给HTML标签修改样式语法结构 选择器 &#123; 属性名1:属性值1; 属性名2:属性值2 &#125;注释语法 /*注释内容*/ 引入方式 1.style内部直接编写css代码 平时学习、练习的时候推荐使用 2.link标签引入外部css文件 正式工作、实际生产环境推荐使用 3.标签内直接书写 一般情况下不推荐使用 容易造成冗余现象&quot;&quot;&quot;单独开设的css文件内代码也是非常多的 可以借助于注释管理 /*导航条样式*/ /*侧边栏样式*/&quot;&quot;&quot; 基本选择器(重要)12345678910111213141516171819202122232425&quot;&quot;&quot;css是用来调节标签样式的 那为什么需要学选择器呢? 因为同一个页面上有很多相似的标签 并且这些标签在不同的位置有不同的样式 所以为了能够区分 我们肯定先需要学习如何查找指定的标签&quot;&quot;&quot;1.标签选择器&gt;&gt;&gt;:通过标签名直接查找 /*查找所有的div标签*/ div &#123; color: red; &#125;2.类选择器(关键符号为句点符.)&gt;&gt;&gt;:通过class值查找标签 /*查找所有含有c1样式类的标签*/ .c1 &#123; color: red; &#125;3.id选择器(关键符号为警号#)&gt;&gt;&gt;:通过id值查找标签 /*查找id为d1的标签*/ #d1 &#123; color: orange; &#125;4.通用选择器(了解) /*body内所有的标签*/ * &#123; color: darkgray; &#125; 组合选择器(重点)123456789101112131415161718192021222324252627282930313233343536373839404142&quot;&quot;&quot;为了区分嵌套标签之间的关系 我们发明了一种称呼 &lt;div&gt; &lt;p&gt; &lt;span&gt;&lt;/span&gt; &lt;/p&gt; &lt;/div&gt;span是p的儿子 是div的孙子也可以说是div的后代p是div的儿子也是div后代 是span的父亲div是p的父亲是span的爷爷 也可以说是他们的祖先即： 儿子：子标签 孙子：子标签的子标签 后代：无限子标签 父亲：父标签 爷爷：父标签的父标签 祖先：无限父标签&quot;&quot;&quot;1.后代选择器(特征为空格) /*查找div内部所有的后代span*/ div span &#123; color: red; &#125; 2.儿子选择器(特征&gt;) /*查找div内部所有的儿子span*/ div &gt; span &#123; color: greenyellow; &#125;3.毗邻选择器(特征为+) /*查找同级别下面紧挨着的第一个span(不能有其他标签间隔)*/ div + span &#123; color: pink; &#125;4.弟弟选择器(特征为~) /*查找同级别下面所有的span(不需要紧挨着)*/ div ~ span &#123; color: deeppink; &#125; 属性选择器123456789101112131415# 标签可以有默认的属性也可以自定义属性 &lt;p id=&quot;d1&quot; class=&quot;c1&quot; name=&quot;jason&quot; pwd=&quot;123&quot;&gt;123&lt;/p&gt; 1、含有name属性名的标签 [name] &#123; color: red; &#125;2、含有name属性名并且值为jason的标签 [name=&#x27;jason&#x27;] &#123; color: red; &#125;3、p标签中含有name属性名并且值为jason的 p[name=&#x27;jason&#x27;] &#123; color: red; &#125; 分组与嵌套1234567891011121314151617181920212223242526272829303132333435# 1、多个相同选择器并列使用ag：查找div或者span或者p div,span,p &#123; color: red; &#125; # 2、多个不同选择器并列使用ag：标签查找div id查找d1 类查找c1 div,#d1,.c1 &#123; color: red; &#125;# 3、不并列同样可以使用组合选择器ag：查找class为c1的后代p标签 .c1 p &#123; color: red; &#125;# 4、直接筛选ag1：查找id为d1的div标签 div#d1 &#123; color: red; &#125;ag2：查找class为c1的div标签 div.c1 &#123; color: red; &#125;&quot;&quot;&quot;练习题 #d1&gt;div&gt;.c1&gt;span.c2： 查找id为d1的标签内部的儿子div 并且在儿子div内部查找class为c1的儿子标签 并且在该儿子内部查找class为c2的儿子span&quot;&quot;&quot; 伪类选择器1234567891011/*鼠标悬浮在上面*/a:hover &#123; # 重点掌握 很多网址都在用!!! color: orange;&#125; &quot;&quot;&quot;a标签默认的颜色会变化 第一次是蓝色 后面是紫色&quot;&quot;&quot;input:focus &#123; background-color: red; &#125;&quot;&quot;&quot;我们将input框被用户点击即将录入数据的过程看成是focus状态(聚焦状态)&quot;&quot;&quot;","categories":[],"tags":[{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"01、HTML（简介、创建、展示）、head内常见标签、body内常见标签、标签的两大重要属性","slug":"day01","date":"2018-06-02T06:04:01.000Z","updated":"2022-05-13T15:12:56.880Z","comments":true,"path":"2018/06/02/day01/","link":"","permalink":"https://chenxiao0629.github.io/2018/06/02/day01/","excerpt":"","text":"HTML简介1234567891011121314151617181920212223HTML是构造网页的骨架&gt;&gt;&gt;:几乎所有的网站都是由HTML构建而成HTML:超文本标记语言# 不是一门编程语言 没有任何的逻辑 只有固定的标记功能&quot;&quot;&quot;HTML标签的分类 1.双标签(有头有尾) &lt;a&gt;&lt;/a&gt; 2.自闭合标签(单标签) &lt;img&gt;&quot;&quot;&quot;# HTML文档结构 &lt;html&gt; &lt;head&gt;编写给浏览器查看的内容&lt;/head&gt; &lt;body&gt;编写展示给用户查看的内容&lt;/body&gt; &lt;/html&gt; &#x27;&#x27;&#x27;在使用编程工具创建的时候就会自动编写文档结构&#x27;&#x27;&#x27;# HTML语法注释 &lt;!--单行注释--&gt; &lt;!-- 多行注释 多行注释 --&gt; &#x27;&#x27;&#x27;在编写的时候 编程工具也有注释快捷键 ctrl+?&#x27;&#x27;&#x27; 如何创建及展示12345678910&quot;&quot;&quot;存档网页骨架的文件后缀名一般都是.html 该类型文件主要的打开方式为浏览器形式&quot;&quot;&quot;1.以pycharm为例 右键new点击HTML FILE创建即可2.如何打开展示 右上方会提供多种浏览器(注意需要提前下载) # 编写HTML标签的时候 不需要自己写大括号小括号 只需要写标签名称+tab键即可自动补全(所有支持编写html文件的工具内部自带的插件语法功能) head内常见标签1234567891011title 定义网页标题style 内部支持css代码script 内部支持编写js代码 还可以通过src属性导入外部js文件link 通过href属性引入外部的css文件meta 定义网页源信息 keywords关键字搜索 description网页描述信息&quot;&quot;&quot;在html文件中 可以编写html和css以及js 但是实际工作中三者其实是分开存放的 这样有利于后期维护和扩展&quot;&quot;&quot; body内基本标签1234567891011121314151617h1~h6 标题标签p 段落标签b 加粗i 斜体u 下划线s 删除线br 换行hr 水平分割线&quot;&quot;&quot;有时候相同的样式 可能有多种标签可以实现!!!&quot;&quot;&quot;标签分类 分类1:单双标签 分类2: 块儿级标签 h1~h6 p 独占一行(后期可以通过css实现不占一行) 行内标签 u i s b 自身文本多大就占多大 特殊符号1234567&amp;nbsp; 空格&amp;gt; 大于号&amp;lt; 小于号&amp;amp; &amp;符号&amp;yen; 羊角符&amp;copy; 版权符&amp;reg; 注册 常见标签：div、span、a、img1234567891011121314151617181920212223242526272829303132333435363738394041# 网页在制作之前需要提前布局好布局标签 div 块儿级标签 span 行内标签 &quot;&quot;&quot;标签是可以嵌套的 但是需要遵循以下规律 1、块儿级标签 可以无限制的嵌套块儿级标签和行内标签 特例:p标签虽然是块儿级标签但是也不能嵌套块儿级标签 2、行内标签不能嵌套块儿级标签 可以嵌套行内标签 知识点扩展 页面布局的技巧 先用div划分区域 之后再考虑填充具体内容 可以参考小米官网练习该技巧&quot;&quot;&quot;1.a标签:链接标签 用法1:通过href属性指定网址(URL)点击跳转 跳转过程中有两种方式 1.当前页面跳转 target=&quot;_self&quot; 默认 2.新建页面跳转 target=&quot;_blank&quot; 用法2:锚点功能 通过href属性指定标签的id值点击即可跳转到对应位置&quot;&quot;&quot;网址其实并不是一个非常专业的名词 URL:统一资源定位符&quot;&quot;&quot;2.img标签:图片标签 1、src属性指定图片地址 可以是本地的地址也可以是网络上的地址 2、alt属性编写文本 用于在图片无法加载出来的情况下的提示信息 3、title属性写文本 用于鼠标悬浮在图片上之后提示的文本信息 4、height、width属性写像素 用于调整图片的尺寸 注意：调整的时候 修改一个另外一个自动等比例缩放 如果同事调整两个 那么可能会造成图片的失真 5、在外面套a标签：点击图片可以跳转a标签href属性对应地址 列表标签123456789101112131415161718192021222324251.无序列表(掌握) # 前面没有用于标识数字顺序的提示 &lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ul&gt; &quot;&quot;&quot; 网页上有规则排列的多个横向或者竖向内容 几乎都是无序列表 要想实现需要css相关知识 &quot;&quot;&quot;2.有序列表(了解) &lt;ol&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;/ol&gt;3.标题列表(了解) &lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;内容1&lt;/dd&gt; &lt;dd&gt;内容2&lt;/dd&gt; &lt;/dl&gt; 表格标签12345678910111213141516171819202122232425262728293031323334353637# 当需要展示一些具体固定格式的多条数据的时候可以考虑使用(excel)# 表格标签的格式 &lt;table&gt; &lt;thead&gt;&lt;/thead&gt; 表头 &lt;tbody&gt;&lt;/tbody&gt; 表单 &lt;/table&gt;# tr标签 tr就表示一行# th标签 在表头的字段名称# td标签 普通的单元格数据 &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;密码&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;jason&lt;/td&gt; &lt;td&gt;123&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&quot;&quot;&quot;我们只需要掌握最基本的html标签即可 至于花里胡哨的样式后面学习完前端框架之后 直接cv拷贝即可 都是别人提前写好的&quot;&quot;&quot;border: 表格边框.cellpadding: 内边距cellspacing: 外边距.width: 像素 百分比.（最好通过css来设置长宽）rowspan: 单元格竖跨多少行colspan: 单元格横跨多少列（即合并单元格） form表单(很重要)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# form表单:获取用户的数据并发送给后端(服务端) eg:网站的登录、注册、验证码... &#x27;&#x27;&#x27;以注册页面为例&#x27;&#x27;&#x27;1.获取用户数据最为常用的标签就是input标签并且该标签是行内标签 input标签是前端标签里面的变形金刚 通过type参数的不同变换不同的表现形式 text 普通文本 password 密码展示 date 日历展示 radio 单选&gt;&gt;&gt;:多个选项标签需要有相同的name属性 默认选中需要额外配置checked=&#x27;checked&#x27; 当属性名与属性值相等的时候可以简写checked checkbox 多选&gt;&gt;&gt;:默认选中也是checked属性 email 邮箱格式 file 上传文件&gt;&gt;&gt;:默认只支持单个文件 如果需要一次性上传多个需要额外配置multiple submit 提交按钮&gt;&gt;&gt;:点击出发提交数据的动作 button 普通按钮&gt;&gt;&gt;:本身没有任何功能 需要绑定(JS) reset 重置按钮 按钮组的提示信息可以通过value属性自定义，如果不自定义 那么不同的浏览器可能会展示出不同的提示信息 尤其是submit按钮 select标签是下拉框选项 一个个选项就是一个个option标签 默认是单选也可以变为多选 multiple textarea标签 获取大段文本内容 2.直接编写input会出现黄色阴影，原因在于input需要结合lable一起使用 label标签作用：点击内部文本可以跳转输入框内 方式1:lable包裹input并绑定id &lt;label for=&#x27;input标签id值&#x27;&gt;input标签&lt;/label&gt; 方式2:label与input单独出现并绑定id &lt;label for=&quot;d1&quot;&gt;username:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;d1&quot;&gt; 3.form表单提交数据 数据的提交地址由form表单的action参数来控制 action=&quot;URL&quot; # 不写默认朝当前页面所在的地址提交 method=&quot;数据的提交方式&quot; # 数据的提交方式有很多种 这里先忽略(后续讲解) get post put delete patch...&quot;&quot;&quot;form表单在提交数据的时候 如果含文件则需要指定两个固定参数 method=&#x27;post&#x27; enctype=&quot;multipart/form-data&quot;&quot;&quot;&quot; 标签的两大重要属性123456789101.id属性 个体查找 类似于标签的身份证号 在同一个html页面上id不能重复2.class属性 群体查找 类似于python面向对象中的类的继承 可以将多个标签划为一类 &lt;h1 class=&#x27;c1&#x27;&gt;&lt;/h1&gt; &lt;p class=&#x27;c1&#x27;&gt;&lt;/p&gt; 并且一个标签可以有很多类 &lt;h1 class=&#x27;c1 c2 c3&#x27;&gt;&lt;/h1&gt; &lt;p class=&#x27;c1 c8 c9&#x27;&gt;&lt;/p&gt;","categories":[],"tags":[{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]},{"title":"38、Python并发编程之IO模型","slug":"38、python并发编程之IO模型","date":"2018-05-13T06:04:38.000Z","updated":"2022-05-13T12:29:17.172Z","comments":true,"path":"2018/05/13/38、python并发编程之IO模型/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/38%E3%80%81python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BIO%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"目录： 一 IO模型介绍 二 阻塞IO(blocking IO) 三 非阻塞IO(non-blocking IO) 四 多路复用IO(IO multiplexing) 五 异步IO(Asynchronous I&#x2F;O) 六 IO模型比较分析 七 selectors模块 一 IO模型介绍为了更好地了解IO模型，我们需要事先回顾下：同步、异步、阻塞、非阻塞 同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO分别是什么，到底有什么区别？这个问题其实不同的人给出的答案都可能不同，比如wiki，就认为asynchronous IO和non-blocking IO是一个东西。这其实是因为不同的人的知识背景不同，并且在讨论这个问题的时候上下文(context)也不相同。所以，为了更好的回答这个问题，我先限定一下本文的上下文。 本文讨论的背景是Linux环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I&#x2F;O Models ”，Stevens在这节中详细说明了各种IO的特点和区别，如果英文够好的话，推荐直接阅读。Stevens的文风是有名的深入浅出，所以不用担心看不懂。本文中的流程图也是截取自参考文献。 Stevens在文章中一共比较了五种IO Model： * blocking IO * nonblocking IO * IO multiplexing * signal driven IO * asynchronous IO 由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model。 再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，该操作会经历两个阶段： 12#1）等待数据准备 (Waiting for the data to be ready)#2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process) 记住这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况。 补充： 1234567#1、输入操作：read、readv、recv、recvfrom、recvmsg共5个函数，如果会阻塞状态，则会经理wait data和copy data两个阶段，如果设置为非阻塞则在wait 不到data时抛出异常#2、输出操作：write、writev、send、sendto、sendmsg共5个函数，在发送缓冲区满了会阻塞在原地，如果设置为非阻塞，则会抛出异常#3、接收外来链接：accept，与输入操作类似#4、发起外出链接：connect，与输出操作类似 二 阻塞IO（blocking IO）在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样： 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。 而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。 几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv() 等接口开始的，使用这些接口可以很方便的构建服务器&#x2F;客户机的模型。然而大部分的socket接口都是阻塞型的。如下图 ps：所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。 实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用recv(1024)的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。 一个简单的解决方案： 1#在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。 该方案的问题是： 1#开启多进程或都线程的方式，在遇到要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而且线程与进程本身也更容易进入假死状态。 改进方案： 1#很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。 改进后方案其实也存在着问题： 1#“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。 对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。 三 非阻塞IO（non-blocking IO）Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子： 从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是用户就可以在本次到下次再发起read询问的时间间隔内做其他事情，或者直接再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存（这一阶段仍然是阻塞的），然后返回。 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。 所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。 非阻塞IO示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 服务端import socketimport timeserver=socket.socket()server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)server.bind((&#x27;127.0.0.1&#x27;,8083))server.listen(5)server.setblocking(False)r_list=[]w_list=&#123;&#125;while 1: try: conn,addr=server.accept() r_list.append(conn) except BlockingIOError: # 强调强调强调：！！！非阻塞IO的精髓在于完全没有阻塞！！！ # time.sleep(0.5) # 打开该行注释纯属为了方便查看效果 print(&#x27;在做其他的事情&#x27;) print(&#x27;rlist: &#x27;,len(r_list)) print(&#x27;wlist: &#x27;,len(w_list)) # 遍历读列表，依次取出套接字读取内容 del_rlist=[] for conn in r_list: try: data=conn.recv(1024) if not data: conn.close() del_rlist.append(conn) continue w_list[conn]=data.upper() except BlockingIOError: # 没有收成功，则继续检索下一个套接字的接收 continue except ConnectionResetError: # 当前套接字出异常，则关闭，然后加入删除列表，等待被清除 conn.close() del_rlist.append(conn) # 遍历写列表，依次取出套接字发送内容 del_wlist=[] for conn,data in w_list.items(): try: conn.send(data) del_wlist.append(conn) except BlockingIOError: continue # 清理无用的套接字,无需再监听它们的IO操作 for conn in del_rlist: r_list.remove(conn) for conn in del_wlist: w_list.pop(conn)#客户端import socketimport osclient=socket.socket()client.connect((&#x27;127.0.0.1&#x27;,8083))while 1: res=(&#x27;%s hello&#x27; %os.getpid()).encode(&#x27;utf-8&#x27;) client.send(res) data=client.recv(1024) print(data.decode(&#x27;utf-8&#x27;)) 但是非阻塞IO模型绝不被推荐。 我们不能否则其优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在“”同时“”执行）。 但是也难掩其缺点： 12#1. 循环调用recv()将大幅度推高CPU占用率；这也是我们在代码中留一句time.sleep(2)的原因,否则在低配主机下极容易出现卡机情况#2. 任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。 *此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。* 四 多路复用IO（IO multiplexing）IO multiplexing这个词可能有点陌生，但是如果我说select&#x2F;epoll，大概就都能明白了。有些地方也称这种IO方式为事件驱动IO(event driven IO)。我们都知道，select&#x2F;epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select&#x2F;epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图： 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 这个图和blocking IO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blocking IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。 强调： 1. 如果处理的连接数不是很高的话，使用select&#x2F;epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 2. 在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 结论: select的优势在于可以处理多个连接，不适用于单个连接 select网络IO模型 1#服务端from socket import *import selectserver = socket(AF_INET, SOCK_STREAM)server.bind((&#x27;127.0.0.1&#x27;,8093))server.listen(5)server.setblocking(False)print(&#x27;starting...&#x27;)rlist=[server,]wlist=[]wdata=&#123;&#125;while True: rl,wl,xl=select.select(rlist,wlist,[],0.5) print(wl) for sock in rl: if sock == server: conn,addr=sock.accept() rlist.append(conn) else: try: data=sock.recv(1024) if not data: sock.close() rlist.remove(sock) continue wlist.append(sock) wdata[sock]=data.upper() except Exception: sock.close() rlist.remove(sock) for sock in wl: sock.send(wdata[sock]) wlist.remove(sock) wdata.pop(sock)#客户端from socket import *client=socket(AF_INET,SOCK_STREAM)client.connect((&#x27;127.0.0.1&#x27;,8093))while True: msg=input(&#x27;&gt;&gt;: &#x27;).strip() if not msg:continue client.send(msg.encode(&#x27;utf-8&#x27;)) data=client.recv(1024) print(data.decode(&#x27;utf-8&#x27;))client.close() select监听fd变化的过程分析： 1#用户进程创建socket对象，拷贝监听的fd到内核空间，每一个fd会对应一张系统文件表，内核空间的fd响应到数据后，就会发送信号给用户进程数据已到；#用户进程再发送系统调用，比如（accept）将内核空间的数据copy到用户空间，同时作为接受数据端内核空间的数据清除，这样重新监听时fd再有新的数据又可以响应到了（发送端因为基于TCP协议所以需要收到应答后才会清除）。 该模型的优点： 1#相比其他模型，使用select() 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值。 该模型的缺点： 1#首先select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll，…。如果需要实现更高效的服务器程序，类似epoll这样的接口更被推荐。遗憾的是不同的操作系统特供的epoll接口有很大差异，所以使用类似于epoll的接口实现具有较好跨平台能力的服务器会比较困难。#其次，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。 五 异步IO（Asynchronous IO）Linux下的asynchronous IO其实用得不多，从内核2.6版本才开始引入。先看一下它的流程： 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 六 IO模型比较分析到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。 先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。 再说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的： A synchronous I&#x2F;O operation causes the requesting process to be blocked until that I&#x2F;O operationcompletes; An asynchronous I&#x2F;O operation does not cause the requesting process to be blocked; 两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，四个IO模型可以分为两大类，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO这一类，而 asynchronous I&#x2F;O后一类 。 有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。 各个IO Model的比较如图所示： 经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 七 selectors模块select,poll,epoll 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869IO复用：为了解释这个名词，首先来理解下复用这个概念，复用也就是共用的意思，这样理解还是有些抽象，为此，咱们来理解下复用在通信领域的使用，在通信领域中为了充分利用网络连接的物理介质，往往在同一条网络链路上采用时分复用或频分复用的技术使其在同一链路上传输多路信号，到这里我们就基本上理解了复用的含义，即公用某个“介质”来尽可能多的做同一类(性质)的事，那IO复用的“介质”是什么呢？为此我们首先来看看服务器编程的模型，客户端发来的请求服务端会产生一个进程来对其进行服务，每当来一个客户请求就产生一个进程来服务，然而进程不可能无限制的产生，因此为了解决大量客户端访问的问题，引入了IO复用技术，即：一个进程可以同时对多个客户请求进行服务。也就是说IO复用的“介质”是进程(准确的说复用的是select和poll，因为进程也是靠调用select和poll来实现的)，复用一个进程(select和poll)来对多个IO进行服务，虽然客户端发来的IO是并发的但是IO所需的读写数据多数情况下是没有准备好的，因此就可以利用一个函数(select和poll)来监听IO所需的这些数据的状态，一旦IO有数据可以进行读写了，进程就来对这样的IO进行服务。理解完IO复用后，我们在来看下实现IO复用中的三个API(select、poll和epoll)的区别和联系select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。三者的原型如下所示：int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);int poll(struct pollfd *fds, nfds_t nfds, int timeout);int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); 1.select的第一个参数nfds为fdset集合中最大描述符值加1，fdset是一个位数组，其大小限制为__FD_SETSIZE（1024），位数组的每一位代表其对应的描述符是否需要被检查。第二三四参数表示需要关注读、写、错误事件的文件描述符位数组，这些参数既是输入参数也是输出参数，可能会被内核修改用于标示哪些描述符上发生了关注的事件，所以每次调用select前都需要重新初始化fdset。timeout参数为超时时间，该结构会被内核修改，其值为超时剩余的时间。 select的调用步骤如下：（1）使用copy_from_user从用户空间拷贝fdset到内核空间（2）注册回调函数__pollwait（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll 来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数 据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是 current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout 指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。（8）把fd_set从内核空间拷贝到用户空间。总结下select的几大缺点：（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（3）select支持的文件描述符数量太小了，默认是10242． poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。 poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，相比处理fdset来说，poll效率更高。poll返回后，需要对pollfd中的每个元素检查其revents值，来得指事件是否发生。3．直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll 和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函 数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注 册要监听的事件类型；epoll_wait则是等待事件的产生。 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定 EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝 一次。 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在 epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调 函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用 schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子, 在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。总结：（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用 epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在 epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的 时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间，这就是回调机制带来的性能提升。（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要 一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内 部定义的等待队列），这也能节省不少的开销。 这三种IO多路复用模型在不同的平台有着不同的支持，而epoll在windows下就不支持，好在我们有selectors模块，帮我们默认选择当前平台下最合适的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#服务端from socket import *import selectorssel=selectors.DefaultSelector()def accept(server_fileobj,mask): conn,addr=server_fileobj.accept() sel.register(conn,selectors.EVENT_READ,read)def read(conn,mask): try: data=conn.recv(1024) if not data: print(&#x27;closing&#x27;,conn) sel.unregister(conn) conn.close() return conn.send(data.upper()+b&#x27;_SB&#x27;) except Exception: print(&#x27;closing&#x27;, conn) sel.unregister(conn) conn.close()server_fileobj=socket(AF_INET,SOCK_STREAM)server_fileobj.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)server_fileobj.bind((&#x27;127.0.0.1&#x27;,8088))server_fileobj.listen(5)server_fileobj.setblocking(False) #设置socket的接口为非阻塞sel.register(server_fileobj,selectors.EVENT_READ,accept) #相当于网select的读列表里append了一个文件句柄server_fileobj,并且绑定了一个回调函数acceptwhile True: events=sel.select() #检测所有的fileobj，是否有完成wait data的 for sel_obj,mask in events: callback=sel_obj.data #callback=accpet callback(sel_obj.fileobj,mask) #accpet(server_fileobj,1)#客户端from socket import *c=socket(AF_INET,SOCK_STREAM)c.connect((&#x27;127.0.0.1&#x27;,8088))while True: msg=input(&#x27;&gt;&gt;: &#x27;) if not msg:continue c.send(msg.encode(&#x27;utf-8&#x27;)) data=c.recv(1024) print(data.decode(&#x27;utf-8&#x27;)) 作业:基于selectors模块实现并发的FTP 参考:链接: https://pan.baidu.com/s/1qYPrHCg 密码: 9is4","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"37、Python并发编程之协程","slug":"37、python并发编程之协程","date":"2018-05-13T06:04:37.000Z","updated":"2022-05-13T12:29:14.610Z","comments":true,"path":"2018/05/13/37、python并发编程之协程/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/37%E3%80%81python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8D%8F%E7%A8%8B/","excerpt":"","text":"目录： 一 引子 二 协程介绍 三 Greenlet 四 Gevent介绍 五 Gevent之同步与异步 六 Gevent之应用举例一 七 Gevent之应用举例二 一 引子本节的主题是基于单线程来实现并发，即只用一个主线程（很明显可利用的cpu只有一个）情况下实现并发，为此我们需要先回顾下并发的本质：切换+保存状态 cpu正在运行一个任务，会在两种情况下切走去执行其他的任务（切换由操作系统强制控制），一种情况是该任务发生了阻塞，另外一种情况是该任务计算的时间过长或有一个优先级更高的程序替代了它 ps：在介绍进程理论时，提及进程的三种执行状态，而线程才是执行单位，所以也可以将上图理解为线程的三种状态 一：其中第二种情况并不能提升效率，只是为了让cpu能够雨露均沾，实现看起来所有任务都被“同时”执行的效果，如果多个任务都是纯计算的，这种切换反而会降低效率。为此我们可以基于yield来验证。yield本身就是一种在单线程下可以保存任务运行状态的方法，我们来简单复习一下： 12#1 yiled可以保存状态，yield的状态保存与操作系统的保存线程状态很像，但是yield是代码级别控制的，更轻量级#2 send可以把一个函数的结果传给另外一个函数，以此实现单线程内程序之间的切换 单纯地切换反而会降低运行效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#x27;&#x27;&#x27;1、协程： 单线程实现并发 在应用程序里控制多个任务的切换+保存状态 优点： 应用程序级别速度要远远高于操作系统的切换 缺点： 多个任务一旦有一个阻塞没有切，整个线程都阻塞在原地 该线程内的其他的任务都不能执行了 一旦引入协程，就需要检测单线程下所有的IO行为, 实现遇到IO就切换,少一个都不行，以为一旦一个任务阻塞了，整个线程就阻塞了， 其他的任务即便是可以计算，但是也无法运行了2、协程序的目的： 想要在单线程下实现并发 并发指的是多个任务看起来是同时运行的 并发=切换+保存状态&#x27;&#x27;&#x27;#串行执行import timedef func1(): for i in range(10000000): i+1def func2(): for i in range(10000000): i+1start = time.time()func1()func2()stop = time.time()print(stop - start)#基于yield并发执行import timedef func1(): while True: yielddef func2(): g=func1() for i in range(10000000): i+1 next(g)start=time.time()func2()stop=time.time()print(stop-start) 二：第一种情况的切换。在任务一遇到io情况下，切到任务二去执行，这样就可以利用任务一阻塞的时间完成任务二的计算，效率的提升就在于此。 yield不能检测IO，实现遇到IO自动切换 1234567891011121314151617import timedef func1(): while True: print(&#x27;func1&#x27;) yielddef func2(): g=func1() for i in range(10000000): i+1 next(g) time.sleep(3) print(&#x27;func2&#x27;)start=time.time()func2()stop=time.time()print(stop-start) 对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，io比较少，从而更多的将cpu的执行权限分配给我们的线程。 协程的本质就是在单线程下，由用户自己控制一个任务遇到io阻塞了就切换另外一个任务去执行，以此来提升效率。为了实现它，我们需要找寻一种可以同时满足以下条件的解决方案： 123#1. 可以控制多个任务之间的切换，切换之前将任务的状态保存下来，以便重新运行时，可以基于暂停的位置继续执行。#2. 作为1的补充：可以检测io操作，在遇到io操作的情况下才发生切换 二 协程介绍协程：是单线程下的并发，又称微线程，纤程。英文名Coroutine。一句话说明什么是协程：协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。、 需要强调的是： 12#1. python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）#2. 单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关） 对比操作系统控制线程的切换，用户在单线程内控制协程的切换 优点如下： 12#1. 协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级#2. 单线程内就可以实现并发的效果，最大限度地利用cpu 缺点如下： 12#1. 协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程#2. 协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程 总结协程特点： 必须在只有一个单线程里实现并发 修改共享数据不需加锁 用户程序里自己保存多个控制流的上下文栈 附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制）） 三 Greenlet如果我们在单个线程内有20个任务，要想实现在多个任务之间切换，使用yield生成器的方式过于麻烦（需要先得到初始化一次的生成器，然后再调用send。。。非常麻烦），而使用greenlet模块可以非常简单地实现这20个任务直接的切换 123456789101112131415161718#安装pip3 install greenletfrom greenlet import greenletdef eat(name): print(&#x27;%s eat 1&#x27; %name) g2.switch(&#x27;egon&#x27;) print(&#x27;%s eat 2&#x27; %name) g2.switch()def play(name): print(&#x27;%s play 1&#x27; %name) g1.switch() print(&#x27;%s play 2&#x27; %name)g1=greenlet(eat)g2=greenlet(play)g1.switch(&#x27;egon&#x27;)#可以在第一次switch时传入参数，以后都不需要 单纯的切换（在没有io的情况下或者没有重复开辟内存空间的操作），反而会降低程序的执行速度 123456789101112131415161718192021222324252627282930313233343536373839#顺序执行import timedef f1(): res=1 for i in range(100000000): res+=idef f2(): res=1 for i in range(100000000): res*=istart=time.time()f1()f2()stop=time.time()print(&#x27;run time is %s&#x27; %(stop-start)) #10.985628366470337#切换from greenlet import greenletimport timedef f1(): res=1 for i in range(100000000): res+=i g2.switch()def f2(): res=1 for i in range(100000000): res*=i g1.switch()start=time.time()g1=greenlet(f1)g2=greenlet(f2)g1.switch()stop=time.time()print(&#x27;run time is %s&#x27; %(stop-start)) # 52.763017892837524 greenlet只是提供了一种比generator更加便捷的切换方式，当切到一个任务执行时如果遇到io，那就原地阻塞，仍然是没有解决遇到IO自动切换来提升效率的问题。 单线程里的这20个任务的代码通常会既有计算操作又有阻塞操作，我们完全可以在执行任务1时遇到阻塞，就利用阻塞的时间去执行任务2。。。。如此，才能提高效率，这就用到了Gevent模块。 四 Gevent介绍12#安装pip3 install gevent Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。 123456789101112#用法g1=gevent.spawn(func,1,,2,3,x=4,y=5)创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的g2=gevent.spawn(func2)g1.join() #等待g1结束g2.join() #等待g2结束#或者上述两步合作一步：gevent.joinall([g1,g2])g1.value#拿到func1的返回值 遇到IO阻塞时会自动切换任务 123456789101112131415161718import geventdef eat(name): print(&#x27;%s eat 1&#x27; %name) gevent.sleep(2) print(&#x27;%s eat 2&#x27; %name)def play(name): print(&#x27;%s play 1&#x27; %name) gevent.sleep(1) print(&#x27;%s play 2&#x27; %name)g1=gevent.spawn(eat,&#x27;egon&#x27;)g2=gevent.spawn(play,name=&#x27;egon&#x27;)g1.join()g2.join()#或者gevent.joinall([g1,g2])print(&#x27;主&#x27;) 上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞, 而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了 from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前 或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头 123456789101112131415161718from gevent import monkey;monkey.patch_all()import geventimport timedef eat(): print(&#x27;eat food 1&#x27;) time.sleep(2) print(&#x27;eat food 2&#x27;)def play(): print(&#x27;play 1&#x27;) time.sleep(1) print(&#x27;play 2&#x27;)g1=gevent.spawn(eat)g2=gevent.spawn(play_phone)gevent.joinall([g1,g2])print(&#x27;主&#x27;) 我们可以用threading.current_thread().getName()来查看每个g1和g2，查看的结果为DummyThread-n，即假线程 五 Greenlet之同步与异步1234567891011121314151617181920212223242526from gevent import spawn,joinall,monkey;monkey.patch_all()import timedef task(pid): &quot;&quot;&quot; Some non-deterministic task &quot;&quot;&quot; time.sleep(0.5) print(&#x27;Task %s done&#x27; % pid)def synchronous(): for i in range(10): task(i)def asynchronous(): g_l=[spawn(task,i) for i in range(10)] joinall(g_l)if __name__ == &#x27;__main__&#x27;: print(&#x27;Synchronous:&#x27;) synchronous() print(&#x27;Asynchronous:&#x27;) asynchronous()#上面程序的重要部分是将task函数封装到Greenlet内部线程的gevent.spawn。 初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall 函数，后者阻塞当前流程，并执行所有给定的greenlet。执行流程只会在 所有greenlet执行完后才会继续向下走。 六 Greenlet之应用举例一1234567891011121314151617181920from gevent import monkey;monkey.patch_all()import geventimport requestsimport timedef get_page(url): print(&#x27;GET: %s&#x27; %url) response=requests.get(url) if response.status_code == 200: print(&#x27;%d bytes received from %s&#x27; %(len(response.text),url))start_time=time.time()gevent.joinall([ gevent.spawn(get_page,&#x27;https://www.python.org/&#x27;), gevent.spawn(get_page,&#x27;https://www.yahoo.com/&#x27;), gevent.spawn(get_page,&#x27;https://github.com/&#x27;),])stop_time=time.time()print(&#x27;run time is %s&#x27; %(stop_time-start_time)) 七 Greenlet之应用举例二通过gevent实现单线程下的socket并发（from gevent import monkey;monkey.patch_all()一定要放到导入socket模块之前，否则gevent无法识别socket的阻塞） 服务端 123456789101112131415161718192021222324252627282930from gevent import monkey;monkey.patch_all()from socket import *import gevent#如果不想用monkey.patch_all()打补丁,可以用gevent自带的socket# from gevent import socket# s=socket.socket()def server(server_ip,port): s=socket(AF_INET,SOCK_STREAM) s.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) s.bind((server_ip,port)) s.listen(5) while True: conn,addr=s.accept() gevent.spawn(talk,conn,addr)def talk(conn,addr): try: while True: res=conn.recv(1024) print(&#x27;client %s:%s msg: %s&#x27; %(addr[0],addr[1],res)) conn.send(res.upper()) except Exception as e: print(e) finally: conn.close()if __name__ == &#x27;__main__&#x27;: server(&#x27;127.0.0.1&#x27;,8080) 客户端 12345678910111213from socket import *client=socket(AF_INET,SOCK_STREAM)client.connect((&#x27;127.0.0.1&#x27;,8080))while True: msg=input(&#x27;&gt;&gt;: &#x27;).strip() if not msg:continue client.send(msg.encode(&#x27;utf-8&#x27;)) msg=client.recv(1024) print(msg.decode(&#x27;utf-8&#x27;)) 多线程并发多个客户端 123456789101112131415161718from threading import Threadfrom socket import *import threadingdef client(server_ip,port): c=socket(AF_INET,SOCK_STREAM) #套接字对象一定要加到函数内，即局部名称空间内，放在函数外则被所有线程共享，则大家公用一个套接字对象，那么客户端端口永远一样了 c.connect((server_ip,port)) count=0 while True: c.send((&#x27;%s say hello %s&#x27; %(threading.current_thread().getName(),count)).encode(&#x27;utf-8&#x27;)) msg=c.recv(1024) print(msg.decode(&#x27;utf-8&#x27;)) count+=1if __name__ == &#x27;__main__&#x27;: for i in range(500): t=Thread(target=client,args=(&#x27;127.0.0.1&#x27;,8080)) t.start()","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"36、Python并发编程之多线程（实战）","slug":"36、python并发编程之多线程（操作篇）","date":"2018-05-13T06:04:36.000Z","updated":"2022-05-13T12:29:11.616Z","comments":true,"path":"2018/05/13/36、python并发编程之多线程（操作篇）/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/36%E3%80%81python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AF%87%EF%BC%89/","excerpt":"","text":"目录： 一 threading模块介绍 二 开启线程的两种方式 三 在一个进程下开启多个线程与在一个进程下开启多个子进程的区别 四 练习 五 线程相关的其他方法 六 守护线程 七 Python GIL(Global Interpreter Lock) 八 同步锁 九 死锁现象与递归锁 十 信号量Semaphore 十一 Event 十二 条件Condition（了解） 十三 定时器 十四 线程queue 十五 Python标准模块–concurrent.futures 一 threading模块介绍multiprocessing模块完全模仿了threading模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍 官网链接：https://docs.python.org/3/library/threading.html?highlight=threading# 二 开启线程的两种方式方式一 1234567891011from threading import Threadimport timedef sayhi(name): time.sllep(2) print(&#x27;%s say hello&#x27; % name)if __name__ == &#x27;__main__&#x27;: t = Thread(target=syahi, args=(&#x27;egon&#x27;, )) t.start() print(&#x27;主线程&#x27;) 方式二 12345678910111213141516from threading import Threadimport timeclass Sayhi(Thread) def __init__(self,name): super().__init() self.name = name def run(name): time.sllep(2) print(&#x27;%s say hello&#x27; % name)if __name__ == &#x27;__main__&#x27;: t = Syahi(&#x27;egon&#x27;) t.start() print(&#x27;主线程&#x27;) 三 在一个进程下开启多个线程与在一个进程下开启多个子进程的区别1 谁的开启速度快 1234567891011121314151617181920212223242526272829from threading import Threadfrom multiprocessing import Processimport osdef work(): print(&#x27;hello&#x27;)if __name__ == &quot;__main__&quot;: # 在主进程下开启线程 t = Thread(target=work) t.start() print(&#x27;主线程/主进程&#x27;) &quot;&quot;&quot; 打印结果： hello 主线程/主进程 &quot;&quot;&quot; # 在主进程下开启子进程 p = Process(target=work) p.start() print(&#x27;主线程/主进程&#x27;) &quot;&quot;&quot; 打印结果： 主线程/主进程 hello &quot;&quot;&quot; 2 瞅一瞅pid 12345678910111213141516171819202122from threading import Threadfrom multiprocessing import Processimport osdef work(): print(&#x27;hello&#x27;,os.getpid())if __name__ == &#x27;__man__&#x27;: #part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样 t1=Thread(target=work) t2=Thread(target=work) t1.start() t2.start() print(&#x27;主线程/主进程pid&#x27;,os.getpid()) #part2:开多个进程,每个进程都有不同的pid p1=Process(target=work) p2=Process(target=work) p1.start() p2.start() print(&#x27;主线程/主进程pid&#x27;,os.getpid()) 3 同一进程内的线程共享该进程的数据？ 1234567891011121314151617181920from threading import Threadfrom multiprocessing import Processimport osdef work(): global n n=0if __name__ == &#x27;__main__&#x27;: # n=100 # p=Process(target=work) # p.start() # p.join() # print(&#x27;主&#x27;,n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100 n=1 t=Thread(target=work) t.start() t.join() print(&#x27;主&#x27;,n) #查看结果为0,因为同一进程内的线程之间共享进程内的数据 四 练习练习一： 多线程并发的socket服务端 12345678910111213141516171819202122#_*_coding:utf8_*_#!/user/bin/env pythonimport multiprocessing import threadingimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((&#x27;127.0.0.1&#x27;, 8080))s.listen(5)def action(conn): while True: data = conn.recv(1024) print(data) conn.send(data.upper())if __name__ == &#x27;__main__&#x27;: while True: conn, addr = s.accept() p = threading.Thread(target=action, args=(conn, )) p.start() 客户端 12345678910111213import sockets = socket.socket(socket.AF_INET， socket.SOCK_STREAM)s.connect((&#x27;127.0.0.1&#x27;, 8080))while True: msg = input(&#x27;&gt;&gt;&gt;:&#x27;).strip() if not msg: continue s.send(msg.encode(&#x27;utf8&#x27;)) data=s.recv(1024) print(data) 练习二：三个任务，一个接收用户输入，一个将用户输入的内容格式化成大写，一个将格式化后的结果存入文件 1234567891011121314151617181920212223242526272829from threading import Threadmsg_l = []format_l = []def takl(): while True: msg = input(&#x27;&gt;&gt;&gt;:&#x27;).strip() if not msg:continue msg_l.append(msg)def format_msg(): while True: if msg_l: res = msg_l.pop() format_l.append(res.upper()) def save(): while True: if format_l: with open(&#x27;db.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf8&#x27;) as f: res = format_l.pop() f.write(&#x27;%s\\n&#x27; % res) if __name__ == &#x27;__main__&#x27;: t1=Thread(target=talk) t2=Thread(target=format_msg) t3=Thread(target=save) t1.start() t2.start() t3.start() 五 线程相关的其他方法1234567891011121314151617181920212223242526272829303132333435363738394041Thread实例对象的方法 # isAlive() 返回线程是否活动的 # getName() 返回线程名 # setName() 设置线程名threading模块提供的一些方法： # threading.currentThread() 返回当前的线程变量 # threading.enumerate() 返回一个包含正在运行的线程的list。正在运行指线程启动后，结束前，不包括启动前和终止后的线程。 # threading.activeCount() 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果from threading import Threadimport threadingfrom multiprocessing import Processimport osdef work(): import time time.sleep(3) print(threading.current_thread().getName())if __name__ == &#x27;__main__&#x27;: #在主进程下开启线程 t=Thread(target=work) t.start() print(threading.current_thread().getName()) print(threading.current_thread()) #主线程 print(threading.enumerate()) #连同主线程在内有两个运行的线程 print(threading.active_count()) print(&#x27;主线程/主进程&#x27;) &#x27;&#x27;&#x27; 打印结果: MainThread &lt;_MainThread(MainThread, started 140735268892672)&gt; [&lt;_MainThread(MainThread, started 140735268892672)&gt;, &lt;Thread(Thread-1, started 123145307557888)&gt;] 2 主线程/主进程 Thread-1 &#x27;&#x27;&#x27; 主线程等待子线程结束 1234567891011121314151617from threading import Threadimport timedef sayhi(name): time.sleep(2) print(&#x27;%s say hello&#x27; %name)if __name__ == &#x27;__main__&#x27;: t=Thread(target=sayhi,args=(&#x27;egon&#x27;,)) t.start() t.join() print(&#x27;主线程&#x27;) print(t.is_alive()) &#x27;&#x27;&#x27; egon say hello 主线程 False &#x27;&#x27;&#x27; 六 守护线程无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁 需要强调的是：运行完毕并非终止运行 123#1.对主进程来说，运行完毕指的是主进程代码运行完毕#2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕 1234567891011121314151617181920#1 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，#2 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。from threading import Threadimport timedef sayhi(name): time.sleep(2) print(&#x27;%s say hello&#x27; %name)if __name__ == &#x27;__main__&#x27;: t=Thread(target=sayhi,args=(&#x27;egon&#x27;,)) t.setDaemon(True) # 必须在t.start之前设置 t.start() print(&#x27;主线程&#x27;) print(t.is_alive()) &#x27;&#x27;&#x27; 主线程 True &#x27;&#x27;&#x27; 迷惑人的例子 1234567891011121314151617181920from threading import Threadimport timedef foo(): print(123) time.sleep(1) print(&quot;end123&quot;)def bar(): print(456) time.sleep(3) print(&quot;end456&quot;)t1=Thread(target=foo)t2=Thread(target=bar)t1.daemon=Truet1.start()t2.start()print(&quot;main-------&quot;) 七 Python GIL（Global Interpreter Lock）链接：http://www.cnblogs.com/linhaifeng/articles/7449853.html 八 同步锁123456三个需要注意的点：#1.线程抢的是GIL锁，GIL锁相当于执行权限，拿到执行权限后才能拿到互斥锁Lock，其他线程也可以抢到GIL，但如果发现Lock仍然没有被释放则阻塞，即便是拿到执行权限GIL也要立刻交出来#2.join是等待所有，即整体串行，而锁只是锁住修改共享数据的部分，即部分串行，要想保证数据安全的根本原理在于让并发变成串行，join与互斥锁都可以实现，毫无疑问，互斥锁的部分串行效率要更高#3. 一定要看本小节最后的GIL与互斥锁的经典分析 GIL VS Lock 机智的同学可能会问到这个问题，就是既然你之前说过了，Python已经有一个GIL来保证同一时间只能有一个线程来执行了，为什么这里还需要lock? 首先我们需要达成共识：锁的目的是为了保护共享的数据，同一时间只能有一个线程来修改共享的数据 然后，我们可以得出结论：保护不同的数据就应该加不同的锁。 最后，问题就很明朗了，GIL 与Lock是两把锁，保护的数据不一样，前者是解释器级别的（当然保护的就是解释器级别的数据，比如垃圾回收的数据），后者是保护用户自己开发的应用程序的数据，很明显GIL不负责这件事，只能用户自定义加锁处理，即Lock 过程分析：所有线程抢的是GIL锁，或者说所有线程抢的是执行权限 线程1抢到GIL锁，拿到执行权限，开始执行，然后加了一把Lock，还没有执行完毕，即线程1还未释放Lock，有可能线程2抢到GIL锁，开始执行，执行过程中发现Lock还没有被线程1释放，于是线程2进入阻塞，被夺走执行权限，有可能线程1拿到GIL，然后正常执行到释放Lock。。。这就导致了串行运行的效果 既然是串行，那我们执行 t1.start() t1.join t2.start() t2.join() 这也是串行执行啊，为何还要加Lock呢，需知join是等待t1所有的代码执行完，相当于锁住了t1的所有代码，而Lock只是锁住一部分操作共享数据的代码。 详细 12345678910111213141516171819因为Python解释器帮你自动定期进行内存回收，你可以理解为python解释器里有一个独立的线程，每过一段时间它起wake up做一次全局轮询看看哪些内存数据是可以被清空的，此时你自己的程序 里的线程和 py解释器自己的线程是并发运行的，假设你的线程删除了一个变量，py解释器的垃圾回收线程在清空这个变量的过程中的clearing时刻，可能一个其它线程正好又重新给这个还没来及得清空的内存空间赋值了，结果就有可能新赋值的数据被删除了，为了解决类似的问题，python解释器简单粗暴的加了锁，即当一个线程运行时，其它人都不能动，这样就解决了上述的问题， 这可以说是Python早期版本的遗留问题。from threading import Threadimport os,timedef work(): global n temp=n time.sleep(0.1) n=temp-1if __name__ == &#x27;__main__&#x27;: n=100 l=[] for i in range(100): p=Thread(target=work) l.append(p) p.start() for p in l: p.join() print(n) #结果可能为99 锁通常被用来实现对共享资源的同步访问。为每一个共享资源创建一个Lock对象，当你需要访问该资源时，调用acquire方法来获取锁对象（如果其它线程已经获得了该锁，则当前线程需等待其被释放），待资源访问完后，再调用release方法释放锁： 123456789101112131415161718192021222324252627282930import threadingR=threading.Lock()R.acquire()&#x27;&#x27;&#x27;对公共数据的操作&#x27;&#x27;&#x27;R.release()from threading import Thread,Lockimport os,timedef work(): global n lock.acquire() temp=n time.sleep(0.1) n=temp-1 lock.release()if __name__ == &#x27;__main__&#x27;: lock=Lock() n=100 l=[] for i in range(100): p=Thread(target=work) l.append(p) p.start() for p in l: p.join() print(n) #结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全 GIL锁与互斥锁综合分析（重点） 12345分析： #1.100个线程去抢GIL锁，即抢执行权限 #2. 肯定有一个线程先抢到GIL（暂且称为线程1），然后开始执行，一旦执行就会拿到lock.acquire() #3. 极有可能线程1还未运行完毕，就有另外一个线程2抢到GIL，然后开始运行，但线程2发现互斥锁lock还未被线程1释放，于是阻塞，被迫交出执行权限，即释放GIL #4.直到线程1重新抢到GIL，开始从上次暂停的位置继续执行，直到正常释放互斥锁lock，然后其他的线程再重复2 3 4的过程 互斥锁与join的区别（重点！！！） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#不加锁:并发执行,速度快,数据不安全from threading import current_thread,Thread,Lockimport os,timedef task(): global n print(&#x27;%s is running&#x27; %current_thread().getName()) temp=n time.sleep(0.5) n=temp-1if __name__ == &#x27;__main__&#x27;: n=100 lock=Lock() threads=[] start_time=time.time() for i in range(100): t=Thread(target=task) threads.append(t) t.start() for t in threads: t.join() stop_time=time.time() print(&#x27;主:%s n:%s&#x27; %(stop_time-start_time,n))&#x27;&#x27;&#x27;Thread-1 is runningThread-2 is running......Thread-100 is running主:0.5216062068939209 n:99&#x27;&#x27;&#x27;#不加锁:未加锁部分并发执行,加锁部分串行执行,速度慢,数据安全from threading import current_thread,Thread,Lockimport os,timedef task(): #未加锁的代码并发运行 time.sleep(3) print(&#x27;%s start to run&#x27; %current_thread().getName()) global n #加锁的代码串行运行 lock.acquire() temp=n time.sleep(0.5) n=temp-1 lock.release()if __name__ == &#x27;__main__&#x27;: n=100 lock=Lock() threads=[] start_time=time.time() for i in range(100): t=Thread(target=task) threads.append(t) t.start() for t in threads: t.join() stop_time=time.time() print(&#x27;主:%s n:%s&#x27; %(stop_time-start_time,n))&#x27;&#x27;&#x27;Thread-1 is runningThread-2 is running......Thread-100 is running主:53.294203758239746 n:0&#x27;&#x27;&#x27;#有的同学可能有疑问:既然加锁会让运行变成串行,那么我在start之后立即使用join,就不用加锁了啊,也是串行的效果啊#没错:在start之后立刻使用jion,肯定会将100个任务的执行变成串行,毫无疑问,最终n的结果也肯定是0,是安全的,但问题是#start后立即join:任务内的所有代码都是串行执行的,而加锁,只是加锁的部分即修改共享数据的部分是串行的#单从保证数据安全方面,二者都可以实现,但很明显是加锁的效率更高.from threading import current_thread,Thread,Lockimport os,timedef task(): time.sleep(3) print(&#x27;%s start to run&#x27; %current_thread().getName()) global n temp=n time.sleep(0.5) n=temp-1if __name__ == &#x27;__main__&#x27;: n=100 lock=Lock() start_time=time.time() for i in range(100): t=Thread(target=task) t.start() t.join() stop_time=time.time() print(&#x27;主:%s n:%s&#x27; %(stop_time-start_time,n))&#x27;&#x27;&#x27;Thread-1 start to runThread-2 start to run......Thread-100 start to run主:350.6937336921692 n:0 #耗时是多么的恐怖&#x27;&#x27;&#x27; 九 死锁现象与递归锁进程也有死锁与递归锁，在进程那里忘记说了，放到这里一切说了额 所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁 123456789101112131415161718192021222324252627282930313233343536373839404142from threading import Thread,Lockimport timemutexA=Lock()mutexB=Lock()class MyThread(Thread): def run(self): self.func1() self.func2() def func1(self): mutexA.acquire() print(&#x27;\\033[41m%s 拿到A锁\\033[0m&#x27; %self.name) mutexB.acquire() print(&#x27;\\033[42m%s 拿到B锁\\033[0m&#x27; %self.name) mutexB.release() mutexA.release() def func2(self): mutexB.acquire() print(&#x27;\\033[43m%s 拿到B锁\\033[0m&#x27; %self.name) time.sleep(2) mutexA.acquire() print(&#x27;\\033[44m%s 拿到A锁\\033[0m&#x27; %self.name) mutexA.release() mutexB.release()if __name__ == &#x27;__main__&#x27;: for i in range(10): t=MyThread() t.start()&#x27;&#x27;&#x27;Thread-1 拿到A锁Thread-1 拿到B锁Thread-1 拿到B锁Thread-2 拿到A锁然后就卡住，死锁了&#x27;&#x27;&#x27; 解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。 这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁： 1mutexA=mutexB=threading.RLock() #一个线程拿到锁，counter加1,该线 十 信号量Semaphore同进程的一样 Semaphore管理一个内置的计数器， 每当调用acquire()时内置计数器-1； 调用release() 时内置计数器+1； 计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()。 实例：(同时只有5个线程可以获得semaphore,即可以限制最大连接数为5)： 1234567891011121314151617181920212223from threading import Thread, Semaphoreimport threadingimport time# def func():# if sm.acquire():# print (threading.currentThread().getName() + &#x27; get semaphore&#x27;)# time.sleep(2)# sm.release()def func(): sm.acquire() print(&#x27;%s get sm&#x27; %threading.current_thread().getName()) time.sleep(3) sm.release()if __name__ == &#x27;__main__&#x27;: sm=Semaphore(5) for i in range(23): t=Thread(target=func) t.start() 与进程池是完全不同的概念，进程池Pool(4)，最大只能产生4个进程，而且从头到尾都只是这四个进程，不会产生新的，而信号量是产生一堆线程/进程互斥锁与信号量推荐博客：http://url.cn/5DMsS9r 十一 Event同进程的一样 线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行 1234event.isSet() 返回event的状态值event.wait() 如果event,isSet() == False将阻塞线程event.set() 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态，等待操作系统调度event.clear() 恢复event的状态值为False 例如，有多个工作线程尝试链接MySQL，我们想要在链接前确保MySQL服务正常才让那些工作线程去连接MySQL服务器，如果连接不成功，都会去尝试重新连接。那么我们就可以采用threading.Event机制来协调各个工作线程的连接操作 1234567891011121314151617181920212223242526from threading import Thread, Eventimport threadingimport time, randomdef conn_mycql(): count = 1 while not event.is_set(): if count &gt; 3: raise TimeoutError(&#x27;链接超时&#x27;) print(&#x27;&lt;%s&gt;第%s尝试链接&#x27; % (threading.current_thread().getName(), count)) event.wait(0.5) print(&#x27;&lt;%s&gt;链接成功&#x27;%threading.current_thread().getName())def check_mysql(): print(&#x27;\\033[45m[%s]正在检查mysql\\033[0m&#x27; % threading.current_thread().getName()) time.sleep(random.randint(2,4)) event.set()if __name__ == &#x27;__main__&#x27;: event=Event() conn1=Thread(target=conn_mysql) conn2=Thread(target=conn_mysql) check=Thread(target=check_mysql) conn1.start() conn2.start() check.start() 十二 条件Condition（了解）使得线程等待，只有满足某条件时，才释放n个线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingdef run(n): con.acquire() con.wait() print(&quot;run the thread: %s&quot; %n) con.release()if __name__ == &#x27;__main__&#x27;: con = threading.Condition() for i in range(10): t = threading.Thread(target=run, args=(i,)) t.start() while True: inp = input(&#x27;&gt;&gt;&gt;&#x27;) if inp == &#x27;q&#x27;: break con.acquire() con.notify(int(inp)) con.release()def condition_func(): ret = False inp = input(&#x27;&gt;&gt;&gt;&#x27;) if inp == &#x27;1&#x27;: ret = True return retdef run(n): con.acquire() con.wait_for(condition_func) print(&quot;run the thread: %s&quot; %n) con.release()if __name__ == &#x27;__main__&#x27;: con = threading.Condition() for i in range(10): t = threading.Thread(target=run, args=(i,)) t.start() 十三 定时器定时器，指定n秒后执行某操作 1234567from threading import Timerdef hello(): print(&#x27;a&#x27;)t = Timer(1, hello)t.start() # after 1 seconds, &quot;a&quot; will be printed 验证码定时器 1234567891011121314151617181920212223242526272829from threading import Timerimport random, timeclass Code: def __init__(self): self.make_cache() def make_cache(self, interval=5): self.cache = self.make_code() print(self.cache) self.t = Timer(interval, self.make_cache) self.t.start() def make_code(self, n=4): res = &#x27;&#x27; for i in range(n): s1 = str(random.ranint(0,9)) s2 = chr(random.randint(65,90)) res += random.choice([s1, s2]) return res def check(self): while Ture: inp = input(&#x27;&gt;&gt;&gt;:&#x27;).strip() if inp.upper() == self.cache: print(&#x27;验证成功&#x27;, end=&#x27;\\n&#x27;) self.t.cancel() breakif __name__ == &#x27;__main__&#x27;: obj = Code() obj.check() 十四 线程queuequeue队列 ：使用import queue，用法与进程Queue一样 queue is especially useful in threaded programming when information must be exchanged safely between multiple threads. *class* queue.``Queue(*maxsize&#x3D;0*) #先进先出 12345678910111213141516import queueq=queue.Queue()q.put(&#x27;first&#x27;)q.put(&#x27;second&#x27;)q.put(&#x27;third&#x27;)print(q.get())print(q.get())print(q.get())&#x27;&#x27;&#x27;结果(先进先出):firstsecondthird&#x27;&#x27;&#x27; *class* queue.``LifoQueue(*maxsize&#x3D;0*) #last in fisrt out 12345678910111213141516import queueq=queue.LifoQueue()q.put(&#x27;first&#x27;)q.put(&#x27;second&#x27;)q.put(&#x27;third&#x27;)print(q.get())print(q.get())print(q.get())&#x27;&#x27;&#x27;结果(后进先出):thirdsecondfirst&#x27;&#x27;&#x27; *class* queue.``PriorityQueue(*maxsize&#x3D;0*) #存储数据时可设置优先级的队列 1234567891011121314151617import queueq=queue.PriorityQueue()#put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高q.put((20,&#x27;a&#x27;))q.put((10,&#x27;b&#x27;))q.put((30,&#x27;c&#x27;))print(q.get())print(q.get())print(q.get())&#x27;&#x27;&#x27;结果(数字越小优先级越高,优先级高的优先出队):(10, &#x27;b&#x27;)(20, &#x27;a&#x27;)(30, &#x27;c&#x27;)&#x27;&#x27;&#x27; 其他 1234567891011121314151617181920212223242526272829303132333435Constructor for a priority queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite.The lowest valued entries are retrieved first (the lowest valued entry is the one returned by sorted(list(entries))[0]). A typical pattern for entries is a tuple in the form: (priority_number, data).exception queue.EmptyException raised when non-blocking get() (or get_nowait()) is called on a Queue object which is empty.exception queue.FullException raised when non-blocking put() (or put_nowait()) is called on a Queue object which is full.Queue.qsize()Queue.empty() #return True if empty Queue.full() # return True if full Queue.put(item, block=True, timeout=None)Put item into the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case).Queue.put_nowait(item)Equivalent to put(item, False).Queue.get(block=True, timeout=None)Remove and return an item from the queue. If optional args block is true and timeout is None (the default), block if necessary until an item is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Otherwise (block is false), return an item if one is immediately available, else raise the Empty exception (timeout is ignored in that case).Queue.get_nowait()Equivalent to get(False).Two methods are offered to support tracking whether enqueued tasks have been fully processed by daemon consumer threads.Queue.task_done()Indicate that a formerly enqueued task is complete. Used by queue consumer threads. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task is complete.If a join() is currently blocking, it will resume when all items have been processed (meaning that a task_done() call was received for every item that had been put() into the queue).Raises a ValueError if called more times than there were items placed in the queue.Queue.join() block直到queue被消费完毕 十五 Python标准模块–concurrent.futureshttps://docs.python.org/dev/library/concurrent.futures.html 12345678910111213141516171819202122232425#1 介绍concurrent.futures模块提供了高度封装的异步调用接口ThreadPoolExecutor：线程池，提供异步调用ProcessPoolExecutor: 进程池，提供异步调用Both implement the same interface, which is defined by the abstract Executor class.#2 基本方法#submit(fn, *args, **kwargs)异步提交任务#map(func, *iterables, timeout=None, chunksize=1) 取代for循环submit的操作#shutdown(wait=True) 相当于进程池的pool.close()+pool.join()操作wait=True，等待池内所有任务执行完毕回收完资源后才继续wait=False，立即返回，并不会等待池内的任务执行完毕但不管wait参数为何值，整个程序都会等到所有任务执行完毕submit和map必须在shutdown之前#result(timeout=None)取得结果#add_done_callback(fn)回调函数 ProcessPoolExecutor 12345678910111213141516171819202122232425262728#介绍The ProcessPoolExecutor class is an Executor subclass that uses a pool of processes to execute calls asynchronously. ProcessPoolExecutor uses the multiprocessing module, which allows it to side-step the Global Interpreter Lock but also means that only picklable objects can be executed and returned.class concurrent.futures.ProcessPoolExecutor(max_workers=None, mp_context=None)An Executor subclass that executes calls asynchronously using a pool of at most max_workers processes. If max_workers is None or not given, it will default to the number of processors on the machine. If max_workers is lower or equal to 0, then a ValueError will be raised.#用法from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorimport os,time,randomdef task(n): print(&#x27;%s is runing&#x27; %os.getpid()) time.sleep(random.randint(1,3)) return n**2if __name__ == &#x27;__main__&#x27;: executor=ProcessPoolExecutor(max_workers=3) futures=[] for i in range(11): future=executor.submit(task,i) futures.append(future) executor.shutdown(True) print(&#x27;+++&gt;&#x27;) for future in futures: print(future.result()) ThreadPoolExecutor 1234567891011#介绍ThreadPoolExecutor is an Executor subclass that uses a pool of threads to execute calls asynchronously.class concurrent.futures.ThreadPoolExecutor(max_workers=None, thread_name_prefix=&#x27;&#x27;)An Executor subclass that uses a pool of at most max_workers threads to execute calls asynchronously.Changed in version 3.5: If max_workers is None or not given, it will default to the number of processors on the machine, multiplied by 5, assuming that ThreadPoolExecutor is often used to overlap I/O instead of CPU work and the number of workers should be higher than the number of workers for ProcessPoolExecutor.New in version 3.6: The thread_name_prefix argument was added to allow users to control the threading.Thread names for worker threads created by the pool for easier debugging.#用法与ProcessPoolExecutor相同 map的用法 12345678910111213141516from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorimport os,time,randomdef task(n): print(&#x27;%s is runing&#x27; %os.getpid()) time.sleep(random.randint(1,3)) return n**2if __name__ == &#x27;__main__&#x27;: executor=ThreadPoolExecutor(max_workers=3) # for i in range(11): # future=executor.submit(task,i) executor.map(task,range(1,12)) #map取代了for+submit 回调函数 1234567891011121314151617181920212223242526272829303132333435363738from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorfrom multiprocessing import Poolimport requestsimport jsonimport osdef get_page(url): print(&#x27;&lt;进程%s&gt; get %s&#x27; %(os.getpid(),url)) respone=requests.get(url) if respone.status_code == 200: return &#123;&#x27;url&#x27;:url,&#x27;text&#x27;:respone.text&#125;def parse_page(res): res=res.result() print(&#x27;&lt;进程%s&gt; parse %s&#x27; %(os.getpid(),res[&#x27;url&#x27;])) parse_res=&#x27;url:&lt;%s&gt; size:[%s]\\n&#x27; %(res[&#x27;url&#x27;],len(res[&#x27;text&#x27;])) with open(&#x27;db.txt&#x27;,&#x27;a&#x27;) as f: f.write(parse_res)if __name__ == &#x27;__main__&#x27;: urls=[ &#x27;https://www.baidu.com&#x27;, &#x27;https://www.python.org&#x27;, &#x27;https://www.openstack.org&#x27;, &#x27;https://help.github.com/&#x27;, &#x27;http://www.sina.com.cn/&#x27; ] # p=Pool(3) # for url in urls: # p.apply_async(get_page,args=(url,),callback=pasrse_page) # p.close() # p.join() p=ProcessPoolExecutor(3) for url in urls: p.submit(get_page,url).add_done_callback(parse_page) #parse_page拿到的是一个future对象obj，需要用obj.result()拿到结果","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"35、Python并发编程之多线程（理论）","slug":"35、python并发编程之多线程（理论篇）","date":"2018-05-13T06:04:35.000Z","updated":"2022-05-13T12:29:09.135Z","comments":true,"path":"2018/05/13/35、python并发编程之多线程（理论篇）/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/35%E3%80%81python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/","excerpt":"","text":"一 什么是线程 二 线程的创建开销小 三 线程与进程的区别 四 为何要用多线程 五 多线程的应用举例 六 经典的线程模型（了解） 七 POSIX线程（了解） 八 在用户空间实现的线程（了解） 九 在内核空间实现的线程（了解） 十 用户级与内核级线程的对比（了解） 十一 混合实现（了解） 十二 线程小故事 一 什么是线程在传统操作系统中，每个进程有一个地址空间，而且默认就有一个控制线程 线程顾名思义，就是一条流水工作的过程，一条流水线必须属于一个车间，一个车间的工作过程是一个进程 车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一个流水线 流水线的工作需要电源，电脑就相当于cpu 所以，进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。 多线程（即多个控制线程）的概念是：在一个进程中存在多个控制线程，多个控制线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。 例如：北京地铁与上海地铁是不同的进程，而北京地铁里的13号线是一个线程，北京地铁所有的线路共享北京地铁所有的资源，比如所有的乘客可以被所有线路拉。 二 线程的创建开销小创建进程的开销要远大于线程？ 如果我们的软件是一个工厂，该工厂有多条流水线，流水线工作需要电源，电源只有一个即cpu（单核cpu） 一个车间就是一个进程，一个车间至少一条流水线（一个进程至少一个线程） 创建一个进程，就是创建一个车间（申请空间，在该空间内建至少一条流水线） 而建线程，就只是在一个车间内造一条流水线，无需申请空间，所以创建开销小 进程之间是竞争关系，线程之间是协作关系？ 车间直接是竞争&#x2F;抢电源的关系，竞争（不同的进程直接是竞争关系，是不同的程序员写的程序运行的，迅雷抢占其他进程的网速，360把其他进程当作病毒干死）一个车间的不同流水线式协同工作的关系（同一个进程的线程之间是合作关系，是同一个程序员写的程序内打开，迅雷内的线程是合作关系，不会自己干自己） 三 线程与进程的区别 Threads share the address space of the process that created it; processes have their own address space. Threads have direct access to the data segment of its process; processes have their own copy of the data segment of the parent process. Threads can directly communicate with other threads of its process; processes must use interprocess communication to communicate with sibling processes. New threads are easily created; new processes require duplication of the parent process. Threads can exercise considerable control over threads of the same process; processes can only exercise control over child processes. Changes to the main thread (cancellation, priority change, etc.) may affect the behavior of the other threads of the process; changes to the parent process does not affect child processes. 四 为何要用多线程多线程指的是，在一个进程中开启多个线程，简单地将：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。具体来讲分为四点： \\1. 多线程共享一个进程的地址空间 \\2. 线程比进程更轻量级，线程比进程更容易创建可撤销，在许多操作系统中，创建一个线程比创建一个进程要快10-100倍，在有大量线程需要动态和快速修改时，这一特性很有用 \\3. 若多个线程都是cpu密集型的，那么并不能获得性能上的增强，但是如果存在大量的计算和大量的I&#x2F;O处理，拥有多个线程允许这些活动彼此重叠运行，从而会加快程序执行的速度。 \\4. 在多cpu系统中，为了最大限度的利用多核，可以开启多个线程，比开进程开销要小的多。（这一条并不适用于python） 五 多线程的应用举例 开启一个字处理软件进程，该进程肯定需要办不止一件事情，比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。 六 经典的线程模型（了解）多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程 而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。 多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。 不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。 类似于进程，每个线程也有自己的堆栈 不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。 线程通常是有益的，但是带来了不小程序设计难度，线程的问题是： \\1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程 如果是，那么附近中某个线程被阻塞，那么copy到子进程后，copy版的线程也要被阻塞吗，想一想nginx的多线程模式接收用户连接。 \\2. 在同一个进程中，如果一个线程关闭了问题，而另外一个线程正准备往该文件内写内容呢？ 如果一个线程注意到没有内存了，并开始分配更多的内存，在工作一半时，发生线程切换，新的线程也发现内存不够用了，又开始分配更多的内存，这样内存就被分配了多次，这些问题都是多线程编程的典型问题，需要仔细思考和设计。 七 POSIX线程（了解）为了实现可移植的线程程序,IEEE在IEEE标准1003.1c中定义了线程标准，它定义的线程包叫Pthread。大部分UNIX系统都支持该标准，简单介绍如下 八 在用户空间实现的线程（了解）线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。 用户级线程内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu,目前Linux pthread大体是这么做的。 在用户空间模拟操作系统对进程的调度，来调用一个进程中的线程，每个进程中都会有一个运行时系统，用来调度线程。此时当该进程获取cpu时，进程内再调度出一个线程去执行，同一时刻只有一个线程执行。 九 在内核空间实现的线程（了解）内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。 十 用户级与内核级线程的对比（了解）一： 以下是用户级线程和内核级线程的区别： 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。 用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。 二： 内核线程的优缺点 优点： 当有多个处理机时，一个进程的多个线程可以同时执行。 缺点： 由内核进行调度。 三： 用户进程的*优缺点* 优点： 线程的调度不需要内核直接参与，控制简单。 可以在不支持线程的操作系统中实现。 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。 允许每个进程定制自己的调度算法，线程管理比较灵活。 线程能够利用的表空间和堆栈空间比内核级线程多。 同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。 缺点： 资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用 十一 混合实现（了解）用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程 十二 线程小故事我是一个线程mp.weixin.qq.com","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"34、Python并发编程之多进程（实战）","slug":"34、python并发编程之多进程（操作篇）","date":"2018-05-13T06:04:34.000Z","updated":"2022-05-13T12:29:06.726Z","comments":true,"path":"2018/05/13/34、python并发编程之多进程（操作篇）/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/34%E3%80%81python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E6%93%8D%E4%BD%9C%E7%AF%87%EF%BC%89/","excerpt":"","text":"目录： 一 multiprocessing模块介绍 二 Process类的介绍 三 Process类的使用 四 守护进程 五 进程同步(锁) 六 队列（推荐使用） 七 管道 八 共享数据 九 信号量(了解） 十 事件(了解) 十一 进程池 1、multiprocessing模块介绍python中的多线程无法利用多核优势，如果想要充分地使用多核CPU的资源（os.cpu_count()查看），在python中大部分需要使用多进程。Python提供了multiprocessing。 multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。 需要再次强调一点的是：与线程不同。进程没有任何共享状态，进程修改的额数据没改动仅限于改进程内 2、Process类的介绍创建进程的类： 12345Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）强调：1. 需要使用关键字的方式来指定参数2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号 参数介绍： 1234567891 group参数未使用，值始终为None2 3 target表示调用对象，即子进程要执行的任务4 5 args表示调用对象的位置参数元组，args=(1,2,&#x27;egon&#x27;,)6 7 kwargs表示调用对象的字典,kwargs=&#123;&#x27;name&#x27;:&#x27;egon&#x27;,&#x27;age&#x27;:18&#125;8 9 name为子进程的名称 方法介绍： 12345671 p.start()：启动进程，并调用该子进程中的p.run() 2 p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 3 4 p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁 5 p.is_alive():如果p仍然运行，返回True 6 7 p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程 属性介绍： 1234567891 p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置2 3 p.name:进程的名称4 5 p.pid：进程的pid6 7 p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)8 9 p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可） 3、Process类的使用注意：在windows中Process()必须放到# if name &#x3D;&#x3D; ‘main‘:下 详细解释 123456789Since Windows has no fork, the multiprocessing module starts a new Python process and imports the calling module. If Process() gets called upon import, then this sets off an infinite succession of new processes (or until your machine runs out of resources). This is the reason for hiding calls to Process() insideif __name__ == &quot;__main__&quot;since statements inside this if-statement will not get called upon import.由于Windows没有fork，多处理模块启动一个新的Python进程并导入调用模块。 如果在导入时调用Process（），那么这将启动无限继承的新进程（或直到机器耗尽资源）。 这是隐藏对Process（）内部调用的原，使用if __name__ == “__main __”，这个if语句中的语句将不会在导入时被调用。 创建并开启子进程的两种方式 方法一 123456789101112131415161718192021#开进程的方法一:import timeimport randomfrom multiprocessing import Processdef piao(name): print(&#x27;%s piaoing&#x27; %name) time.sleep(random.randrange(1,5)) print(&#x27;%s piao end&#x27; %name)p1=Process(target=piao,args=(&#x27;egon&#x27;,)) #必须加,号p2=Process(target=piao,args=(&#x27;alex&#x27;,))p3=Process(target=piao,args=(&#x27;wupeqi&#x27;,))p4=Process(target=piao,args=(&#x27;yuanhao&#x27;,))p1.start()p2.start()p3.start()p4.start()print(&#x27;主线程&#x27;) 方法二 1234567891011121314151617181920212223242526#开进程的方法二:import timeimport randomfrom multiprocessing import Processclass Piao(Process): def __init__(self,name): super().__init__() self.name=name def run(self): print(&#x27;%s piaoing&#x27; %self.name) time.sleep(random.randrange(1,5)) print(&#x27;%s piao end&#x27; %self.name)p1=Piao(&#x27;egon&#x27;)p2=Piao(&#x27;alex&#x27;)p3=Piao(&#x27;wupeiqi&#x27;)p4=Piao(&#x27;yuanhao&#x27;)p1.start() #start会自动调用runp2.start()p3.start()p4.start()print(&#x27;主线程&#x27;) 进程直接的内存空间是隔离的 123456789101112from multiprocessing import Processn=100 #在windows系统中应该把全局变量定义在if __name__ == &#x27;__main__&#x27;之上就可以了def work(): global n n=0 print(&#x27;子进程内: &#x27;,n)if __name__ == &#x27;__main__&#x27;: p=Process(target=work) p.start() print(&#x27;主进程内: &#x27;,n) 练习1：把上周所学的socket通信变成并发的形式 server端 12345678910111213141516171819202122from socket import *from multiprocessing import Processserver=socket(AF_INET,SOCK_STREAM)server.setsockopt(SOL_SOCKET,SO_REUSEADDR,1)server.bind((&#x27;127.0.0.1&#x27;,8080))server.listen(5)def talk(conn,client_addr): while True: try: msg=conn.recv(1024) if not msg:break conn.send(msg.upper()) except Exception: breakif __name__ == &#x27;__main__&#x27;: #windows下start进程一定要写到这下面 while True: conn,client_addr=server.accept() p=Process(target=talk,args=(conn,client_addr)) p.start() 多个client端 12345678910111213from socket import *client=socket(AF_INET,SOCK_STREAM)client.connect((&#x27;127.0.0.1&#x27;,8080))while True: msg=input(&#x27;&gt;&gt;: &#x27;).strip() if not msg:continue client.send(msg.encode(&#x27;utf-8&#x27;)) msg=client.recv(1024) print(msg.decode(&#x27;utf-8&#x27;)) 这么实现有没有问题？？？ 12每来一个客户端，都在服务端开启一个进程，如果并发来一个万个客户端，要开启一万个进程吗，你自己尝试着在你自己的机器上开启一万个，10万个进程试一试。解决方法：进程池 *Process对象的join方法* join：主进程等，等待子进程结束 123456789101112131415161718from multiprocessing import Processimport timeimport randomclass Piao(Process): def __init__(self,name): self.name=name super().__init__() def run(self): print(&#x27;%s is piaoing&#x27; %self.name) time.sleep(random.randrange(1,3)) print(&#x27;%s is piao end&#x27; %self.name)p=Piao(&#x27;egon&#x27;)p.start()p.join(0.0001) #等待p停止,等0.0001秒就不再等了print(&#x27;开始&#x27;) 有了join，程序不就是串行了吗？？？ 12345678910111213141516171819202122232425262728293031323334353637383940414243from multiprocessing import Processimport timeimport randomdef piao(name): print(&#x27;%s is piaoing&#x27; %name) time.sleep(random.randint(1,3)) print(&#x27;%s is piao end&#x27; %name)p1=Process(target=piao,args=(&#x27;egon&#x27;,))p2=Process(target=piao,args=(&#x27;alex&#x27;,))p3=Process(target=piao,args=(&#x27;yuanhao&#x27;,))p4=Process(target=piao,args=(&#x27;wupeiqi&#x27;,))p1.start()p2.start()p3.start()p4.start()#有的同学会有疑问:既然join是等待进程结束,那么我像下面这样写,进程不就又变成串行的了吗?#当然不是了,必须明确：p.join()是让谁等？#很明显p.join()是让主线程等待p的结束，卡住的是主线程而绝非进程p，#详细解析如下：#进程只要start就会在开始运行了,所以p1-p4.start()时,系统中已经有四个并发的进程了#而我们p1.join()是在等p1结束,没错p1只要不结束主线程就会一直卡在原地,这也是问题的关键#join是让主线程等,而p1-p4仍然是并发执行的,p1.join的时候,其余p2,p3,p4仍然在运行,等#p1.join结束,可能p2,p3,p4早已经结束了,这样p2.join,p3.join.p4.join直接通过检测，无需等待# 所以4个join花费的总时间仍然是耗费时间最长的那个进程运行的时间p1.join()p2.join()p3.join()p4.join()print(&#x27;主线程&#x27;)#上述启动进程与join进程可以简写为# p_l=[p1,p2,p3,p4]# # for p in p_l:# p.start()# # for p in p_l:# p.join() Process对象的其他方法或属性（了解） terminate与is_alive 123456789101112131415161718192021222324#进程对象的其他方法一:terminate,is_alivefrom multiprocessing import Processimport timeimport randomclass Piao(Process): def __init__(self,name): self.name=name super().__init__() def run(self): print(&#x27;%s is piaoing&#x27; %self.name) time.sleep(random.randrange(1,5)) print(&#x27;%s is piao end&#x27; %self.name)p1=Piao(&#x27;egon1&#x27;)p1.start()p1.terminate()#关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活print(p1.is_alive()) #结果为Trueprint(&#x27;开始&#x27;)print(p1.is_alive()) #结果为False name与pid 12345678910111213141516171819202122from multiprocessing import Processimport timeimport randomclass Piao(Process): def __init__(self,name): # self.name=name # super().__init__() #Process的__init__方法会执行self.name=Piao-1, # #所以加到这里,会覆盖我们的self.name=name #为我们开启的进程设置名字的做法 super().__init__() self.name=name def run(self): print(&#x27;%s is piaoing&#x27; %self.name) time.sleep(random.randrange(1,3)) print(&#x27;%s is piao end&#x27; %self.name)p=Piao(&#x27;egon&#x27;)p.start()print(&#x27;开始&#x27;)print(p.pid) #查看pid 僵尸进程与孤儿进程（了解） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111一：僵尸进程（有害） 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。详解如下我们知道在unix/linux中，正常情况下子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束，如果子进程一结束就立刻回收其全部资源，那么在父进程内将无法获取子进程的状态信息。因此，UNⅨ提供了一种机制可以保证父进程可以在任意时刻获取子进程结束时的状态信息：1、在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）2、直到父进程通过wait / waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。 任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。二：孤儿进程（无害） 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。我们来测试一下（创建完子进程后，主进程所在的这个脚本就退出了，当父进程先于子进程结束时，子进程会被init收养，成为孤儿进程，而非僵尸进程），文件内容import osimport sysimport timepid = os.getpid()ppid = os.getppid()print &#x27;im father&#x27;, &#x27;pid&#x27;, pid, &#x27;ppid&#x27;, ppidpid = os.fork()#执行pid=os.fork()则会生成一个子进程#返回值pid有两种值：# 如果返回的pid值为0，表示在子进程当中# 如果返回的pid值&gt;0，表示在父进程当中if pid &gt; 0: print &#x27;father died..&#x27; sys.exit(0)# 保证主线程退出完毕time.sleep(1)print &#x27;im child&#x27;, os.getpid(), os.getppid()执行文件，输出结果：im father pid 32515 ppid 32015father died..im child 32516 1看，子进程已经被pid为1的init进程接收了，所以僵尸进程在这种情况下是不存在的，存在只有孤儿进程而已，孤儿进程声明周期结束自然会被init来销毁。三：僵尸进程危害场景： 例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。四：测试#1、产生僵尸进程的程序test.py内容如下#coding:utf-8from multiprocessing import Processimport time,osdef run(): print(&#x27;子&#x27;,os.getpid())if __name__ == &#x27;__main__&#x27;: p=Process(target=run) p.start() print(&#x27;主&#x27;,os.getpid()) time.sleep(1000)#2、在unix或linux系统上执行[root@vm172-31-0-19 ~]# python3 test.py &amp;[1] 18652[root@vm172-31-0-19 ~]# 主 18652子 18653[root@vm172-31-0-19 ~]# ps aux |grep ZUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 18653 0.0 0.0 0 0 pts/0 Z 20:02 0:00 [python3] &lt;defunct&gt; #出现僵尸进程root 18656 0.0 0.0 112648 952 pts/0 S+ 20:02 0:00 grep --color=auto Z[root@vm172-31-0-19 ~]# top #执行top命令发现1zombietop - 20:03:42 up 31 min, 3 users, load average: 0.01, 0.06, 0.12Tasks: 93 total, 2 running, 90 sleeping, 0 stopped, 1 zombie%Cpu(s): 0.0 us, 0.3 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1016884 total, 97184 free, 70848 used, 848852 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 782540 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND root 20 0 29788 1256 988 S 0.3 0.1 0:01.50 elfin #3、等待父进程正常结束后会调用wait／waitpid去回收僵尸进程但如果父进程是一个死循环，永远不会结束，那么该僵尸进程就会一直存在，僵尸进程过多，就是有害的解决方法一：杀死父进程解决方法二：对开启的子进程应该记得使用join，join会回收僵尸进程参考python2源码注释class Process(object): def join(self, timeout=None): &#x27;&#x27;&#x27; Wait until child process terminates &#x27;&#x27;&#x27; assert self._parent_pid == os.getpid(), &#x27;can only join a child process&#x27; assert self._popen is not None, &#x27;can only join a started process&#x27; res = self._popen.wait(timeout) if res is not None: _current_process._children.discard(self)join方法中调用了wait，告诉系统释放僵尸进程。discard为从自己的children中剔除解决方法三：http://blog.csdn.net/u010571844/article/details/50419798 思考： 1234567891011121314from multiprocessing import Processimport time,osdef task(): print(&#x27;%s is running&#x27; %os.getpid()) time.sleep(3)if __name__ == &#x27;__main__&#x27;: p=Process(target=task) p.start() p.join() # 等待进程p结束后，join函数内部会发送系统调用wait，去告诉操作系统回收掉进程p的id号 print(p.pid) #？？？此时能否看到子进程p的id号 print(&#x27;主&#x27;) 答案 123456789#答案：可以#分析：p.join()是像操作系统发送请求，告知操作系统p的id号不需要再占用了，回收就可以，此时在父进程内还可以看到p.pid,但此时的p.pid是一个无意义的id号，因为操作系统已经将该编号回收打个比方：我党相当于操作系统，控制着整个中国的硬件，每个人相当于一个进程，每个人都需要跟我党申请一个身份证号该号码就相当于进程的pid，人死后应该到我党那里注销身份证号，p.join()就相当于要求我党回收身份证号，但p的家人（相当于主进程）仍然持有p的身份证，但此刻的身份证已经没有意义 4、守护进程主进程创建守护进程 其一：守护进程会在主进程代码执行结束后就终止 其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children 注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止 123456789101112131415161718from multiprocessing import Processimport timeimport randomclass Piao(Process): def __init__(self,name): self.name=name super().__init__() def run(self): print(&#x27;%s is piaoing&#x27; %self.name) time.sleep(random.randrange(1,3)) print(&#x27;%s is piao end&#x27; %self.name)p=Piao(&#x27;egon&#x27;)p.daemon=True #一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行p.start()print(&#x27;主&#x27;) 迷惑人的例子 12345678910111213141516171819202122#主进程代码运行完毕,守护进程就会结束from multiprocessing import Processfrom threading import Threadimport timedef foo(): print(123) time.sleep(1) print(&quot;end123&quot;)def bar(): print(456) time.sleep(3) print(&quot;end456&quot;)p1=Process(target=foo)p2=Process(target=bar)p1.daemon=Truep1.start()p2.start()print(&quot;main-------&quot;) #打印该行则主进程代码结束,则守护进程p1应该被终止,可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止 5、进程同步（锁）进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的, 而共享带来的是竞争，竞争带来的结果就是错乱，如何控制，就是加锁处理 part1：多个进程共享同一打印终端 并发运行,效率高,但竞争同一打印终端,带来了打印错乱 123456789101112#并发运行,效率高,但竞争同一打印终端,带来了打印错乱from multiprocessing import Processimport os,timedef work(): print(&#x27;%s is running&#x27; %os.getpid()) time.sleep(2) print(&#x27;%s is done&#x27; %os.getpid())if __name__ == &#x27;__main__&#x27;: for i in range(3): p=Process(target=work) p.start() 加锁：由并发变成了串行,牺牲了运行效率,但避免了竞争 1234567891011121314#由并发变成了串行,牺牲了运行效率,但避免了竞争from multiprocessing import Process,Lockimport os,timedef work(lock): lock.acquire() print(&#x27;%s is running&#x27; %os.getpid()) time.sleep(2) print(&#x27;%s is done&#x27; %os.getpid()) lock.release()if __name__ == &#x27;__main__&#x27;: lock=Lock() for i in range(3): p=Process(target=work,args=(lock,)) p.start() part2：多个进程共享同一文件 文件当数据库，模拟抢票 并发运行，效率高，但竞争写同一文件，数据写入错乱 12345678910111213141516171819202122232425#文件db的内容为：&#123;&quot;count&quot;:1&#125;#注意一定要用双引号，不然json无法识别from multiprocessing import Process,Lockimport time,json,randomdef search(): dic=json.load(open(&#x27;db.txt&#x27;)) print(&#x27;\\033[43m剩余票数%s\\033[0m&#x27; %dic[&#x27;count&#x27;])def get(): dic=json.load(open(&#x27;db.txt&#x27;)) time.sleep(0.1) #模拟读数据的网络延迟 if dic[&#x27;count&#x27;] &gt;0: dic[&#x27;count&#x27;]-=1 time.sleep(0.2) #模拟写数据的网络延迟 json.dump(dic,open(&#x27;db.txt&#x27;,&#x27;w&#x27;)) print(&#x27;\\033[43m购票成功\\033[0m&#x27;)def task(lock): search() get()if __name__ == &#x27;__main__&#x27;: lock=Lock() for i in range(100): #模拟并发100个客户端抢票 p=Process(target=task,args=(lock,)) p.start() 加锁：购票行为由并发变成了串行，牺牲了运行效率，但保证了数据安全 123456789101112131415161718192021222324252627#文件db的内容为：&#123;&quot;count&quot;:1&#125;#注意一定要用双引号，不然json无法识别from multiprocessing import Process,Lockimport time,json,randomdef search(): dic=json.load(open(&#x27;db.txt&#x27;)) print(&#x27;\\033[43m剩余票数%s\\033[0m&#x27; %dic[&#x27;count&#x27;])def get(): dic=json.load(open(&#x27;db.txt&#x27;)) time.sleep(0.1) #模拟读数据的网络延迟 if dic[&#x27;count&#x27;] &gt;0: dic[&#x27;count&#x27;]-=1 time.sleep(0.2) #模拟写数据的网络延迟 json.dump(dic,open(&#x27;db.txt&#x27;,&#x27;w&#x27;)) print(&#x27;\\033[43m购票成功\\033[0m&#x27;)def task(lock): search() lock.acquire() get() lock.release()if __name__ == &#x27;__main__&#x27;: lock=Lock() for i in range(100): #模拟并发100个客户端抢票 p=Process(target=task,args=(lock,)) p.start() 总结： 1234567891011#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。虽然可以用文件共享数据实现进程间通信，但问题是：1.效率低（共享数据基于文件，而文件是硬盘上的数据）2.需要自己加锁处理#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。1 队列和管道都是将数据存放于内存中2 队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。 6、队列（推荐使用）进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的 创建队列的类（底层就是以管道和锁定的方式实现）： 11 Queue([maxsize]):创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。 参数介绍： 11 maxsize是队列中允许最大项数，省略则无大小限制。 方法介绍： 主要方法： 1234567891 q.put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。2 q.get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常.3 4 q.get_nowait():同q.get(False)5 q.put_nowait():同q.put(False)6 7 q.empty():调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。8 q.full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。9 q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样 其他方法(了解)： 1231 q.cancel_join_thread():不会在进程退出时自动连接后台线程。可以防止join_thread()方法阻塞2 q.close():关闭队列，防止队列中加入更多数据。调用此方法，后台线程将继续写入那些已经入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将调用此方法。关闭队列不会在队列使用者中产生任何类型的数据结束信号或异常。例如，如果某个使用者正在被阻塞在get()操作上，关闭生产者中的队列不会导致get()方法返回错误。3 q.join_thread()：连接队列的后台线程。此方法用于在调用q.close()方法之后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread方法可以禁止这种行为 应用： 1234567891011121314151617181920&#x27;&#x27;&#x27;multiprocessing模块支持进程间通信的两种主要形式:管道和队列都是基于消息传递实现的,但是队列接口&#x27;&#x27;&#x27;from multiprocessing import Process,Queueimport timeq=Queue(3)#put ,get ,put_nowait,get_nowait,full,emptyq.put(3)q.put(3)q.put(3)print(q.full()) #满了print(q.get())print(q.get())print(q.get())print(q.empty()) #空了 生产者消费者模型 在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。 为什么要使用生产者和消费者模式 在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 什么是生产者消费者模式 生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 基于队列实现生产者消费者模型 123456789101112131415161718192021222324252627from multiprocessing import Process,Queueimport time,random,osdef consumer(q): while True: res=q.get() time.sleep(random.randint(1,3)) print(&#x27;\\033[45m%s 吃 %s\\033[0m&#x27; %(os.getpid(),res))def producer(q): for i in range(10): time.sleep(random.randint(1,3)) res=&#x27;包子%s&#x27; %i q.put(res) print(&#x27;\\033[44m%s 生产了 %s\\033[0m&#x27; %(os.getpid(),res))if __name__ == &#x27;__main__&#x27;: q=Queue() #生产者们:即厨师们 p1=Process(target=producer,args=(q,)) #消费者们:即吃货们 c1=Process(target=consumer,args=(q,)) #开始 p1.start() c1.start() print(&#x27;主&#x27;) 生产者消费者模型总结 123456789101112#生产者消费者模型总结 #程序中有两类角色 一类负责生产数据（生产者） 一类负责处理数据（消费者） #引入生产者消费者模型为了解决的问题是： 平衡生产者与消费者之间的工作能力，从而提高程序整体处理数据的速度 #如何实现： 生产者&lt;--&gt;队列&lt;——&gt;消费者 #生产者消费者模型实现类程序的解耦和 此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。 解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环 生产者在生产完毕后发送结束信号None 12345678910111213141516171819202122232425262728from multiprocessing import Process,Queueimport time,random,osdef consumer(q): while True: res=q.get() if res is None:break #收到结束信号则结束 time.sleep(random.randint(1,3)) print(&#x27;\\033[45m%s 吃 %s\\033[0m&#x27; %(os.getpid(),res))def producer(q): for i in range(10): time.sleep(random.randint(1,3)) res=&#x27;包子%s&#x27; %i q.put(res) print(&#x27;\\033[44m%s 生产了 %s\\033[0m&#x27; %(os.getpid(),res)) q.put(None) #发送结束信号if __name__ == &#x27;__main__&#x27;: q=Queue() #生产者们:即厨师们 p1=Process(target=producer,args=(q,)) #消费者们:即吃货们 c1=Process(target=consumer,args=(q,)) #开始 p1.start() c1.start() print(&#x27;主&#x27;) 注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号 主进程在生产者生产完毕后发送结束信号None 12345678910111213141516171819202122232425262728293031from multiprocessing import Process,Queueimport time,random,osdef consumer(q): while True: res=q.get() if res is None:break #收到结束信号则结束 time.sleep(random.randint(1,3)) print(&#x27;\\033[45m%s 吃 %s\\033[0m&#x27; %(os.getpid(),res))def producer(q): for i in range(2): time.sleep(random.randint(1,3)) res=&#x27;包子%s&#x27; %i q.put(res) print(&#x27;\\033[44m%s 生产了 %s\\033[0m&#x27; %(os.getpid(),res))if __name__ == &#x27;__main__&#x27;: q=Queue() #生产者们:即厨师们 p1=Process(target=producer,args=(q,)) #消费者们:即吃货们 c1=Process(target=consumer,args=(q,)) #开始 p1.start() c1.start() p1.join() q.put(None) #发送结束信号 print(&#x27;主&#x27;) 但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决 有几个消费者就需要发送几次结束信号：相当low 1234567891011121314151617181920212223242526272829303132333435363738394041from multiprocessing import Process,Queueimport time,random,osdef consumer(q): while True: res=q.get() if res is None:break #收到结束信号则结束 time.sleep(random.randint(1,3)) print(&#x27;\\033[45m%s 吃 %s\\033[0m&#x27; %(os.getpid(),res))def producer(name,q): for i in range(2): time.sleep(random.randint(1,3)) res=&#x27;%s%s&#x27; %(name,i) q.put(res) print(&#x27;\\033[44m%s 生产了 %s\\033[0m&#x27; %(os.getpid(),res))if __name__ == &#x27;__main__&#x27;: q=Queue() #生产者们:即厨师们 p1=Process(target=producer,args=(&#x27;包子&#x27;,q)) p2=Process(target=producer,args=(&#x27;骨头&#x27;,q)) p3=Process(target=producer,args=(&#x27;泔水&#x27;,q)) #消费者们:即吃货们 c1=Process(target=consumer,args=(q,)) c2=Process(target=consumer,args=(q,)) #开始 p1.start() p2.start() p3.start() c1.start() p1.join() #必须保证生产者全部生产完毕,才应该发送结束信号 p2.join() p3.join() q.put(None) #有几个消费者就应该发送几次结束信号None q.put(None) #发送结束信号 print(&#x27;主&#x27;) 其实我们的思路无非是发送结束信号而已，有另外一种队列提供了这种机制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#JoinableQueue([maxsize])：这就像是一个Queue对象，但队列允许项目的使用者通知生成者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。 #参数介绍： maxsize是队列中允许最大项数，省略则无大小限制。 #方法介绍： JoinableQueue的实例p除了与Queue对象相同的方法之外还具有： q.task_done()：使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常 q.join():生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止from multiprocessing import Process,JoinableQueueimport time,random,osdef consumer(q): while True: res=q.get() time.sleep(random.randint(1,3)) print(&#x27;\\033[45m%s 吃 %s\\033[0m&#x27; %(os.getpid(),res)) q.task_done() #向q.join()发送一次信号,证明一个数据已经被取走了def producer(name,q): for i in range(10): time.sleep(random.randint(1,3)) res=&#x27;%s%s&#x27; %(name,i) q.put(res) print(&#x27;\\033[44m%s 生产了 %s\\033[0m&#x27; %(os.getpid(),res)) q.join()if __name__ == &#x27;__main__&#x27;: q=JoinableQueue() #生产者们:即厨师们 p1=Process(target=producer,args=(&#x27;包子&#x27;,q)) p2=Process(target=producer,args=(&#x27;骨头&#x27;,q)) p3=Process(target=producer,args=(&#x27;泔水&#x27;,q)) #消费者们:即吃货们 c1=Process(target=consumer,args=(q,)) c2=Process(target=consumer,args=(q,)) c1.daemon=True c2.daemon=True #开始 p_l=[p1,p2,p3,c1,c2] for p in p_l: p.start() p1.join() p2.join() p3.join() print(&#x27;主&#x27;) #主进程等---&gt;p1,p2,p3等----&gt;c1,c2 #p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据 #因而c1,c2也没有存在的价值了,应该随着主进程的结束而结束,所以设置成守护进程 7、管道进程间通信（IPC）方式二：管道（不推荐使用，了解即可） 介绍 12345678910111213141516#创建管道的类：Pipe([duplex]):在进程之间创建一条管道，并返回元组（conn1,conn2）,其中conn1，conn2表示管道两端的连接对象，强调一点：必须在产生Process对象之前产生管道#参数介绍：dumplex:默认管道是全双工的，如果将duplex射成False，conn1只能用于接收，conn2只能用于发送。#主要方法： conn1.recv():接收conn2.send(obj)发送的对象。如果没有消息可接收，recv方法会一直阻塞。如果连接的另外一端已经关闭，那么recv方法会抛出EOFError。 conn1.send(obj):通过连接发送对象。obj是与序列化兼容的任意对象 #其他方法：conn1.close():关闭连接。如果conn1被垃圾回收，将自动调用此方法conn1.fileno():返回连接使用的整数文件描述符conn1.poll([timeout]):如果连接上的数据可用，返回True。timeout指定等待的最长时限。如果省略此参数，方法将立即返回结果。如果将timeout射成None，操作将无限期地等待数据到达。conn1.recv_bytes([maxlength]):接收c.send_bytes()方法发送的一条完整的字节消息。maxlength指定要接收的最大字节数。如果进入的消息，超过了这个最大值，将引发IOError异常，并且在连接上无法进行进一步读取。如果连接的另外一端已经关闭，再也不存在任何数据，将引发EOFError异常。conn.send_bytes(buffer [, offset [, size]])：通过连接发送字节数据缓冲区，buffer是支持缓冲区接口的任意对象，offset是缓冲区中的字节偏移量，而size是要发送字节数。结果数据以单条消息的形式发出，然后调用c.recv_bytes()函数进行接收 conn1.recv_bytes_into(buffer [, offset]):接收一条完整的字节消息，并把它保存在buffer对象中，该对象支持可写入的缓冲区接口（即bytearray对象或类似的对象）。offset指定缓冲区中放置消息处的字节位移。返回值是收到的字节数。如果消息长度大于可用的缓冲区空间，将引发BufferTooShort异常。 基于管道实现进程间通信（与队列的方式是类似的，队列就是管道加锁实现的） 12345678910111213141516171819202122232425262728293031from multiprocessing import Process,Pipeimport time,osdef consumer(p,name): left,right=p left.close() while True: try: baozi=right.recv() print(&#x27;%s 收到包子:%s&#x27; %(name,baozi)) except EOFError: right.close() breakdef producer(seq,p): left,right=p right.close() for i in seq: left.send(i) # time.sleep(1) else: left.close()if __name__ == &#x27;__main__&#x27;: left,right=Pipe() c1=Process(target=consumer,args=((left,right),&#x27;c1&#x27;)) c1.start() seq=(i for i in range(10)) producer(seq,(left,right)) right.close() left.close() c1.join() print(&#x27;主进程&#x27;) *注意：生产者和消费者都没有使用管道的某个端点，就应该将其关闭，如在生产者中关闭管道的右端，在消费者中关闭管道的左端。如果忘记执行这些步骤，程序可能再消费者中的recv*()*操作上挂起。管道是由操作系统进行引用计数的,必须在所有进程中关闭管道后才能生产EOFError异常。因此在生产者中关闭管道不会有任何效果，付费消费者中也关闭了相同的管道端点。* 管道可以用于双向通信，利用通常在客户端&#x2F;服务器中使用的请求／响应模型或远程过程调用，就可以使用管道编写与进程交互的程序 123456789101112131415161718192021222324252627282930from multiprocessing import Process,Pipeimport time,osdef adder(p,name): server,client=p client.close() while True: try: x,y=server.recv() except EOFError: server.close() break res=x+y server.send(res) print(&#x27;server done&#x27;)if __name__ == &#x27;__main__&#x27;: server,client=Pipe() c1=Process(target=adder,args=((server,client),&#x27;c1&#x27;)) c1.start() server.close() client.send((10,20)) print(client.recv()) client.close() c1.join() print(&#x27;主进程&#x27;)#注意：send()和recv()方法使用pickle模块对对象进行序列化。 8、共享数据展望未来，基于消息传递的并发编程是大势所趋 即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合 通过消息队列交换数据。这样极大地减少了对使用锁定和其他同步手段的需求， 还可以扩展到分布式系统中 进程间通信应该尽量避免使用本节所讲的共享数据的方式 1234567进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的虽然进程间数据独立，但可以通过Manager实现数据共享，事实上Manager的功能远不止于此A manager object returned by Manager() controls a server process which holds Python objects and allows other processes to manipulate them using proxies.A manager returned by Manager() will support types list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array. For example, 进程之间操作共享的数据 12345678910111213141516171819from multiprocessing import Manager,Process,Lockimport osdef work(d,lock): # with lock: #不加锁而操作共享的数据,肯定会出现数据错乱 d[&#x27;count&#x27;]-=1if __name__ == &#x27;__main__&#x27;: lock=Lock() with Manager() as m: dic=m.dict(&#123;&#x27;count&#x27;:100&#125;) p_l=[] for i in range(100): p=Process(target=work,args=(dic,lock)) p_l.append(p) p.start() for p in p_l: p.join() print(dic) #&#123;&#x27;count&#x27;: 94&#125; 9、信号量（了解）信号量Semahpore（同线程一样） 123456789101112131415161718192021222324互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去，如果指定信号量为3，那么来一个人获得一把锁，计数加1，当计数等于3时，后面的人均需要等待。一旦释放，就有人可以获得一把锁 信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念from multiprocessing import Process,Semaphoreimport time,randomdef go_wc(sem,user): sem.acquire() print(&#x27;%s 占到一个茅坑&#x27; %user) time.sleep(random.randint(0,3)) #模拟每个人拉屎速度不一样，0代表有的人蹲下就起来了 sem.release()if __name__ == &#x27;__main__&#x27;: sem=Semaphore(5) p_l=[] for i in range(13): p=Process(target=go_wc,args=(sem,&#x27;user%s&#x27; %i,)) p.start() p_l.append(p) for i in p_l: i.join() print(&#x27;============》&#x27;) 10、事件（了解）Event（同线程一样） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455python线程的事件用于主线程控制其他线程的执行，事件主要提供了三个方法 set、wait、clear。 事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。clear：将“Flag”设置为Falseset：将“Flag”设置为True#_*_coding:utf-8_*_#!/usr/bin/env pythonfrom multiprocessing import Process,Eventimport time,randomdef car(e,n): while True: if not e.is_set(): #Flase print(&#x27;\\033[31m红灯亮\\033[0m，car%s等着&#x27; %n) e.wait() print(&#x27;\\033[32m车%s 看见绿灯亮了\\033[0m&#x27; %n) time.sleep(random.randint(3,6)) if not e.is_set(): continue print(&#x27;走你,car&#x27;, n) breakdef police_car(e,n): while True: if not e.is_set(): print(&#x27;\\033[31m红灯亮\\033[0m，car%s等着&#x27; % n) e.wait(1) print(&#x27;灯的是%s，警车走了,car %s&#x27; %(e.is_set(),n)) breakdef traffic_lights(e,inverval): while True: time.sleep(inverval) if e.is_set(): e.clear() #e.is_set() ----&gt;False else: e.set()if __name__ == &#x27;__main__&#x27;: e=Event() # for i in range(10): # p=Process(target=car,args=(e,i,)) # p.start() for i in range(5): p = Process(target=police_car, args=(e, i,)) p.start() t=Process(target=traffic_lights,args=(e,10)) t.start() print(&#x27;============》&#x27;) 11、进程池在利用Python进行系统管理的时候，特别是同时操作多个文件目录，或者远程控制多台主机，并行操作可以节约大量的时间。多进程是实现并发的手段之一，需要注意的问题是： 1、很明显需要并发执行的任务通常要远大于核数 2、一个操作系统不可能无限开启进程，通常有几个核就开几个进程 3、进程开启过多，效率反而会下降（开启进程是需要占用资源的，而且开启多余核数目的进程也无法做到并行） 例如当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态生成多个进程，十几个还好，但如果是上百个上千个，手动的去限制进程数量却又过于繁琐，此时可以发挥进程池的功效。 我们就可以通过一个进程池来控制进程数目，比如http的进程模式，规定最小进程数和最大进程数。。。 ps：对于远程过程调用的高级应用程序而言，比如使用进程池，Pool可以提供指定数目的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，就重用进程池中的进程。 创建进程池的类：如果指定numprocess为3，则进程池会从无到有创建三个进程，然后至始至终使用这三个进程去执行所有任务，不会开启其他进程 1Pool([numprocess [,initializer [, initargs]]]):创建进程池 参数介绍 123numprocess:要创建的进程数，如果省略，将默认使用cpu_count()的值initializer:是每个工作进程启动时要执行的可调用对象，默认为Noneinitargs:是要传给initializer的参数组 方法介绍： 12345p.apply(func[, args[, kwargs]]):在一个池工作进程中执行func(*args,**kwargs)，然后返回结果。需要强调的是，此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()p.apply_async(func [func [, args [, kwargs]]]):在一个池工作进程中执行func(*args,**kwargs),然后返回结果。此方法的结果是AsynResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。p.close():关闭进程池，防止进一步操作。如果所有操作持续挂起，他们将在工作进程终止前完成p.join()：等待所有工作进程退出，此放大只能在close()或reminate()之后调用","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"33、Python并发编程之多进程（理论）","slug":"33、python并发编程之多进程（理论篇）","date":"2018-05-13T06:04:33.000Z","updated":"2022-05-13T12:29:03.574Z","comments":true,"path":"2018/05/13/33、python并发编程之多进程（理论篇）/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/33%E3%80%81python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89/","excerpt":"","text":"目录： 一 什么是进程 二 进程与程序的区别 三 并发与并行 四 同步\\异步and阻塞\\非阻塞（重点） 五 进程的创建（了解） 六 进程的终止（了解） 七 进程的层次结构 八 进程的状态 九 进程并发的实现（了解） 一 什么是进程进程：正在运行的一个过程或者说一个任务。而负责执行任务则是cpu。 举例：（单核+多道，实现多个进程的并发执行） egon在一个时间段内有很多任务要做：python备课的任务，写书的任务，交女朋友的任务，王者荣耀上分的任务， 但egon同一时刻只能做一个任务（cpu同一时间只能干一个活），如何才能玩出多个任务并发执行的效果？ egon备一会课，再去跟李杰的女朋友聊聊天，再去打一会王者荣耀….这就保证了每个任务都在进行中. 二 进程与程序的区别程序仅仅只是一堆代码而已，而进程指的是程序的运行过程。 举例： 想象一位有一手好厨艺的计算机科学家egon正在为他的女儿元昊烘制生日蛋糕。 他有做生日蛋糕的食谱， 厨房里有所需的原料:面粉、鸡蛋、韭菜，蒜泥等。 在这个比喻中： 做蛋糕的食谱就是程序(即用适当形式描述的算法) 计算机科学家就是处理器(cpu) 而做蛋糕的各种原料就是输入数据。 进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和。 现在假设计算机科学家egon的儿子alex哭着跑了进来，说：XXXXXXXXXXXXXX。 科学家egon想了想，处理儿子alex蛰伤的任务比给女儿元昊做蛋糕的任务更重要，于是 计算机科学家就记录下他照着食谱做到哪儿了(保存进程的当前状态)，然后拿出一本急救手册，按照其中的指示处理蛰伤。这里，我们看到处理机从一个进程(做蛋糕)切换到另一个高优先级的进程(实施医疗救治)，每个进程拥有各自的程序(食谱和急救手册)。当蜜蜂蛰伤处理完之后，这位计算机科学家又回来做蛋糕，从他 离开时的那一步继续做下去。 需要强调的是：同一个程序执行两次，那也是两个进程，比如打开暴风影音，虽然都是同一个软件，但是一个可以播放苍井空，一个可以播放饭岛爱。 三 并发与并行无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真正干活的是cpu，cpu来做这些任务，而一个cou同一时刻只能执行一个任务 一 并发：是伪并行，即看起来是同时运行。单个cou+多道技术就可以实现并发（并行也属于并发） 单cpu多进程，并发举例1： 1234你是一个cpu，你同时谈了三个女朋友，每一个都可以是一个恋爱任务，你被这三个任务共享要玩出并发恋爱的效果，应该是你先跟女友1去看电影，看了一会说：不好，我要拉肚子，然后跑去跟第二个女友吃饭，吃了一会说：那啥，我去趟洗手间，然后跑去跟女友3开了个房 单cpu多进程，并发举例2： 123456某天下午，egon，yuanhao，wupeiqi，alex约好了一起去嫖娼，但娼只有一个，cpu只有一个，但是却要‘同时’干四个任务(嫖出并发的效果)，那就必须是干一会egon，再干一会yuanhao，再干一会wupeiqi，再干一会alexegon：花了200块钱，因为人美活好yuanhao：500块钱wupeiqi：100块钱，可能是不太行alex：没要钱，为啥？？？因为大家刚刚嫖的是他女朋友 二 并行：同时运行，只有具备多个cpu才能实现并行 单核下，可以利用多道技术，多个核，每个核也都可以利用多道技术（躲到技术是针对单核而言的） 有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4，一旦任务1遇到I&#x2F;O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术 而，一旦任务1的I&#x2F;O结束了，操作系统会重新调用它（需知进程的调度、分配给哪个cpu运行，由操作系统说了算），可能被分配给四个cpu的任意一个去执行 所有现代计算机经常会在同一时间做很多件事，一个用户的PC（无论是单cpu还是多cpu），都可以同时运行多个任务（一个任务可以理解为一个进程）。 启动一个进程来杀毒（360软件） 启动一个进程来看电影（暴风影音） 启动一个进程来聊天（腾讯QQ） 所有的这些进程都需被管理，于是一个支持多进程的多道程序系统是至关重要的 多道技术概念回顾：内存中同时存入多道程序，cpu从一个进程快速切换到另外一个，使每个进程各自运行几十或几百毫秒，这样，虽然在某一个瞬间，一个cpu只能执行一个任务，但在1秒内，cpu却可以运行多个进程，这就给人产生了并行的错觉，即伪并发，以此来区分多处理器操作系统的真正硬件并行（多个cpu共享同一个物理内存） 四 同步\\异步and阻塞\\非阻塞（重点）同步： 12345#所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不会返回。按照这个定义，其实绝大多数函数都是同步调用。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。#举例：#1. multiprocessing.Pool下的apply #发起同步调用后，就在原地等着任务结束，根本不考虑任务是在计算还是在io阻塞，总之就是一股脑地等任务结束#2. concurrent.futures.ProcessPoolExecutor().submit(func,).result()#3. concurrent.futures.ThreadPoolExecutor().submit(func,).result() 异步： 12345#异步的概念和同步相对。当一个异步功能调用发出后，调用者不能立刻得到结果。当该异步功能完成后，通过状态、通知或回调来通知调用者。如果异步功能用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一 种很严重的错误）。如果是使用通知的方式，效率则很高，因为异步功能几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。#举例：#1. multiprocessing.Pool().apply_async() #发起异步调用后，并不会等待任务结束才返回，相反，会立即获取一个临时结果（并不是最终的结果，可能是封装好的一个对象）。#2. concurrent.futures.ProcessPoolExecutor(3).submit(func,)#3. concurrent.futures.ThreadPoolExecutor(3).submit(func,) 阻塞： 1234#阻塞调用是指调用结果返回之前，当前线程会被挂起（如遇到io操作）。函数只有在得到结果之后才会将阻塞的线程激活。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。#举例：#1. 同步调用：apply一个累计1亿次的任务，该调用会一直等待，直到任务返回结果为止，但并未阻塞住（即便是被抢走cpu的执行权限，那也是处于就绪态）;#2. 阻塞调用：当socket工作在阻塞模式的时候，如果没有数据的情况下调用recv函数，则当前线程就会被挂起，直到有数据为止。 非阻塞： 1#非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前也会立刻返回，同时该函数不会阻塞当前线程。 小结： 123#1. 同步与异步针对的是函数/任务的调用方式：同步就是当一个进程发起一个函数（任务）调用的时候，一直等到函数（任务）完成，而进程继续处于激活状态。而异步情况下是当一个进程发起一个函数（任务）调用的时候，不会等函数返回，而是继续往下执行当，函数返回的时候通过状态、通知、事件等方式通知进程任务完成。#2. 阻塞与非阻塞针对的是进程或线程：阻塞是当请求不能满足的时候就将进程挂起，而非阻塞则不会阻塞当前进程 五 进程的创建（了解）但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。 而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4中形式创建新的进程 \\1. 系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印） \\2. 一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等） \\3. 用户的交互式请求，而创建一个新进程（如用户双击暴风影音） \\4. 一个批处理作业的初始化（只在大型机的批处理系统中应用） 无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的： \\1. 在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程） \\2. 在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。 关于创建的子进程，UNIX和windows 1.相同的是：进程创建后，父进程和子进程有各自不同的地址空间（多道技术要求物理层面实现进程之间内存的隔离），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。 2.不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。 六 进程的终止（了解）\\1. 正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess） \\2. 出错退出（自愿，python a.py中a.py不存在） \\3. 严重错误（非自愿，执行非法指令，如引用不存在的内存，1&#x2F;0等，可以捕捉异常，try…except…） \\4. 被其他进程杀死（非自愿，如kill -9） 七 进程的层次结构无论UNIX还是windows，进程只有一个父进程，不同的是： \\1. 在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。 \\2. 在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（称为句柄）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。 八 进程的状态1tail -f access.log |grep &#x27;404&#x27; 执行程序tail，开启一个子进程，执行程序grep，开启另外一个子进程，两个进程之间基于管道’|’通讯，将tail的结果作为grep的输入。 进程grep在等待输入（即I&#x2F;O）时的状态称为阻塞，此时grep命令都无法运行 其实在两种情况下会导致一个进程在逻辑上不能运行， \\1. 进程挂起是自身原因，遇到I&#x2F;O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作 \\2. 与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。 因而一个进程由三种状态 九 进程并发的实现（了解）进程并发的实现在于，硬件中断一个正在运行的进程，把此时进程运行的所有状态保存下来，为此，操作系统维护一张表格，即进程表（process table），每个进程占用一个进程表项（这些表项也称为进程控制块） 该表存放了进程状态的重要信息：程序计数器、堆栈指针、内存分配状况、所有打开文件的状态、帐号和调度信息，以及其他在进程由运行态转为就绪态或阻塞态时，必须保存的信息，从而保证该进程在再次启动时，就像从未被中断过一样。","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"32、Python并发编程背景知识","slug":"32、python并发编程之背景知识","date":"2018-05-13T06:04:32.000Z","updated":"2022-05-13T12:28:57.563Z","comments":true,"path":"2018/05/13/32、python并发编程之背景知识/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/32%E3%80%81python%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86/","excerpt":"","text":"目录： 一 引子 二 为什么要有操作系统 三 什么是操作系统 四 操作系统与普通软件的区别 五 操作系统发展史 六 总结视频链接： 一 引子顾名思义，进程即正在执行的一个过程。进程是对正在运行程序的一个抽象。 进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老也是最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。 所以想要真正了解进程，必须事先了解操作系统 二 为什么要有操作系统现代的计算机系统主要是由一个或者多个处理器，主存，硬盘，键盘，鼠标，显示器，打印机，网络接口及其他输入输出设备组成。 一般而言，现代计算机系统是一个复杂的系统。 其一：如果每位应用程序员都必须掌握该系统所有的细节，那就不可能再编写代码了（严重影响了程序员的开发效率：全部掌握这些细节可能需要一万年….） 其二：并且管理这些部件并加以优化使用，是一件极富挑战性的工作，于是，计算安装了一层软件（系统软件），称为操作系统。它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。 总结： 程序员无法把所有的硬件操作细节都了解到，管理这些硬件并且加以优化使用是非常繁琐的工作，这个繁琐的工作就是操作系统来干的，有了他，程序员就从这些繁琐的工作中解脱了出来，只需要考虑自己的应用软件的编写就可以了，应用软件直接使用操作系统提供的功能来间接使用硬件。 三 什么是操作系统精简的说的话，操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序。操作系统所处的位置如图1 1#操作系统位于计算机硬件与应用软件之间，本质也是一个软件。操作系统由操作系统的内核（运行于内核态，管理硬件资源）以及系统调用（运行于用户态，为应用程序员写的应用程序提供系统调用接口）两部分组成，所以，单纯的说操作系统是运行于内核态的，是不准确的。 图1 细说的话，操作系统应该分成两部分功能： 12345#一：隐藏了丑陋的硬件调用接口，为应用程序员提供调用硬件资源的更好，更简单，更清晰的模型（系统调用接口）。应用程序员有了这些接口后，就不用再考虑操作硬件的细节，专心开发自己的应用程序即可。例如：操作系统提供了文件这个抽象概念，对文件的操作就是对磁盘的操作，有了文件我们无需再去考虑关于磁盘的读写控制（比如控制磁盘转动，移动磁头读写数据等细节），#二：将应用程序对硬件资源的竞态请求变得有序化例如：很多应用软件其实是共享一套计算机硬件，比方说有可能有三个应用程序同时需要申请打印机来输出内容，那么a程序竞争到了打印机资源就打印，然后可能是b竞争到打印机资源，也可能是c，这就导致了无序，打印机可能打印一段a的内容然后又去打印c...,操作系统的一个功能就是将这种无序变得有序。 详解 1234567891011121314151617181920212223242526272829现代计算机或者网络都是多用户的，多个用户不仅共享硬件，而且共享文件，数据库等信息，共享意味着冲突和无序。操作系统主要使用来1.记录哪个程序使用什么资源2.对资源请求进行分配3.为不同的程序和用户调解互相冲突的资源请求。我们可将上述操作系统的功能总结为：处理来自多个程序发起的多个（多个即多路）共享（共享即复用）资源的请求，简称多路复用多路复用有两种实现方式1.时间上的复用当一个资源在时间上复用时，不同的程序或用户轮流使用它，第一个程序获取该资源使用结束后，在轮到第二个。。。第三个。。。例如：只有一个cpu，多个程序需要在该cpu上运行，操作系统先把cpu分给第一个程序，在这个程序运行的足够长的时间（时间长短由操作系统的算法说了算）或者遇到了I/O阻塞，操作系统则把cpu分配给下一个程序，以此类推，直到第一个程序重新被分配到了cpu然后再次运行，由于cpu的切换速度很快，给用户的感觉就是这些程序是同时运行的，或者说是并发的，或者说是伪并行的。至于资源如何实现时间复用，或者说谁应该是下一个要运行的程序，以及一个任务需要运行多长时间，这些都是操作系统的工作。2.空间上的复用每个客户都获取了一个大的资源中的一小部分资源，从而减少了排队等待资源的时间。例如：多个运行的程序同时进入内存，硬件层面提供保护机制来确保各自的内存是分割开的，且由操作系统控制，这比一个程序独占内存一个一个排队进入内存效率要高的多。有关空间复用的其他资源还有磁盘，在许多系统中，一个磁盘同时为许多用户保存文件。分配磁盘空间并且记录谁正在使用哪个磁盘块是操作系统资源管理的典型任务。这两种方式合起来便是多道技术 图 2 四 操作系统与普通软件的区别1.主要区别是：你不想用暴风影音了你可以选择用迅雷播放器或者干脆自己写一个，但是你无法写一个属于操作系统一部分的程序（时钟中断处理程序），操作系统由硬件保护，不能被用户修改。 2.操作系统与用户程序的差异并不在于二者所处的地位。特别地，操作系统是一个大型、复杂、长寿的软件， 大型：linux或windows的源代码有五百万行数量级。按照每页50行共1000行的书来算，五百万行要有100卷，要用一整个书架子来摆置，这还仅仅是内核部分。用户程序，如GUI，库以及基本应用软件（如windows Explorer等），很容易就能达到这个数量的10倍或者20倍之多。 长寿：操作系统很难编写，如此大的代码量，一旦完成，操作系统所有者便不会轻易扔掉，再写一个。而是在原有的基础上进行改进。（基本上可以把windows95&#x2F;98&#x2F;Me看出一个操作系统，而windows NT&#x2F;2000&#x2F;XP&#x2F;Vista则是两位一个操作系统，对于用户来说它们十分相似。还有UNIX以及它的变体和克隆版本也演化了多年，如System V版，Solaris以及FreeBSD等都是Unix的原始版，不过尽管linux非常依照UNIX模式而仿制，并且与UNIX高度兼容，但是linux具有全新的代码基础） 五 操作系统发展史第一代计算机（1940~1955）：真空管和穿孔卡片 第一代计算机的产生背景： 第一代之前人类是想用机械取代人力，第一代计算机的产生是计算机由机械时代进入电子时代的标志，从Babbage失败之后一直到第二次世界大战，数字计算机的建造几乎没有什么进展，第二次世界大战刺激了有关计算机研究的爆炸性进展。 lowa州立大学的john Atanasoff教授和他的学生Clifford Berry建造了据认为是第一台可工作的数字计算机。该机器使用300个真空管。大约在同时，Konrad Zuse在柏林用继电器构建了Z3计算机，英格兰布莱切利园的一个小组在1944年构建了Colossus，Howard Aiken在哈佛大学建造了Mark 1，宾夕法尼亚大学的William Mauchley和他的学生J.Presper Eckert建造了ENIAC。这些机器有的是二进制的，有的使用真空管，有的是可编程的，但都非常原始，设置需要花费数秒钟时间才能完成最简单的运算。 在这个时期，同一个小组里的工程师们，设计、建造、编程、操作及维护同一台机器，所有的程序设计是用纯粹的机器语言编写的，甚至更糟糕，需要通过成千上万根电缆接到插件板上连成电路来控制机器的基本功能。没有程序设计语言（汇编也没有），操作系统则是从来都没听说过。使用机器的过程更加原始，详见下‘工作过程’ 特点： 没有操作系统的概念 所有的程序设计都是直接操控硬件 工作过程： 程序员在墙上的机时表预约一段时间，然后程序员拿着他的插件版到机房里，将自己的插件板街道计算机里，这几个小时内他独享整个计算机资源，后面的一批人都得等着(两万多个真空管经常会有被烧坏的情况出现)。 后来出现了穿孔卡片，可以将程序写在卡片上，然后读入机而不用插件板 优点： 程序员在申请的时间段内独享整个资源，可以即时地调试自己的程序（有bug可以立刻处理） 缺点： 浪费计算机资源，一个时间段内只有一个人用。 注意：同一时刻只有一个程序在内存中，被cpu调用执行，比方说10个程序的执行，是串行的 **第二代计算机*（1955~1965）*：晶体管和批处理系统 第二代计算机的产生背景： 由于当时的计算机非常昂贵，自认很自然的想办法较少机时的浪费。通常采用的方法就是批处理系统。 特点： 设计人员、生产人员、操作人员、程序人员和维护人员直接有了明确的分工，计算机被锁在专用空调房间中，由专业操作人员运行，这便是‘大型机’。 有了操作系统的概念 有了程序设计语言：FORTRAN语言或汇编语言，写到纸上，然后穿孔打成卡片，再讲卡片盒带到输入室，交给操作员，然后喝着咖啡等待输出接口 工作过程：插图 第二代如何解决第一代的问题&#x2F;缺点： 1.把一堆人的输入攒成一大波输入， 2.然后顺序计算（这是有问题的，但是第二代计算也没有解决） 3.把一堆人的输出攒成一大波输出 现代操作系统的前身:(见图） 优点：批处理，节省了机时 缺点： 1.整个流程需要人参与控制，将磁带搬来搬去（中间俩小人） 2.计算的过程仍然是顺序计算-》串行 3.程序员原来独享一段时间的计算机，现在必须被统一规划到一批作业中，等待结果和重新调试的过程都需要等同批次的其他程序都运作完才可以（这极大的影响了程序的开发效率，无法及时调试程序） **第三代计算机*（1965~1980）*：集成电路芯片和多道程序设计 第三代计算机的产生背景： 20世纪60年代初期，大多数计算机厂商都有两条完全不兼容的生产线。 一条是面向字的：大型的科学计算机，如IBM 7094，见上图，主要用于科学计算和工程计算 另外一条是面向字符的：商用计算机，如IBM 1401，见上图，主要用于银行和保险公司从事磁带归档和打印服务 开发和维护完全不同的产品是昂贵的，同时不同的用户对计算机的用途不同。 IBM公司试图通过引入system&#x2F;360系列来同时满足科学计算和商业计算，360系列低档机与1401相当，高档机比7094功能强很多，不同的性能卖不同的价格 360是第一个采用了（小规模）芯片（集成电路）的主流机型，与采用晶体管的第二代计算机相比，性价比有了很大的提高。这些计算机的后代仍在大型的计算机中心里使用，此乃现在服务器的前身，这些服务器每秒处理不小于千次的请求。 如何解决第二代计算机的问题1： 卡片被拿到机房后能够很快的将作业从卡片读入磁盘，于是任何时刻当一个作业结束时，操作系统就能将一个作业从磁带读出，装进空出来的内存区域运行，这种技术叫做 同时的外部设备联机操作：SPOOLING，该技术同时用于输出。当采用了这种技术后，就不在需要IBM1401机了，也不必将磁带搬来搬去了（中间俩小人不再需要） 如何解决第二代计算机的问题2： 第三代计算机的操作系统广泛应用了第二代计算机的操作系统没有的关键技术：多道技术 *cpu在执行一个任务的过程中，若需要操作硬盘，则发送操作硬盘的指令，指令一旦发出，硬盘上的机械手臂滑动读取数据到内存中，这一段时间，cpu需要等待，时间可能很短，但对于cpu来说已经很长很长，长到可以让cpu做很多其他的任务，如果我们让cpu在这段时间内切换到去做其他的任务，这样cpu不就充分利用了吗。这正是多道技术产生的技术背景* 多道技术： 多道技术中的多道指的是多个程序，多道技术的实现是为了解决多个程序竞争或者说共享同一个资源（比如cpu）的有序调度问题，解决方式即多路复用，多路复用分为时间上的复用和空间上的复用。 空间上的复用：将内存分为几部分，每个部分放入一个程序，这样，同一时间内存中就有了多道程序。 时间上的复用：当一个程序在等待I&#x2F;O时，另一个程序可以使用cpu，如果内存中可以同时存放足够多的作业，则cpu的利用率可以接近100%，类似于我们小学数学所学的统筹方法。（操作系统采用了多道技术后，可以控制进程的切换，或者说进程之间去争抢cpu的执行权限。这种切换不仅会在一个进程遇到io时进行，一个进程占用cpu时间过长也会切换，或者说被操作系统夺走cpu的执行权限） 详解 空间上的复用最大的问题是：程序之间的内存必须分割，这种分割需要在硬件层面实现，由操作系统控制。如果内存彼此不分割，则一个程序可以访问另外一个程序的内存， 首先丧失的是安全性，比如你的qq程序可以访问操作系统的内存，这意味着你的qq可以拿到操作系统的所有权限。 其次丧失的是稳定性，某个程序崩溃时有可能把别的程序的内存也给回收了，比方说把操作系统的内存给回收了，则操作系统崩溃。 第三代计算机的操作系统仍然是批处理 许多程序员怀念第一代独享的计算机，可以即时调试自己的程序。为了满足程序员们很快可以得到响应，出现了分时操作系统 如何解决第二代计算机的问题3： 分时操作系统： 多个联机终端+多道技术 20个客户端同时加载到内存，有17在思考，3个在运行，cpu就采用多道的方式处理内存中的这3个程序，由于客户提交的一般都是简短的指令而且很少有耗时长的，索引计算机能够为许多用户提供快速的交互式服务，所有的用户都以为自己独享了计算机资源 CTTS：麻省理工（MIT）在一台改装过的7094机上开发成功的，CTSS兼容分时系统，第三代计算机广泛采用了必须的保护硬件（程序之间的内存彼此隔离）之后，分时系统才开始流行 MIT，贝尔实验室和通用电气在CTTS成功研制后决定开发能够同时支持上百终端的MULTICS（其设计者着眼于建造满足波士顿地区所有用户计算需求的一台机器），很明显真是要上天啊，最后摔死了。 后来一位参加过MULTICS研制的贝尔实验室计算机科学家Ken Thompson开发了一个简易的，单用户版本的MULTICS，这就是后来的UNIX系统。基于它衍生了很多其他的Unix版本，为了使程序能在任何版本的unix上运行，IEEE提出了一个unix标准，即posix（可移植的操作系统接口Portable Operating System Interface） 后来，在1987年，出现了一个UNIX的小型克隆，即minix，用于教学使用。芬兰学生Linus Torvalds基于它编写了Linux 第四代计算机*（1980~至今）：个人计算机* PS：即使可以利用的cpu只有一个（早期的计算机确实如此），也能保证支持（伪）并发的能力。将一个单独的cpu变成多个虚拟的cpu（多道技术：时间多路复用和空间多路复用+硬件上支持隔离），没有进程的抽象，现代计算机将不复存在。 六 总结必备的理论基础： 123456789101112131415#一 操作系统的作用： 1：隐藏丑陋复杂的硬件接口，提供良好的抽象接口 2：管理、调度进程，并且将多个进程对硬件的竞争变得有序#二 多道技术： 1.产生背景：针对单核，实现并发 ps： 现在的主机一般是多核，那么每个核都会利用多道技术 有4个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到4个 cpu中的任意一个，具体由操作系统调度算法决定。 2.空间上的复用：如内存中同时有多道程序 3.时间上的复用：复用一个cpu的时间片 强调：遇到io切，占用cpu时间过长也切，核心在于切之前将进程的状态保存下来，这样 才能保证下次切换回来时，能基于上次切走的位置继续运行","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"31、网络编程","slug":"31.网络编程","date":"2018-05-13T06:04:31.000Z","updated":"2022-05-13T12:28:55.165Z","comments":true,"path":"2018/05/13/31.网络编程/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/31.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一 客户端&#x2F;服务端架构 二 osi七层协议 三 socket层 四 socket是什么 五 套接字发展史及分类 六 套接字工作流程 七 基于TCP的套接字 八 基于UDP的套接字 九 粘包现象 十 什么是粘包 十一 解决粘包的low处理方法 十二 高手解决粘包的方法 十三 认证客户端的链接合法性 十四 socketserver实现并发 一 客户端&#x2F;服务端架构1.硬件C&#x2F;S架构(打印机) 2.软件C&#x2F;S架构 互联网中处处是C&#x2F;S架构 如黄色网站是服务端，你的浏览器是客户端（B&#x2F;S架构也是C&#x2F;S架构的一种） 腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频） C&#x2F;S架构与socket的关系： 我们学习socket就是为了完成C&#x2F;S架构的开发 二 osi七层协议引子： 须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的） 如果你要跟别人一起玩，那你就需要上网了，什么是互联网？ 互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语 如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。 人们按照分工不同把互联网协议从逻辑上划分了层级， 详见网络通信原理：https://www.cnblogs.com/chenxiao1/p/14893950.html 为何学习socket一定要先学习互联网协议： 1.首先：本节课程的目标就是教会你如何基于socket编程，来开发一款自己的C&#x2F;S架构软件 2.其次：C&#x2F;S架构的软件（软件属于应用层）是基于网络进行通信的 3.然后：网络的核心即一堆协议，协议即标准，你想开发一款基于网络通信的软件，就必须遵循这些标准。 4.最后：就让我们从这些标准开始研究，开启我们的socket编程之旅 图1 三 socket层在图1中，我们没有看到Socket的影子，那么它到底在哪里呢？还是用图来说话，一目了然。 图2 四 socket是什么Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 所以，我们无需深入理解tcp&#x2F;udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp&#x2F;udp标准的。 123也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序而程序的pid是同一台机器上不同进程或者线程的标识 五 套接字发展史及分类套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。 *基于文件类型的套接字家族* 套接字家族的名字：AF_UNIX unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信 *基于网络类型的套接字家族* 套接字家族的名字：AF_INET (还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我们只使用AF_INET) 六 套接字工作流程一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。 图3 先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束 socket()模块函数用法 12345678910111213141516import socketsocket.socket(socket_family, socket_type, protocal=0)# socket_family 可以是 AF_UNIX, AF_INET# socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM# protocal 一般不填默认为0# 获取tcp/ip套接字tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 获取udp/ip套接字udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 由于socket 模块中有太多的属性，这里破例使用了&#x27;from module import *&#x27; 语句。使用&#x27;from socket import *&#x27;，我们把socket模块里的所有属性都带到我们的命名空间里了，这样能大幅简短我们的代码# 例如: tcpSock = socket(AF_INET, SOCK_STREAM) 服务端套接字函数 s.bind() 绑定(主机，端口号)到套接字 s.listen() 开始TCP监听 s.accept() 被动接收TCP客户的连接，（阻塞式）等待连接的到来 客户端套接字函数 s.connect() 主动初始化TCP服务器连接 s.conncect_ex() # connect函数的扩展版本，出错时返回出错码，而不是抛出异常 公共用途的套接字函数 s.recv() 接收TCP数据 s.send() 发送TCP数据（send在待发送数据大于己端缓存区剩余空间时，数据丢失，不会发完） s.sendall() 发送完整的TCP数据（本质就是循环勇send，sendall在待发送数据大于己端缓存区剩余空间时，数据不丢失，循环用send发完） s.recvfrom() 接收UDP数据 s.sendto() 发送UDP数据 s.getpeername() 连接到当前套接字的远端的地址 s.getsockname() 当前套接字的地址 s.getsockopt() 返回指定套接字的参数 s.setsockopt() 设置指定套接字的参数 s.close() 关闭套接字 面向锁的套接字方法 s.setbocking() 设置套接字的阻塞与非阻塞模式 s.settimeout() 设置阻塞套接字操作的超时时间 s.gettimeout() 得到组测套接字操作的操作时间 面向文件的套接字的函数 s.fileno() 套接字的文件描述符 s.makefile() 创建一个与该套接字相关的文件 七 基于TCP的套接字tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端 tcp服务端 123456789ss = socket() # 创建服务器套接字ss.bind() # 把地址绑定到套接字ss.listen() # 监听链接info_loop: # 服务器无限循环 cs = ss.accept() # 接收客户端链接 comm_loop: # 通信循环 cs.recv()/cs.send() # 对话（接收与发送） cs.close() # 关闭客户端套接字ss.close() # 关闭服务端套接字（可选） tcp客户端 12345cs = socket() # 创建客户端套接字cs.connect() # 尝试连接服务器comm_loop: # 通信循环 cs.send()/cs.recv() # 对话（发送/接收）cs.close() # 关闭客户套接字 socket通信流程与打电话流程类似，我们可以以打电话为例实现一个low版的套接字通信： 服务端： 123456789101112131415161718192021#_*_coding:utf-8_*___author__ = &#x27;cx&#x27;import socketip_port = (&#x27;127.0.0.1&#x27;,9000) # 电话卡BUFSIZE = 1024 # 收发消息的尺寸s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 买手机s.bind(ip_port) # 手机插卡s.listen(5) # 手机待机conn,addr = s.accept() # 手机接电话print(&#x27;接到来自%s的电话&#x27; % addr[0]) msg = conn.recv(BUFSIZE) # 听电话print(msg,type(msg))conn.send(msg.upper()) # 发消息，说话conn.close() # 挂电话s.close() # 手机关机 客户端： 123456789101112131415#_*_coding:utf-8_*___author__ = &#x27;Linhaifeng&#x27;import socketip_port=(&#x27;127.0.0.1&#x27;,9000)BUFSIZE=1024s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect_ex(ip_port) #拨电话s.send(&#x27;linhaifeng nb&#x27;.encode(&#x27;utf-8&#x27;)) #发消息,说话(只能发送字节类型)feedback=s.recv(BUFSIZE) #收消息,听话print(feedback.decode(&#x27;utf-8&#x27;))s.close() 加上链接循环与通信循环 服务端改进版: 1234567891011121314151617181920212223242526#_*_coding:utf-8_*_import socketip_port=(&#x27;127.0.0.1&#x27;,8081)#电话卡BUFSIZE=1024s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) #买手机s.bind(ip_port) #手机插卡s.listen(5) #手机待机while True: # 新增接收链接循环,可以不停的接电话 conn,addr=s.accept() # 手机接电话 # print(conn) # print(addr) print(&#x27;接到来自%s的电话&#x27; %addr[0]) while True: #新增通信循环,可以不断的通信,收发消息 msg=conn.recv(BUFSIZE) #听消息,听话 # if len(msg) == 0:break # 如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生 print(msg,type(msg)) conn.send(msg.upper()) #发消息,说话 conn.close() #挂电话s.close() #手机关机 客户端改进版 1234567891011121314151617#_*_coding:utf-8_*_import socketip_port=(&#x27;127.0.0.1&#x27;,8081)BUFSIZE=1024s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect_ex(ip_port) #拨电话while True: #新增通信循环,客户端可以不断发收消息 msg=input(&#x27;&gt;&gt;: &#x27;).strip() if len(msg) == 0:continue s.send(msg.encode(&#x27;utf-8&#x27;)) #发消息,说话(只能发送字节类型) feedback=s.recv(BUFSIZE) #收消息,听话 print(feedback.decode(&#x27;utf-8&#x27;))s.close() #挂电话 八 基于UDP的套接字*udp是无链接的，先启动哪一端都不会报错* udp服务端 12345ss = socket() #创建一个服务器的套接字ss.bind() #绑定服务器套接字inf_loop: #服务器无限循环 cs = ss.recvfrom()/ss.sendto() # 对话(接收与发送)ss.close() # 关闭服务器套接字 udp客户端 1234cs = socket() # 创建客户套接字comm_loop: # 通讯循环 cs.sendto()/cs.recvfrom() # 对话(发送/接收)cs.close() # 关闭客户套接字 *udp套接字简单示例* udp服务端 12345678910111213#_*_coding:utf-8_*_import socketip_port=(&#x27;127.0.0.1&#x27;,9000)BUFSIZE=1024udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)udp_server_client.bind(ip_port)while True: msg,addr=udp_server_client.recvfrom(BUFSIZE) print(msg,addr) udp_server_client.sendto(msg.upper(),addr) udp客户端 123456789101112131415#_*_coding:utf-8_*___author__ = &#x27;Linhaifeng&#x27;import socketip_port=(&#x27;127.0.0.1&#x27;,9000)BUFSIZE=1024udp_server_client=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)while True: msg=input(&#x27;&gt;&gt;: &#x27;).strip() if not msg:continue udp_server_client.sendto(msg.encode(&#x27;utf-8&#x27;),ip_port) back_msg,addr=udp_server_client.recvfrom(BUFSIZE) print(back_msg.decode(&#x27;utf-8&#x27;),addr) *qq聊天(由于udp无连接，所以可以同时多个客户端去跟服务端通信)* udp服务端 123456789101112#_*_coding:utf-8_*_import socketip_port=(&#x27;127.0.0.1&#x27;,8081)udp_server_sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #买手机udp_server_sock.bind(ip_port)while True: qq_msg,addr=udp_server_sock.recvfrom(1024) print(&#x27;来自[%s:%s]的一条消息:\\033[1;44m%s\\033[0m&#x27; %(addr[0],addr[1],qq_msg.decode(&#x27;utf-8&#x27;))) back_msg=input(&#x27;回复消息: &#x27;).strip() udp_server_sock.sendto(back_msg.encode(&#x27;utf-8&#x27;),addr) udp客户端1 12345678910111213141516171819202122232425#_*_coding:utf-8_*_import socketBUFSIZE=1024udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)qq_name_dic=&#123; &#x27;狗哥alex&#x27;:(&#x27;127.0.0.1&#x27;,8081), &#x27;瞎驴&#x27;:(&#x27;127.0.0.1&#x27;,8081), &#x27;一棵树&#x27;:(&#x27;127.0.0.1&#x27;,8081), &#x27;武大郎&#x27;:(&#x27;127.0.0.1&#x27;,8081),&#125;while True: qq_name=input(&#x27;请选择聊天对象: &#x27;).strip() while True: msg=input(&#x27;请输入消息,回车发送: &#x27;).strip() if msg == &#x27;quit&#x27;:break if not msg or not qq_name or qq_name not in qq_name_dic:continue udp_client_socket.sendto(msg.encode(&#x27;utf-8&#x27;),qq_name_dic[qq_name]) back_msg,addr=udp_client_socket.recvfrom(BUFSIZE) print(&#x27;来自[%s:%s]的一条消息:\\033[1;44m%s\\033[0m&#x27; %(addr[0],addr[1],back_msg.decode(&#x27;utf-8&#x27;)))udp_client_socket.close() udp客户端2 12345678910111213141516171819202122232425#_*_coding:utf-8_*_import socketBUFSIZE=1024udp_client_socket=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)qq_name_dic=&#123; &#x27;狗哥alex&#x27;:(&#x27;127.0.0.1&#x27;,8081), &#x27;瞎驴&#x27;:(&#x27;127.0.0.1&#x27;,8081), &#x27;一棵树&#x27;:(&#x27;127.0.0.1&#x27;,8081), &#x27;武大郎&#x27;:(&#x27;127.0.0.1&#x27;,8081),&#125;while True: qq_name=input(&#x27;请选择聊天对象: &#x27;).strip() while True: msg=input(&#x27;请输入消息,回车发送: &#x27;).strip() if msg == &#x27;quit&#x27;:break if not msg or not qq_name or qq_name not in qq_name_dic:continue udp_client_socket.sendto(msg.encode(&#x27;utf-8&#x27;),qq_name_dic[qq_name]) back_msg,addr=udp_client_socket.recvfrom(BUFSIZE) print(&#x27;来自[%s:%s]的一条消息:\\033[1;44m%s\\033[0m&#x27; %(addr[0],addr[1],back_msg.decode(&#x27;utf-8&#x27;)))udp_client_socket.close() *时间服务器* ntp服务端 1234567891011121314151617181920212223#_*_coding:utf-8_*_from socket import *from time import strftimeip_port=(&#x27;127.0.0.1&#x27;,9000)bufsize=1024tcp_server=socket(AF_INET,SOCK_DGRAM)tcp_server.bind(ip_port)while True: msg,addr=tcp_server.recvfrom(bufsize) print(&#x27;===&gt;&#x27;,msg) if not msg: time_fmt=&#x27;%Y-%m-%d %X&#x27; else: time_fmt=msg.decode(&#x27;utf-8&#x27;) back_msg=strftime(time_fmt) tcp_server.sendto(back_msg.encode(&#x27;utf-8&#x27;),addr)tcp_server.close() ntp客户端 12345678910111213141516#_*_coding:utf-8_*_from socket import *ip_port=(&#x27;127.0.0.1&#x27;,9000)bufsize=1024tcp_client=socket(AF_INET,SOCK_DGRAM)while True: msg=input(&#x27;请输入时间格式(例%Y %m %d)&gt;&gt;: &#x27;).strip() tcp_client.sendto(msg.encode(&#x27;utf-8&#x27;),ip_port) data=tcp_client.recv(bufsize) print(data.decode(&#x27;utf-8&#x27;))tcp_client.close() 九 粘包现象让我们基于tcp先制作一个远程执行命令的程序（1：执行错误命令 2：执行ls 3：执行ifconfig） 注意注意注意： res&#x3D;subprocess.Popen(cmd.decode(‘utf-8’), shell&#x3D;True, stderr&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE) 的结果的编码是以当前所在的系统为准的，如果是windows，那么res.stdout.read()读出的就是GBK编码的，在接收端需要用GBK解码 且只能从管道里读一次结果 注意：命令ls -l ; lllllll ; pwd 的结果是既有正确stdout结果，又有错误stderr结果 服务端 12345678910111213141516171819202122232425262728#_*_coding:utf-8_*_from socket import *import subprocessip_port=(&#x27;127.0.0.1&#x27;,8080)BUFSIZE=1024tcp_socket_server=socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)while True: conn,addr=tcp_socket_server.accept() print(&#x27;客户端&#x27;,addr) while True: cmd=conn.recv(BUFSIZE) if len(cmd) == 0:break res=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;),shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE) stderr=act_res.stderr.read() stdout=act_res.stdout.read() conn.send(stderr) conn.send(stdout) 客户端 1234567891011121314151617#_*_coding:utf-8_*_import socketBUFSIZE=1024ip_port=(&#x27;127.0.0.1&#x27;,8080)s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex(ip_port)while True: msg=input(&#x27;&gt;&gt;: &#x27;).strip() if len(msg) == 0:continue if msg == &#x27;quit&#x27;:break s.send(msg.encode(&#x27;utf-8&#x27;)) act_res=s.recv(BUFSIZE) print(act_res.decode(&#x27;utf-8&#x27;),end=&#x27;&#x27;) 上述程序是基于tcp的socket，在运行时会发生粘包 让我们再基于udp制作一个远程执行命令的程序 服务端 1234567891011121314151617181920212223from socket import *import subprocessip_port=(&#x27;127.0.0.1&#x27;,9003)bufsize=1024udp_server=socket(AF_INET,SOCK_DGRAM)udp_server.bind(ip_port)while True: #收消息 cmd,addr=udp_server.recvfrom(bufsize) print(&#x27;用户命令-----&gt;&#x27;,cmd) #逻辑处理 res=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;),shell=True,stderr=subprocess.PIPE,stdin=subprocess.PIPE,stdout=subprocess.PIPE) stderr=res.stderr.read() stdout=res.stdout.read() #发消息 udp_server.sendto(stderr,addr) udp_server.sendto(stdout,addr)udp_server.close() 客户端 12345678910111213from socket import *ip_port=(&#x27;127.0.0.1&#x27;,9003)bufsize=1024udp_client=socket(AF_INET,SOCK_DGRAM)while True: msg=input(&#x27;&gt;&gt;: &#x27;).strip() udp_client.sendto(msg.encode(&#x27;utf-8&#x27;),ip_port) data,addr=udp_client.recvfrom(bufsize) print(data.decode(&#x27;utf-8&#x27;),end=&#x27;&#x27;) 上述程序是基于udp的socket，在运行时永远不会发生粘包 十 什么是粘包须知：只有TCP有粘包现象，UDP永远不会粘包，为何，且听我娓娓道来 首先需要掌握一个socket收发消息的原理 发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write&#x2F;send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。 例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束 所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。 此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。 TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。 UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。 tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略 udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠 tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。 *两种情况下会发生粘包。* 发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包） 服务端 123456789101112131415161718from socket import *ip_port=(&#x27;127.0.0.1&#x27;,8080)tcp_socket_server=socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)conn,addr=tcp_socket_server.accept()data1=conn.recv(10)data2=conn.recv(10)print(&#x27;-----&gt;&#x27;,data1.decode(&#x27;utf-8&#x27;))print(&#x27;-----&gt;&#x27;,data2.decode(&#x27;utf-8&#x27;))conn.close() 客户端 12345678910import socketBUFSIZE=1024ip_port=(&#x27;127.0.0.1&#x27;,8080)s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex(ip_port)s.send(&#x27;hello&#x27;.encode(&#x27;utf-8&#x27;))s.send(&#x27;feng&#x27;.encode(&#x27;utf-8&#x27;)) 接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） 服务端 123456789101112131415161718from socket import *ip_port=(&#x27;127.0.0.1&#x27;,8080)tcp_socket_server=socket(AF_INET,SOCK_STREAM)tcp_socket_server.bind(ip_port)tcp_socket_server.listen(5)conn,addr=tcp_socket_server.accept()data1=conn.recv(2) #一次没有收完整data2=conn.recv(10)#下次收的时候,会先取旧的数据,然后取新的print(&#x27;-----&gt;&#x27;,data1.decode(&#x27;utf-8&#x27;))print(&#x27;-----&gt;&#x27;,data2.decode(&#x27;utf-8&#x27;))conn.close() 客户端 123456789import socketBUFSIZE=1024ip_port=(&#x27;127.0.0.1&#x27;,8080)s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex(ip_port)s.send(&#x27;hello feng&#x27;.encode(&#x27;utf-8&#x27;)) *拆包的发生情况* 当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。 *补充问题一：为何tcp是可靠传输，udp是不可靠传输* 基于tcp的数据传输请参考我的另一篇文章http://www.cnblogs.com/linhaifeng/articles/5937962.html，tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack&#x3D;1，发送端则清理缓存中的数据，对端返回ack&#x3D;0，则重新发送数据，所以tcp是可靠的 而udp发送数据，对端是不会返回确认信息的，因此不可靠 *补充问题二：send(字节流)和recv(1024)及sendall* recv里指定的1024意思是从缓存里一次拿出1024个字节的数据 send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失 十一 解决粘包的low方法问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据 low版本的解决方法 服务端 1234567891011121314151617181920212223242526272829import socket,subprocessip_port=(&#x27;127.0.0.1&#x27;,8080)s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)s.bind(ip_port)s.listen(5)while True: conn,addr=s.accept() print(&#x27;客户端&#x27;,addr) while True: msg=conn.recv(1024) if not msg:break res=subprocess.Popen(msg.decode(&#x27;utf-8&#x27;),shell=True,\\ stdin=subprocess.PIPE,\\ stderr=subprocess.PIPE,\\ stdout=subprocess.PIPE) err=res.stderr.read() if err: ret=err else: ret=res.stdout.read() data_length=len(ret) conn.send(str(data_length).encode(&#x27;utf-8&#x27;)) data=conn.recv(1024).decode(&#x27;utf-8&#x27;) if data == &#x27;recv_ready&#x27;: conn.sendall(ret) conn.close() 客户端 123456789101112131415161718192021import socket,times=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex((&#x27;127.0.0.1&#x27;,8080))while True: msg=input(&#x27;&gt;&gt;: &#x27;).strip() if len(msg) == 0:continue if msg == &#x27;quit&#x27;:break s.send(msg.encode(&#x27;utf-8&#x27;)) length=int(s.recv(1024).decode(&#x27;utf-8&#x27;)) s.send(&#x27;recv_ready&#x27;.encode(&#x27;utf-8&#x27;)) send_size=0 recv_size=0 data=b&#x27;&#x27; while recv_size &lt; length: data+=s.recv(1024) recv_size+=len(data) print(data.decode(&#x27;utf-8&#x27;)) 为何low： 程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗 十二 高级解决粘包的方法为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据 struct模块 该模块可以把一个类型，如数字，转成固定长度的bytes &gt;&gt;&gt; struct.pack(‘i’,1111111111111) 。。。。。。。。。 struct.error: ‘i’ format requires -2147483648 &lt;&#x3D; number &lt;&#x3D; 2147483647 #这个是范围 123456789101112131415161718192021222324252627import json,struct#假设通过客户端上传1T:1073741824000的文件a.txt#为避免粘包,必须自定制报头header=&#123;&#x27;file_size&#x27;:1073741824000,&#x27;file_name&#x27;:&#x27;/a/b/c/d/e/a.txt&#x27;,&#x27;md5&#x27;:&#x27;8f6fbf8347faa4924a76856701edb0f3&#x27;&#125; #1T数据,文件路径和md5值#为了该报头能传送,需要序列化并且转为byteshead_bytes=bytes(json.dumps(header),encoding=&#x27;utf-8&#x27;) #序列化并转成bytes,用于传输#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节head_len_bytes=struct.pack(&#x27;i&#x27;,len(head_bytes)) #这4个字节里只包含了一个数字,该数字是报头的长度#客户端开始发送conn.send(head_len_bytes) #先发报头的长度,4个bytesconn.send(head_bytes) #再发报头的字节格式conn.sendall(文件内容) #然后发真实内容的字节格式#服务端开始接收head_len_bytes=s.recv(4) #先收报头4个bytes,得到报头长度的字节格式x=struct.unpack(&#x27;i&#x27;,head_len_bytes)[0] #提取报头的长度head_bytes=s.recv(x) #按照报头长度x,收取报头的bytes格式header=json.loads(json.dumps(header)) #提取报头#最后根据报头的内容提取真实的数据,比如real_data_len=s.recv(header[&#x27;file_size&#x27;])s.recv(real_data_len) 关于struct的详细用法 1234567891011121314151617181920212223242526272829#http://www.cnblogs.com/coser/archive/2011/12/17/2291160.html__author__ = &#x27;Linhaifeng&#x27;import structimport binasciiimport ctypesvalues1 = (1, &#x27;abc&#x27;.encode(&#x27;utf-8&#x27;), 2.7)values2 = (&#x27;defg&#x27;.encode(&#x27;utf-8&#x27;),101)s1 = struct.Struct(&#x27;I3sf&#x27;)s2 = struct.Struct(&#x27;4sI&#x27;)print(s1.size,s2.size)prebuffer=ctypes.create_string_buffer(s1.size+s2.size)print(&#x27;Before : &#x27;,binascii.hexlify(prebuffer))# t=binascii.hexlify(&#x27;asdfaf&#x27;.encode(&#x27;utf-8&#x27;))# print(t)s1.pack_into(prebuffer,0,*values1)s2.pack_into(prebuffer,s1.size,*values2)print(&#x27;After pack&#x27;,binascii.hexlify(prebuffer))print(s1.unpack_from(prebuffer,0))print(s2.unpack_from(prebuffer,s1.size))s3=struct.Struct(&#x27;ii&#x27;)s3.pack_into(prebuffer,0,123,123)print(&#x27;After pack&#x27;,binascii.hexlify(prebuffer))print(s3.unpack_from(prebuffer,0)) 服务端（自定制报头） 1234567891011121314151617181920212223242526272829303132import socket,struct,jsonimport subprocessphone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加phone.bind((&#x27;127.0.0.1&#x27;,8080))phone.listen(5)while True: conn,addr=phone.accept() while True: cmd=conn.recv(1024) if not cmd:break print(&#x27;cmd: %s&#x27; %cmd) res=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) err=res.stderr.read() print(err) if err: back_msg=err else: back_msg=res.stdout.read() conn.send(struct.pack(&#x27;i&#x27;,len(back_msg))) #先发back_msg的长度 conn.sendall(back_msg) #在发真实的内容 conn.close() 客户端（自定制报头） 123456789101112131415161718192021222324252627import socket,time,structs=socket.socket(socket.AF_INET,socket.SOCK_STREAM)res=s.connect_ex((&#x27;127.0.0.1&#x27;,8080))while True: msg=input(&#x27;&gt;&gt;: &#x27;).strip() if len(msg) == 0:continue if msg == &#x27;quit&#x27;:break s.send(msg.encode(&#x27;utf-8&#x27;)) l=s.recv(4) x=struct.unpack(&#x27;i&#x27;,l)[0] print(type(x),x) # print(struct.unpack(&#x27;I&#x27;,l)) r_s=0 data=b&#x27;&#x27; while r_s &lt; x: r_d=s.recv(1024) data+=r_d r_s+=len(r_d) # print(data.decode(&#x27;utf-8&#x27;)) print(data.decode(&#x27;gbk&#x27;)) #windows默认gbk编码 我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了） 发送时： 先发报头长度 再编码报头内容然后发送 最后发真实内容 接收时： 先手报头长度，用struct取出来 根据取出的长度收取报头内容，然后解码，反序列化 从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容 服务端：定制稍微复杂一点的报头 123456789101112131415161718192021222324252627282930313233343536import socket,struct,jsonimport subprocessphone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加phone.bind((&#x27;127.0.0.1&#x27;,8080))phone.listen(5)while True: conn,addr=phone.accept() while True: cmd=conn.recv(1024) if not cmd:break print(&#x27;cmd: %s&#x27; %cmd) res=subprocess.Popen(cmd.decode(&#x27;utf-8&#x27;), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) err=res.stderr.read() print(err) if err: back_msg=err else: back_msg=res.stdout.read() headers=&#123;&#x27;data_size&#x27;:len(back_msg)&#125; head_json=json.dumps(headers) head_json_bytes=bytes(head_json,encoding=&#x27;utf-8&#x27;) conn.send(struct.pack(&#x27;i&#x27;,len(head_json_bytes))) #先发报头的长度 conn.send(head_json_bytes) #再发报头 conn.sendall(back_msg) #在发真实的内容 conn.close() 客户端 12345678910111213141516171819202122232425from socket import *import struct,jsonip_port=(&#x27;127.0.0.1&#x27;,8080)client=socket(AF_INET,SOCK_STREAM)client.connect(ip_port)while True: cmd=input(&#x27;&gt;&gt;: &#x27;) if not cmd:continue client.send(bytes(cmd,encoding=&#x27;utf-8&#x27;)) head=client.recv(4) head_json_len=struct.unpack(&#x27;i&#x27;,head)[0] head_json=json.loads(client.recv(head_json_len).decode(&#x27;utf-8&#x27;)) data_len=head_json[&#x27;data_size&#x27;] recv_size=0 recv_data=b&#x27;&#x27; while recv_size &lt; data_len: recv_data+=client.recv(1024) recv_size+=len(recv_data) print(recv_data.decode(&#x27;utf-8&#x27;)) #print(recv_data.decode(&#x27;gbk&#x27;)) #windows默认gbk编码 FTP作业：上传下载文件 服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import socketimport structimport jsonimport subprocessimport osclass MYTCPServer: address_family = socket.AF_INET socket_type = socket.SOCK_STREAM allow_reuse_address = False max_packet_size = 8192 coding=&#x27;utf-8&#x27; request_queue_size = 5 server_dir=&#x27;file_upload&#x27; def __init__(self, server_address, bind_and_activate=True): &quot;&quot;&quot;Constructor. May be extended, do not override.&quot;&quot;&quot; self.server_address=server_address self.socket = socket.socket(self.address_family, self.socket_type) if bind_and_activate: try: self.server_bind() self.server_activate() except: self.server_close() raise def server_bind(self): &quot;&quot;&quot;Called by constructor to bind the socket. &quot;&quot;&quot; if self.allow_reuse_address: self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.bind(self.server_address) self.server_address = self.socket.getsockname() def server_activate(self): &quot;&quot;&quot;Called by constructor to activate the server. &quot;&quot;&quot; self.socket.listen(self.request_queue_size) def server_close(self): &quot;&quot;&quot;Called to clean-up the server. &quot;&quot;&quot; self.socket.close() def get_request(self): &quot;&quot;&quot;Get the request and client address from the socket. &quot;&quot;&quot; return self.socket.accept() def close_request(self, request): &quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot; request.close() def run(self): while True: self.conn,self.client_addr=self.get_request() print(&#x27;from client &#x27;,self.client_addr) while True: try: head_struct = self.conn.recv(4) if not head_struct:break head_len = struct.unpack(&#x27;i&#x27;, head_struct)[0] head_json = self.conn.recv(head_len).decode(self.coding) head_dic = json.loads(head_json) print(head_dic) #head_dic=&#123;&#x27;cmd&#x27;:&#x27;put&#x27;,&#x27;filename&#x27;:&#x27;a.txt&#x27;,&#x27;filesize&#x27;:123123&#125; cmd=head_dic[&#x27;cmd&#x27;] if hasattr(self,cmd): func=getattr(self,cmd) func(head_dic) except Exception: break def put(self,args): file_path=os.path.normpath(os.path.join( self.server_dir, args[&#x27;filename&#x27;] )) filesize=args[&#x27;filesize&#x27;] recv_size=0 print(&#x27;-----&gt;&#x27;,file_path) with open(file_path,&#x27;wb&#x27;) as f: while recv_size &lt; filesize: recv_data=self.conn.recv(self.max_packet_size) f.write(recv_data) recv_size+=len(recv_data) print(&#x27;recvsize:%s filesize:%s&#x27; %(recv_size,filesize))tcpserver1=MYTCPServer((&#x27;127.0.0.1&#x27;,8080))tcpserver1.run() 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import socketimport structimport jsonimport osclass MYTCPClient: address_family = socket.AF_INET socket_type = socket.SOCK_STREAM allow_reuse_address = False max_packet_size = 8192 coding=&#x27;utf-8&#x27; request_queue_size = 5 def __init__(self, server_address, connect=True): self.server_address=server_address self.socket = socket.socket(self.address_family, self.socket_type) if connect: try: self.client_connect() except: self.client_close() raise def client_connect(self): self.socket.connect(self.server_address) def client_close(self): self.socket.close() def run(self): while True: inp=input(&quot;&gt;&gt;: &quot;).strip() if not inp:continue l=inp.split() cmd=l[0] if hasattr(self,cmd): func=getattr(self,cmd) func(l) def put(self,args): cmd=args[0] filename=args[1] if not os.path.isfile(filename): print(&#x27;file:%s is not exists&#x27; %filename) return else: filesize=os.path.getsize(filename) head_dic=&#123;&#x27;cmd&#x27;:cmd,&#x27;filename&#x27;:os.path.basename(filename),&#x27;filesize&#x27;:filesize&#125; print(head_dic) head_json=json.dumps(head_dic) head_json_bytes=bytes(head_json,encoding=self.coding) head_struct=struct.pack(&#x27;i&#x27;,len(head_json_bytes)) self.socket.send(head_struct) self.socket.send(head_json_bytes) send_size=0 with open(filename,&#x27;rb&#x27;) as f: for line in f: self.socket.send(line) send_size+=len(line) print(send_size) else: print(&#x27;upload successful&#x27;)client=MYTCPClient((&#x27;127.0.0.1&#x27;,8080))client.run() 十三 认证客户端的链接合法性如果你想在分布式系统中实现一个简单的客户端链接认证功能，又不像SSL那么复杂，那么利用hmac+加盐的方式来实现 服务端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from socket import *import hmac,ossecret_key=b&#x27;linhaifeng bang bang bang&#x27;def conn_auth(conn): &#x27;&#x27;&#x27; 认证客户端链接 :param conn: :return: &#x27;&#x27;&#x27; print(&#x27;开始验证新链接的合法性&#x27;) msg=os.urandom(32) conn.sendall(msg) h=hmac.new(secret_key,msg) digest=h.digest() respone=conn.recv(len(digest)) return hmac.compare_digest(respone,digest)def data_handler(conn,bufsize=1024): if not conn_auth(conn): print(&#x27;该链接不合法,关闭&#x27;) conn.close() return print(&#x27;链接合法,开始通信&#x27;) while True: data=conn.recv(bufsize) if not data:break conn.sendall(data.upper())def server_handler(ip_port,bufsize,backlog=5): &#x27;&#x27;&#x27; 只处理链接 :param ip_port: :return: &#x27;&#x27;&#x27; tcp_socket_server=socket(AF_INET,SOCK_STREAM) tcp_socket_server.bind(ip_port) tcp_socket_server.listen(backlog) while True: conn,addr=tcp_socket_server.accept() print(&#x27;新连接[%s:%s]&#x27; %(addr[0],addr[1])) data_handler(conn,bufsize)if __name__ == &#x27;__main__&#x27;: ip_port=(&#x27;127.0.0.1&#x27;,9999) bufsize=1024 server_handler(ip_port,bufsize) 客户端(合法) 1234567891011121314151617181920212223242526272829303132333435from socket import *import hmac,ossecret_key=b&#x27;linhaifeng bang bang bang&#x27;def conn_auth(conn): &#x27;&#x27;&#x27; 验证客户端到服务器的链接 :param conn: :return: &#x27;&#x27;&#x27; msg=conn.recv(32) h=hmac.new(secret_key,msg) digest=h.digest() conn.sendall(digest)def client_handler(ip_port,bufsize=1024): tcp_socket_client=socket(AF_INET,SOCK_STREAM) tcp_socket_client.connect(ip_port) conn_auth(tcp_socket_client) while True: data=input(&#x27;&gt;&gt;: &#x27;).strip() if not data:continue if data == &#x27;quit&#x27;:break tcp_socket_client.sendall(data.encode(&#x27;utf-8&#x27;)) respone=tcp_socket_client.recv(bufsize) print(respone.decode(&#x27;utf-8&#x27;)) tcp_socket_client.close()if __name__ == &#x27;__main__&#x27;: ip_port=(&#x27;127.0.0.1&#x27;,9999) bufsize=1024 client_handler(ip_port,bufsize) 客户端(非法:不知道加密方式) 1234567891011121314151617181920from socket import *def client_handler(ip_port,bufsize=1024): tcp_socket_client=socket(AF_INET,SOCK_STREAM) tcp_socket_client.connect(ip_port) while True: data=input(&#x27;&gt;&gt;: &#x27;).strip() if not data:continue if data == &#x27;quit&#x27;:break tcp_socket_client.sendall(data.encode(&#x27;utf-8&#x27;)) respone=tcp_socket_client.recv(bufsize) print(respone.decode(&#x27;utf-8&#x27;)) tcp_socket_client.close()if __name__ == &#x27;__main__&#x27;: ip_port=(&#x27;127.0.0.1&#x27;,9999) bufsize=1024 client_handler(ip_port,bufsize) 客户端(非法:不知道secret_key) 1234567891011121314151617181920212223242526272829303132333435from socket import *import hmac,ossecret_key=b&#x27;linhaifeng bang bang bang1111&#x27;def conn_auth(conn): &#x27;&#x27;&#x27; 验证客户端到服务器的链接 :param conn: :return: &#x27;&#x27;&#x27; msg=conn.recv(32) h=hmac.new(secret_key,msg) digest=h.digest() conn.sendall(digest)def client_handler(ip_port,bufsize=1024): tcp_socket_client=socket(AF_INET,SOCK_STREAM) tcp_socket_client.connect(ip_port) conn_auth(tcp_socket_client) while True: data=input(&#x27;&gt;&gt;: &#x27;).strip() if not data:continue if data == &#x27;quit&#x27;:break tcp_socket_client.sendall(data.encode(&#x27;utf-8&#x27;)) respone=tcp_socket_client.recv(bufsize) print(respone.decode(&#x27;utf-8&#x27;)) tcp_socket_client.close()if __name__ == &#x27;__main__&#x27;: ip_port=(&#x27;127.0.0.1&#x27;,9999) bufsize=1024 client_handler(ip_port,bufsize) 十四 socketserver实现并发基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环 socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题） server类： request类： 继承关系: 以下述代码为例，分析socketserver源码： 12ftpserver=socketserver.ThreadingTCPServer((&#x27;127.0.0.1&#x27;,8080),FtpServer)ftpserver.serve_forever() 查找属性的顺序：ThreadingTCPServer-&gt;ThreadingMixIn-&gt;TCPServer-&gt;BaseServer 实例化得到ftpserver，先找类ThreadingTCPServer的init,在TCPServer中找到，进而执行server_bind,server_active 找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中 执行self._handle_request_noblock()进而执行request, client_address &#x3D; self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address) 在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address) 上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找init方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找…. 源码分析总结： 基于tcp的socketserver我们自己定义的类中的 self.server即套接字对象 self.request即一个链接 self.client_address即客户端地址 基于udp的socketserver我们自己定义的类中的 self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b’adsf’, ) self.client_address即客户端地址 FtpServer 1234567891011121314151617181920212223242526272829303132333435363738394041import socketserverimport structimport jsonimport osclass FtpServer(socketserver.BaseRequestHandler): coding=&#x27;utf-8&#x27; server_dir=&#x27;file_upload&#x27; max_packet_size=1024 BASE_DIR=os.path.dirname(os.path.abspath(__file__)) def handle(self): print(self.request) while True: data=self.request.recv(4) data_len=struct.unpack(&#x27;i&#x27;,data)[0] head_json=self.request.recv(data_len).decode(self.coding) head_dic=json.loads(head_json) # print(head_dic) cmd=head_dic[&#x27;cmd&#x27;] if hasattr(self,cmd): func=getattr(self,cmd) func(head_dic) def put(self,args): file_path = os.path.normpath(os.path.join( self.BASE_DIR, self.server_dir, args[&#x27;filename&#x27;] )) filesize = args[&#x27;filesize&#x27;] recv_size = 0 print(&#x27;-----&gt;&#x27;, file_path) with open(file_path, &#x27;wb&#x27;) as f: while recv_size &lt; filesize: recv_data = self.request.recv(self.max_packet_size) f.write(recv_data) recv_size += len(recv_data) print(&#x27;recvsize:%s filesize:%s&#x27; % (recv_size, filesize))ftpserver=socketserver.ThreadingTCPServer((&#x27;127.0.0.1&#x27;,8080),FtpServer)ftpserver.serve_forever() FtpClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import socketimport structimport jsonimport osclass MYTCPClient: address_family = socket.AF_INET socket_type = socket.SOCK_STREAM allow_reuse_address = False max_packet_size = 8192 coding=&#x27;utf-8&#x27; request_queue_size = 5 def __init__(self, server_address, connect=True): self.server_address=server_address self.socket = socket.socket(self.address_family, self.socket_type) if connect: try: self.client_connect() except: self.client_close() raise def client_connect(self): self.socket.connect(self.server_address) def client_close(self): self.socket.close() def run(self): while True: inp=input(&quot;&gt;&gt;: &quot;).strip() if not inp:continue l=inp.split() cmd=l[0] if hasattr(self,cmd): func=getattr(self,cmd) func(l) def put(self,args): cmd=args[0] filename=args[1] if not os.path.isfile(filename): print(&#x27;file:%s is not exists&#x27; %filename) return else: filesize=os.path.getsize(filename) head_dic=&#123;&#x27;cmd&#x27;:cmd,&#x27;filename&#x27;:os.path.basename(filename),&#x27;filesize&#x27;:filesize&#125; print(head_dic) head_json=json.dumps(head_dic) head_json_bytes=bytes(head_json,encoding=self.coding) head_struct=struct.pack(&#x27;i&#x27;,len(head_json_bytes)) self.socket.send(head_struct) self.socket.send(head_json_bytes) send_size=0 with open(filename,&#x27;rb&#x27;) as f: for line in f: self.socket.send(line) send_size+=len(line) print(send_size) else: print(&#x27;upload successful&#x27;)client=MYTCPClient((&#x27;127.0.0.1&#x27;,8080))client.run() 十五 作业听懂后可以试着完成：","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"30、异常处理","slug":"30、异常处理","date":"2018-05-13T06:04:30.000Z","updated":"2022-05-13T12:28:53.092Z","comments":true,"path":"2018/05/13/30、异常处理/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/30%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"目录： 什么是异常 异常处理 何时使用异常处理 一 什么是异常异常是程序发生错误的信号。程序一旦出现错误，便会产生一个异常，若程序中没有处理它，就会抛出该异常，程序的运行也随之终止。在Python中,错误触发的异常如下 而错误分成两种，一种是语法上的错误SyntaxError，这种错误应该在程序运行前就修改正确 12345&gt;&gt;&gt; if File &quot;&lt;stdin&gt;&quot;, line 1 if ^SyntaxError: invalid syntax 另一类就是逻辑错误，常见的逻辑错误如 12345678910111213141516171819202122232425# TypeError：数字类型无法与字符串类型相加1+’2’# ValueError：当字符串包含有非数字的值时，无法转成int类型num=input(&quot;&gt;&gt;: &quot;) #输入helloint(num)# NameError：引用了一个不存在的名字xx# IndexError：索引超出列表的限制l=[&#x27;egon&#x27;,&#x27;aa&#x27;]l[3]# KeyError：引用了一个不存在的keydic=&#123;&#x27;name&#x27;:&#x27;egon&#x27;&#125;dic[&#x27;age&#x27;]# AttributeError：引用的属性不存在class Foo: passFoo.x# ZeroDivisionError：除数不能为01/0 二 异常处理为了保证程序的容错性与可靠性，即在遇到错误时有相应的处理机制不会任由程序崩溃掉，我们需要对异常进行处理，处理的基本形式为 1234try: 被检测的代码块except 异常类型： 检测到异常，就执行这个位置的逻辑 举例 123456789101112try: print(&#x27;start...&#x27;) print(x) # 引用了一个不存在的名字，触发异常NameError print(&#x27;end...&#x27;)except NameError as e: # as语法将异常类型的值赋值给变量e，这样我们通过打印e便可以知道错误的原因 print(&#x27;异常值为：%s&#x27; %e)print(&#x27;run other code...&#x27;)#执行结果为start...异常值为：name &#x27;x&#x27; is not definedrun other code... 本来程序一旦出现异常就整体结束掉了，有了异常处理以后，在被检测的代码块出现异常时，被检测的代码块中异常发生位置之后的代码将不会执行，取而代之的是执行匹配异常的except子代码块，其余代码均正常运行。 当被检测的代码块中有可能触发不同类型的异常时，针对不同类型的异常： 如果我们想分别用不同的逻辑处理，需要用到多分支的except（类似于多分支的elif，从上到下依次匹配，匹配成功一次便不再匹配其他） 12345678try: 被检测的代码块except NameError: 触发NameError时对应的处理逻辑except IndexError: 触发IndexError时对应的处理逻辑except KeyError: 触发KeyError时对应的处理逻辑 举例 12345678910111213def convert_int(obj): try: res=int(obj) except ValueError as e: print(&#x27;ValueError: %s&#x27; %e) res=None except TypeError as e: print(&#x27;TypeError: %s&#x27; %e) res=None return resconvert_int(&#x27;egon&#x27;) # ValueError: invalid literal for int() with base 10: &#x27;egon&#x27;convert_int(&#123;&#x27;n&#x27;:1&#125;) # TypeError: int() argument must be a string, a bytes-like object or a number, not &#x27;dict&#x27; 如果我们想多种类型的异常统一用一种逻辑处理，可以将多个异常放到一个元组内，用一个except匹配 1234try: 被检测的代码块except (NameError,IndexError,TypeError): 触发NameError或IndexError或TypeError时对应的处理逻辑 举例 12345678910def convert_int(obj): try: res=int(obj) except (ValueError,TypeError): print(&#x27;argument must be number or numeric string&#x27;) res=None return resconvert_int(&#x27;egon&#x27;) # argument must be number or numeric stringconvert_int(&#123;&#x27;n&#x27;:1&#125;) # argument must be number or numeric string 如果我们想捕获所有异常并用一种逻辑处理，Python提供了一个万能异常类型Exception 12345678try: 被检测的代码块except NameError: 触发NameError时对应的处理逻辑except IndexError: 触发IndexError时对应的处理逻辑except Exception: 其他类型的异常统一用此处的逻辑处理 在多分支except之后还可以跟一个else（else必须跟在except之后，不能单独存在），只有在被检测的代码块没有触发任何异常的情况下才会执行else的子代码块 123456789try: 被检测的代码块except 异常类型1: passexcept 异常类型2: pass......else: 没有异常发生时执行的代码块 此外try还可以与finally连用，从语法上讲finally必须放到else之后，但可以使用try-except-finally的形式，也可以直接使用try-finally的形式。无论被检测的代码块是否触发异常，都会执行finally的子代码块，因此通常在finally的子代码块做一些回收资源的操作，比如关闭打开的文件、关闭数据库连接等 123456789101112try: 被检测的代码块except 异常类型1: pass except 异常类型2: pass...... else: 没有异常发生时执行的代码块finally: 无论有无异常发生都会执行的代码块 举例 123456789f=Nonetry: f=open(‘db.txt’,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) s=f.read().strip() int(s) # 若字符串s中包含非数字时则会触发异常ValueError # f.close() # 若上面的代码触发异常，则根本不可能执行到此处的代码，应该将关闭文件的操作放到finally中finally: if f: # 文件存在则f的值不为None f.close() 在不符合Python解释器的语法或逻辑规则时，是由Python解释器主动触发的各种类型的异常，而对于违反程序员自定制的各类规则，则需要由程序员自己来明确地触发异常，这就用到了raise语句，raise后必须是一个异常的类或者是异常的实例 123456789101112class Student: def __init__(self,name,age): if not isinstance(name,str): raise TypeError(&#x27;name must be str&#x27;) if not isinstance(age,int): raise TypeError(&#x27;age must be int&#x27;) self.name=name self.age=agestu1=Student(4573,18) # TypeError: name must be strstu2=Student(&#x27;egon&#x27;,&#x27;18&#x27;) # TypeError: age must be int 在内置异常不够用的情况下，我们可以通过继承内置的异常类来自定义异常类 123456789101112131415class PoolEmptyError(Exception): # 可以通过继承Exception来定义一个全新的异常 def __init__(self,value=&#x27;The proxy source is exhausted&#x27;): # 可以定制初始化方法 super(PoolEmptyError,self).__init__() self.value=value def __str__(self): # 可以定义该方法用来定制触发异常时打印异常值的格式 return &#x27;&lt; %s &gt;&#x27; %self.valueclass NetworkIOError(IOError): # 也可以在特定异常的基础上扩展一个相关的异常 passraise PoolEmptyError # __main__.PoolEmptyError: &lt; The proxy source is exhausted &gt;raise NetworkIOError(&#x27;连接被拒绝&#x27;) # __main__.NetworkIOError: 连接被拒绝 最后，Python还提供了一个断言语句assert expression，断定表达式expression成立，否则触发异常AssertionError，与raise-if-not的语义相同，如下 12345678age=&#x27;18&#x27;# 若表达式isinstance(age,int)返回值为False则触发异常AssertionErrorassert isinstance(age,int)# 等同于if not isinstance(age,int): raise AssertionError 三 何时使用异常处理在了解了异常处理机制后，本着提高程序容错性和可靠性的目的，读者可能会错误地认为应该尽可能多地为程序加上try…except…，这其是在过度消费程序的可读性，因为try…except本来就是你附加给程序的一种额外的逻辑，与你的主要工作是没有多大关系的。 如果错误发生的条件是“可预知的”，我们应该用if来进行”预防”，如下 12345age=input(&#x27;input your age&gt;&gt;: &#x27;).strip()if age.isdigit(): # 可预知只有满足字符串age是数字的条件，int(age)才不会触发异常， age=int(age)else: print(&#x27;You must enter the number&#x27;) 如果错误发生的条件“不可预知”，即异常一定会触发，那么我们才应该使用try…except语句来处理。例如我们编写一个下载网页内容的功能，网络发生延迟之类的异常是很正常的事，而我们根本无法预知在满足什么条件的情况下才会出现延迟，因而只能用异常处理机制了 12345678910111213141516import requestsfrom requests.exceptions import ConnectTimeout # 导入requests模块内自定义的异常def get(url): try: response=requests.get(url,timeout=3)#超过3秒未下载成功则触发ConnectTimeout异常 res=response.text except ConnectTimeout: print(&#x27;连接请求超时&#x27;) res=None except Exception: print(&#x27;网络出现其他异常&#x27;) res=None return resget(&#x27;https://www.python.org&#x27;)","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"29、元类","slug":"29、元类","date":"2018-05-13T06:04:29.000Z","updated":"2022-05-13T12:28:50.843Z","comments":true,"path":"2018/05/13/29、元类/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/29%E3%80%81%E5%85%83%E7%B1%BB/","excerpt":"","text":"元类介绍 class关键字创建类的流程分析 自定义袁磊控制类StanfordTeacher的创建 自定义元类控制类StanfordTeacher的调用 再看属性查找 作业 一 元类介绍什么是元类呢？一切源自于一句话：python中一切皆为对象。让我们先定义一个类，然后逐步分析 123456789class StanfordTeacher(object): school=&#x27;Stanford&#x27; def __init__(self,name,age): self.name=name self.age=age def say(self): print(&#x27;%s says welcome to the Stanford to learn Python&#x27; %self.name) 所有的对象都是实例化或者说调用类而得到的（调用类的过程称为类的实例化），比如对象t1是调用类StanfordTeacher得到的 12t1=StanfordTeacher(&#x27;lili&#x27;,18)print(type(t1)) #查看对象t1的类是&lt;class &#x27;__main__.StanfordTeacher&#x27;&gt; 如果一切皆为对象，那么类StanfordTeacher本质也是一个对象，既然所有的对象都是调用类得到的，那么StanfordTeacher必然也是调用了一个类得到的，这个类称为元类 1print(type(StanfordTeacher)) # 结果为&lt;class &#x27;type&#x27;&gt;，证明是调用了type这个元类而产生的StanfordTeacher，即默认的元类为type 二 class关键字创建类的流程分析上文我们基于python中一切皆为对象的概念分析出：我们用class关键字定义的类本身也是一个对象，负责产生该对象的类称之为元类（元类可以简称为类的类），内置的元类为type class关键字在帮我们创建类时，必然帮我们调用了元类StanfordTeacher&#x3D;type(…)，那调用type时传入的参数是什么呢？必然是类的关键组成部分，一个类有三大组成部分，分别是 1、类名class_name&#x3D;’StanfordTeacher’ 2、基类们class_bases&#x3D;(object,) 3、类的名称空间class_dic，类的名称空间是执行类体代码而得到的 调用type时会依次传入以上三个参数 综上，class关键字帮我们创建一个类应该细分为以下四个过程 补充：exec的用法 12345678910111213141516171819202122232425#exec：三个参数#参数一：包含一系列python代码的字符串#参数二：全局作用域（字典形式），如果不指定，默认为globals()#参数三：局部作用域（字典形式），如果不指定，默认为locals()#可以把exec命令的执行当成是一个函数的执行，会将执行期间产生的名字存放于局部名称空间中g=&#123; &#x27;x&#x27;:1, &#x27;y&#x27;:2&#125;l=&#123;&#125;exec(&#x27;&#x27;&#x27;global x,zx=100z=200m=300&#x27;&#x27;&#x27;,g,l)print(g) #&#123;&#x27;x&#x27;: 100, &#x27;y&#x27;: 2,&#x27;z&#x27;:200,......&#125;print(l) #&#123;&#x27;m&#x27;: 300&#125;","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"28、反射、内置方法","slug":"28、反射、内置方法","date":"2018-05-13T06:04:28.000Z","updated":"2022-05-13T12:28:48.710Z","comments":true,"path":"2018/05/13/28、反射、内置方法/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/28%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、反射python是动态语言，而反射(reflection)机制被视为动态语言的关键。 反射机制指的是在程序的运行状态中 对于任意一个类，都可以知道这个类的所有属性和方法； 对于任意一个对象，都能够调用他的任意方法和属性。 这种动态获取程序信息以及动态调用对象的功能称为反射机制。 在python中实现反射非常简单，在程序运行过程中，如果我们获取一个不知道存有何种属性的对象，若想操作其内部属性，可以先通过内置函数dir来获取任意一个类或者对象的属性列表，列表中全为字符串格式 123456789&gt;&gt;&gt; class People:... def __init__(self,name,age,gender):... self.name=name... self.age=age... self.gender=gender... &gt;&gt;&gt; obj=People(&#x27;egon&#x27;,18,&#x27;male&#x27;)&gt;&gt;&gt; dir(obj) # 列表中查看到的属性全为字符串[......,&#x27;age&#x27;, &#x27;gender&#x27;, &#x27;name&#x27;] 接下来就是想办法通过字符串来操作对象的属性了，这就涉及到内置函数hasattr、getattr、setattr、delattr的使用了（Python中一切皆对象，类和对象都可以被这四个函数操作，用法一样） 1234567891011121314151617class Teacher: def __init__(self,full_name): self.full_name =full_namet=Teacher(&#x27;Egon Lin&#x27;)# hasattr(object,&#x27;name&#x27;)hasattr(t,&#x27;full_name&#x27;) # 按字符串&#x27;full_name&#x27;判断有无属性t.full_name# getattr(object, &#x27;name&#x27;, default=None)getattr(t,&#x27;full_name&#x27;,None) # 等同于t.full_name,不存在该属性则返回默认值None# setattr(x, &#x27;y&#x27;, v)setattr(t,&#x27;age&#x27;,18) # 等同于t.age=18# delattr(x, &#x27;y&#x27;)delattr(t,&#x27;age&#x27;) # 等同于del t.age 基于反射可以十分灵活地操作对象的属性，比如将用户交互的结果反射到具体的功能执行 12345678910111213141516171819&gt;&gt;&gt; class FtpServer:... def serve_forever(self):... while True:... inp=input(&#x27;input your cmd&gt;&gt;: &#x27;).strip()... cmd,file=inp.split()... if hasattr(self,cmd): # 根据用户输入的cmd，判断对象self有无对应的方法属性... func=getattr(self,cmd) # 根据字符串cmd，获取对象self对应的方法属性... func(file)... def get(self,file):... print(&#x27;Downloading %s...&#x27; %file)... def put(self,file):... print(&#x27;Uploading %s...&#x27; %file)... &gt;&gt;&gt; server=FtpServer()&gt;&gt;&gt; server.serve_forever()input your cmd&gt;&gt;: get a.txtDownloading a.txt...input your cmd&gt;&gt;: put a.txtUploading a.txt... 二、内置方法Python的Class机制内置了很多特殊的方法来帮助使用者高度定制自己的类，这些内置方法都是以双下划线开头和结尾的，会在满足某种条件时自动触发，我们以常用的__str__和__del__为例来简单介绍它们的使用。 __str__方法会在对象被打印时自动触发，print功能打印的就是它的返回值，我们通常基于方法来定制对象的打印信息，该方法必须返回字符串类型 12345678910&gt;&gt;&gt; class People:... def __init__(self,name,age):... self.name=name... self.age=age... def __str__(self):... return &#x27;&lt;Name:%s Age:%s&gt;&#x27; %(self.name,self.age) #返回类型必须是字符串... &gt;&gt;&gt; p=People(&#x27;lili&#x27;,18)&gt;&gt;&gt; print(p) #触发p.__str__()，拿到返回值后进行打印&lt;Name:lili Age:18&gt; __del__会在对象被删除时自动触发。由于Python自带的垃圾回收机制会自动清理Python程序的资源，所以当一个对象只占用应用程序级资源时，完全没必要为对象定制__del__方法，但在产生一个对象的同时涉及到申请系统资源（比如系统打开的文件、网络连接等）的情况下，关于系统资源的回收，Python的垃圾回收机制便派不上用场了，需要我们为对象定制该方法，用来在对象被删除时自动触发回收系统资源的操作 1234567class MySQL: def __init__(self,ip,port): self.conn=connect(ip,port) # 伪代码，发起网络连接，需要占用系统资源 def __del__(self): self.conn.close() # 关闭网络连接，回收系统资源obj=MySQL(&#x27;127.0.0.1&#x27;,3306) # 在对象obj被删除时，自动触发obj.__del__() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Student: school = &#x27;SH&#x27; def __init__(self, name): self.name = name def func(self): return self.nameclass Teacher(Student): def __init__(self, name, age): # super(Student, self).__init__(name) # python2中 super().__init__(name) # python3中 self.age = age def __str__(self): return self.name # 只能是字符串 def __del__(self): print(&#x27;deeeee&#x27;) # 删除后输出内容 def __getattr__(self, item): print(&#x27;访问属性不存在输出&#x27;) def __setattr__(self, key, value): # self.key = value # 会无限递归 self.__dict__[key] = value print(&#x27;设置值的时候输出，如果初始化中有自动设值也执行，递归深度一般为1000&#x27;) def __call__(self, *args, **kwargs): print(&#x27;对象加()调用时执行&#x27;)&quot;&quot;&quot;gte 小于等于lte 小于等于&quot;&quot;&quot;obj = Teacher(&#x27;cx&#x27;, 18)# del objprint(obj.__dict__)obj()&quot;&quot;&quot;NameErrorSyntaxErrorAttributeErrorKeyErrorTypeErrorZeroDivisionError&quot;&quot;&quot;try: print(&#x27;a&#x27;) # 要检测的代码except KeyError as e1: print(&#x27;Key&#x27;)except NameError as e2: print()except TypeError as e3: print()except Exception as e: print(&#x27;其他所有错误在这被捕捉并执行下面代码&#x27;)else: print(&#x27;没有错误则执行&#x27;) # else以及以上的代码只会执行一种finally: print(&#x27;不管有没有异常都会执行的代码&#x27;)l = [1, 2, 3]if len(l) &lt;5: raise Exception(&#x27;断言失败&#x27;) # 抛出异常: raise Execption/TypeErroeassert len(l) == 3 # 当l长度为3是抛出异常","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"27、绑定方法与非绑定方法","slug":"27、绑定方法与非绑定方法","date":"2018-05-13T06:04:27.000Z","updated":"2022-05-13T12:28:45.913Z","comments":true,"path":"2018/05/13/27、绑定方法与非绑定方法/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/27%E3%80%81%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、绑定方法与非绑定方法类中定义的函数分为两大类：绑定方法和非绑定方法 其中绑定方法又分为绑定到对象的对象方法和绑定到类的类方法。 在类中正常定义的函数默认是绑定到对象的，而为某个函数加上装饰器@classmethod后，该函数就绑定到了类。 我们在之前的章节中已经介绍过对象方法了，本节我们主要介绍类方法。类方法通常用来在__init__的基础上提供额外的初始化实例的方式 1234567891011121314151617# 配置文件settings.py的内容HOST=&#x27;127.0.0.1&#x27;PORT=3306# 类方法的应用import settingsclass MySQL: def __init__(self,host,port): self.host=host self.port=port @classmethod def from_conf(cls): # 从配置文件中读取配置进行初始化 return cls(settings.HOST,settings.PORT)&gt;&gt;&gt; MySQL.from_conf # 绑定到类的方法&lt;bound method MySQL.from_conf of &lt;class ‘__main__.MySQL&#x27;&gt;&gt;&gt;&gt;&gt; conn=MySQL.from_conf() # 调用类方法，自动将类MySQL当作第一个参数传给cls 绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍然是类，也就是说这种调用是没有意义的，并且容易引起混淆，这也是Python的对象系统与其他面向对象语言对象系统的区别之一，比如Smalltalk和Ruby中，绑定到类的方法与绑定到对象的方法是严格区分开的。 二、非绑定方法为类中某个函数加上装饰器@staticmethod后，该函数就变成了非绑定方法，也称为静态方法。该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，因而没有自动传值那么一说 123456789101112131415161718import uuidclass MySQL: def __init__(self,host,port): self.id=self.create_id() self.host=host self.port=port @staticmethod def create_id(): return uuid.uuid1()&gt;&gt;&gt; conn=MySQL(‘127.0.0.1&#x27;,3306)&gt;&gt;&gt; print(conn.id) #100365f6-8ae0-11e7-a51e-0088653ea1ec# 类或对象来调用create_id发现都是普通函数，而非绑定到谁的方法&gt;&gt;&gt; MySQL.create_id&lt;function MySQL.create_id at 0x1025c16a8&gt;&gt;&gt;&gt; conn.create_id&lt;function MySQL.create_id at 0x1025c16a8&gt; 总结绑定方法与非绑定方法的使用：若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法。","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"26、多态性与鸭子类型","slug":"26、多态性与鸭子类型","date":"2018-05-13T06:04:26.000Z","updated":"2022-05-13T12:28:43.715Z","comments":true,"path":"2018/05/13/26、多态性与鸭子类型/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/26%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"多态与多态性多态指的是一类事物有多种形态，比如动物有多种形态：猫、狗、猪 1234567891011121314151617class Animal: #同一类事物:动物 def talk(self): passclass Cat(Animal): #动物的形态之一:猫 def talk(self): print(&#x27;喵喵喵&#x27;)class Dog(Animal): #动物的形态之二:狗 def talk(self): print(&#x27;汪汪汪&#x27;)class Pig(Animal): #动物的形态之三:猪 def talk(self): print(&#x27;哼哼哼&#x27;)#实例化得到三个对象&gt;&gt;&gt; cat=Cat()&gt;&gt;&gt; dog=Dog()&gt;&gt;&gt; pig=Pig() 多态性指的是可以在不用考虑对象具体类型的情况下而直接使用对象，这就需要在设计时，把对象的使用方法统一成一种：例如cat、dog、pig都是动物,但凡是动物肯定有talk方法，于是我们可以不用考虑它们三者的具体是什么类型的动物,而直接使用 123456&gt;&gt;&gt; cat.talk()喵喵喵&gt;&gt;&gt; dog.talk()汪汪汪&gt;&gt;&gt; pig.talk()哼哼哼 更进一步,我们可以定义一个统一的接口来使用 123456789&gt;&gt;&gt; def Talk(animal):... animal.talk()... &gt;&gt;&gt; Talk(cat)喵喵喵&gt;&gt;&gt; Talk(dog)汪汪汪&gt;&gt;&gt; Talk(pig)哼哼哼 Python中一切皆对象，本身就支持多态性 123456789# 我们可以在不考虑三者类型的情况下直接使用统计三个对象的长度s.__len__()l.__len__()t.__len__()# Python内置了一个统一的接口len(s)len(l)len(t) 多态性的好处在于增强了程序的灵活性和可扩展性，比如通过继承Animal类创建了一个新的类，实例化得到的对象obj，可以使用相同的方式使用obj.talk() 1234567&gt;&gt;&gt; class Wolf(Animal): #动物的另外一种形态：狼... def talk(self):... print(&#x27;嗷...&#x27;)... &gt;&gt;&gt; wolf=Wolf() # 实例出一头狼&gt;&gt;&gt; wolf.talk() # 使用者根本无需关心wolf是什么类型而调用talk嗷... 综上我们得知，多态性的本质在于不同的类中定义有相同的方法名，这样我们就可以不考虑类而统一用一种方式去使用对象，可以通过在父类引入抽象类的概念来硬性限制子类必须有某些方法名 12345678910111213import abc# 指定metaclass属性将类设置为抽象类，抽象类本身只是用来约束子类的，不能被实例化class Animal(metaclass=abc.ABCMeta): @abc.abstractmethod # 该装饰器限制子类必须定义有一个名为talk的方法 def talk(self): # 抽象方法中无需实现具体的功能 passclass Cat(Animal): # 但凡继承Animal的子类都必须遵循Animal规定的标准 def talk(self): passcat=Cat() # 若子类中没有一个名为talk的方法则会抛出异常TypeError，无法实例化 但其实我们完全可以不依赖于继承，只需要制造出外观和行为相同对象，同样可以实现不考虑对象类型而使用对象，这正是Python崇尚的“鸭子类型”（duck typing）：“如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子”。比起继承的方式，鸭子类型在某种程度上实现了程序的松耦合度，如下 123456789101112#二者看起来都像文件,因而就可以当文件一样去用，然而它们并没有直接的关系class Txt: #Txt类有两个与文件类型同名的方法，即read和write def read(self): pass def write(self): passclass Disk: #Disk类也有两个与文件类型同名的方法：read和write def read(self): pass def write(self): pass","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"25、继承与派生","slug":"25、继承与派生","date":"2018-05-13T06:04:25.000Z","updated":"2022-05-13T12:28:41.556Z","comments":true,"path":"2018/05/13/25、继承与派生/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/25%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/","excerpt":"","text":"继承介绍 继承与抽象 属性查找 继承的实现原理 菱形问题 继承原理 深度优先和广度优先 python Mixin机制 派生与方法重用 组合 一 继承介绍继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类 123456789class ParentClass1: #定义父类 passclass ParentClass2: #定义父类 passclass SubClass1(ParentClass1): #单继承 passclass SubClass2(ParentClass1,ParentClass2) #多继承 通过类的内置属性__bases__可以查看类继承的所有父类 12&gt;&gt;&gt; SubClass2__bases__(&lt;class &#x27;__main__.ParentClass1&#x27;&gt;, &lt;class &#x27;__main__.ParentClass2&#x27;&gt;) 在Python2中有经典类与新式类之分，没有显式地继承object类的类，以及该类的子类，都是经典类，显式地继承object的类，以及该类的子类，都是新式类。而在Python3中，即使没有显式地继承object，也会默认继承该类，如下 1234&gt;&gt;&gt; ParentClass1.__bases__(&lt;class ‘object&#x27;&gt;,)&gt;&gt;&gt; ParentClass2.__bases__(&lt;class &#x27;object&#x27;&gt;,) 因而在Python3中统一都是新式类，关于经典类与新式类的区别，我们稍后讨论 1提示：object类提供了一些常用内置方法的实现，如用来在打印对象时返回字符串的内置方法__str__ 二 继承与抽象要找出类与类之间的继承关系，需要先抽象，再继承。抽象即总结相似之处，总结对象之间的相似之处得到类，总结类与类之间的相似之处就可以得到父类，如下图所示 基于抽象的结果，我们就找到了继承关系 基于上图我们可以看出类与类之间的继承指的是什么’是’什么的关系（比如人类，猪类，猴类都是动物类）。子类可以继承／遗传父类所有的属性，因而继承可以用来解决类与类之间的代码重用性问题。比如我们按照定义Student类的方式再定义一个Teacher类 123456789class Teacher: school = &#x27;清华大学&#x27; def __init__(self,name,sex,age): self.name=name self.sex=sex self.age=age def teach(self): print(&#x27;%s is teaching&#x27; % self.name) 类Teacher与Student之间存在重复的代码，老师与学生都是人类，所以我们可以得出如下继承关系，实现代码重用 123456789101112131415class People: school=&#x27;清华大学&#x27; def __init__(self,name,sex,age): self.name=name self.sex=sex self.age=ageclass Student(People): def choose(self): print(&#x27;%s is choosing a course&#x27; %self.name)class Teacher(People): def teach(self): print(&#x27;%s is teaching&#x27; %self.name) Teacher类内并没有定义__init__方法，但是会从父类中找到__init__,因而仍然可以正常实例化，如下 123&gt;&gt;&gt; teacher1=Teacher(&#x27;lili&#x27;,&#x27;male&#x27;,18)&gt;&gt;&gt; teacher1.school,teacher1.name,teacher1.sex,teacher1.age(&#x27;清华大学&#x27;, &#x27;lili&#x27;, &#x27;male&#x27;, 18) 三 属性查找有了继承关系，对象在查找属性时，先从对象自己的__dict__中找，如果没有则去子类中找，然后再去父类中找…… 1234567891011121314151617&gt;&gt;&gt; class Foo:... def f1(self):... print(&#x27;Foo.f1&#x27;)... def f2(self):... print(&#x27;Foo.f2&#x27;)... self.f1()... &gt;&gt;&gt; class Bar(Foo):... def f1(self):... print(&#x27;Foo.f1&#x27;)... &gt;&gt;&gt; b=Bar()&gt;&gt;&gt; b.f2()Foo.f2Foo.f1# b.f2()会在父类Foo中找到f2，先打印Foo.f2,然后执行到self.f1(),即b.f1()，仍会按照：对象本身-&gt;类Bar-&gt;父类Foo的顺序依次找下去，在类Bar中找到f1，因而打印结果为Foo.f1 父类如果不想让子类覆盖自己的方法，可以采用双下划线开头的方式将方法设置为私有的 12345678910111213141516&gt;&gt;&gt; class Foo:... def __f1(self): # 变形为_Foo__fa... print(&#x27;Foo.f1&#x27;) ... def f2(self):... print(&#x27;Foo.f2&#x27;)... self.__f1() # 变形为self._Foo__fa,因而只会调用自己所在的类中的方法... &gt;&gt;&gt; class Bar(Foo):... def __f1(self): # 变形为_Bar__f1... print(&#x27;Foo.f1&#x27;)... &gt;&gt;&gt; &gt;&gt;&gt; b=Bar()&gt;&gt;&gt; b.f2() #在父类中找到f2方法，进而调用b._Foo__f1()方法，同样是在父类中找到该方法Foo.f2Foo.f1 四 继承的实现原理1、菱形问题大多数面向对象语言都不支持多继承，而在Python中，一个子类是可以同时继承多个父类的，这固然可以带来一个子类可以对多个不同父类加以重用的好处，但也有可能引发著名的 Diamond problem菱形问题(或称钻石问题，有时候也被称为“死亡钻石”)，菱形其实就是对下面这种继承结构的形象比喻 1A类在顶部，B类和C类分别位于其下方，D类在底部将两者连接在一起形成菱形。 这种继承结构下导致的问题称之为菱形问题：如果A中有一个方法，B和&#x2F;或C都重写了该方法，而D没有重写它，那么D继承的是哪个版本的方法：B的还是C的？如下所示 123456789101112131415161718192021class A(object): def test(self): print(&#x27;from A&#x27;)class B(A): def test(self): print(&#x27;from B&#x27;)class C(A): def test(self): print(&#x27;from C&#x27;)class D(B,C): passobj = D()obj.test() # 结果为：from B 要想搞明白obj.test()是如何找到方法test的，需要了解python的继承实现原理 2、继承原理python到底是如何实现继承的呢？ 对于你定义的每一个类，Python都会计算出一个方法解析顺序(MRO)列表，该MRO列表就是一个简单的所有基类的线性顺序列表，如下 12&gt;&gt;&gt; D.mro() # 新式类内置了mro方法可以查看线性列表的内容，经典类没有该内置该方法[&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;] python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则: 1231.子类会先于父类被检查2.多个父类会根据它们在列表中的顺序被检查3.如果对下一个类存在两个合法的选择,选择第一个父类 所以obj.test()的查找顺序是，先从对象obj本身的属性里找方法test，没有找到，则参照属性查找的发起者(即obj)所处类D的MRO列表来依次检索，首先在类D中未找到，然后再B中找到方法test ps： 121.由对象发起的属性查找，会从对象自身的属性里检索，没有则会按照对象的类.mro()规定的顺序依次找下去，2.由类发起的属性查找，会按照当前类.mro()规定的顺序依次找下去， 3、深度优先和广度优先参照下述代码，多继承结构为非菱形结构，此时，会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性 123456789101112131415161718192021222324252627282930313233343536373839class E: def test(self): print(&#x27;from E&#x27;)class F: def test(self): print(&#x27;from F&#x27;)class B(E): def test(self): print(&#x27;from B&#x27;)class C(F): def test(self): print(&#x27;from C&#x27;)class D: def test(self): print(&#x27;from D&#x27;)class A(B, C, D): # def test(self): # print(&#x27;from A&#x27;) passprint(A.mro())&#x27;&#x27;&#x27;[&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.E&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.F&#x27;&gt;, &lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]&#x27;&#x27;&#x27;obj = A()obj.test() # 结果为：from B# 可依次注释上述类中的方法test来进行验证 如果继承关系为菱形结构，那么经典类与新式类会有不同MRO，分别对应属性的两种查找方式：深度优先和广度优先 1234567891011121314151617181920212223242526272829303132class G: # 在python2中，未继承object的类及其子类，都是经典类 def test(self): print(&#x27;from G&#x27;)class E(G): def test(self): print(&#x27;from E&#x27;)class F(G): def test(self): print(&#x27;from F&#x27;)class B(E): def test(self): print(&#x27;from B&#x27;)class C(F): def test(self): print(&#x27;from C&#x27;)class D(G): def test(self): print(&#x27;from D&#x27;)class A(B,C,D): # def test(self): # print(&#x27;from A&#x27;) passobj = A()obj.test() # 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;G-&gt;C-&gt;F-&gt;D-&gt;object# 可依次注释上述类中的方法test来进行验证,注意请在python2.x中进行测试 1234567891011121314151617181920212223242526272829303132class G(object): def test(self): print(&#x27;from G&#x27;)class E(G): def test(self): print(&#x27;from E&#x27;)class F(G): def test(self): print(&#x27;from F&#x27;)class B(E): def test(self): print(&#x27;from B&#x27;)class C(F): def test(self): print(&#x27;from C&#x27;)class D(G): def test(self): print(&#x27;from D&#x27;)class A(B,C,D): # def test(self): # print(&#x27;from A&#x27;) passobj = A()obj.test() # 如上图，查找顺序为:obj-&gt;A-&gt;B-&gt;E-&gt;C-&gt;F-&gt;D-&gt;G-&gt;object# 可依次注释上述类中的方法test来进行验证 4、Python Mixins机制一个子类可以同时继承多个父类，这样的设计常被人诟病，一来它有可能导致可恶的菱形问题，二来在人的世界观里继承应该是个”is-a”关系。 比如轿车类之所以可以继承交通工具类，是因为基于人的世界观，我们可以说：轿车是一个(“is-a”)交通工具，而在人的世界观里，一个物品不可能是多种不同的东西，因此多重继承在人的世界观里是说不通的，它仅仅只是代码层面的逻辑。不过有没有这种情况，一个类的确是需要继承多个类呢？ 答案是有，我们还是拿交通工具来举例子: 民航飞机、直升飞机、轿车都是一个（is-a）交通工具，前两者都有一个功能是飞行fly，但是轿车没有，所以如下所示我们把飞行功能放到交通工具这个父类中是不合理的 123456789101112131415161718class Vehicle: # 交通工具 def fly(self): &#x27;&#x27;&#x27; 飞行功能相应的代码 &#x27;&#x27;&#x27; print(&quot;I am flying&quot;)class CivilAircraft(Vehicle): # 民航飞机 passclass Helicopter(Vehicle): # 直升飞机 passclass Car(Vehicle): # 汽车并不会飞，但按照上述继承关系，汽车也能飞了 pass 但是如果民航飞机和直升机都各自写自己的飞行fly方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会重复代码将会越来越多）。 怎么办？？？为了尽可能地重用代码，那就只好在定义出一个飞行器的类，然后让民航飞机和直升飞机同时继承交通工具以及飞行器两个父类，这样就出现了多重继承。这时又违背了继承必须是”is-a”关系。这个难题该怎么解决？ 不同的语言给出了不同的方法，让我们先来了解Java的处理方法。Java提供了接口interface功能，来实现多重继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 抽象基类：交通工具类public abstract class Vehicle &#123;&#125;// 接口：飞行器public interface Flyable &#123; public void fly();&#125;// 类：实现了飞行器接口的类，在该类中实现具体的fly方法，这样下面民航飞机与直升飞机在实现fly时直接重用即可public class FlyableImpl implements Flyable &#123; public void fly() &#123; System.out.println(&quot;I am flying&quot;); &#125;&#125;// 民航飞机，继承自交通工具类，并实现了飞行器接口public class CivilAircraft extends Vehicle implements Flyable &#123; private Flyable flyable; public CivilAircraft() &#123; flyable = new FlyableImpl(); &#125; public void fly() &#123; flyable.fly(); &#125;&#125;// 直升飞机，继承自交通工具类，并实现了飞行器接口public class Helicopter extends Vehicle implements Flyable &#123; private Flyable flyable; public Helicopter() &#123; flyable = new FlyableImpl(); &#125; public void fly() &#123; flyable.fly(); &#125;&#125;// 汽车，继承自交通工具类，public class Car extends Vehicle &#123;&#125; 现在我们的飞机同时具有了交通工具及飞行器两种属性，而且我们不需要重写飞行器中的飞行方法，同时我们没有破坏单一继承的原则。飞机就是一种交通工具，可飞行的能力是飞机的属性，通过继承接口来获取。 回到主题，Python语言可没有接口功能，但Python提供了Mixins机制，简单来说Mixins机制指的是子类混合(mixin)不同类的功能，而这些类采用统一的命名规范（例如Mixin后缀），以此标识这些类只是用来混合功能的，并不是用来标识子类的从属”is-a”关系的，所以Mixins机制本质仍是多继承，但同样遵守”is-a”关系，如下 123456789101112131415161718192021222324class Vehicle: # 交通工具 passclass FlyableMixin: def fly(self): &#x27;&#x27;&#x27; 飞行功能相应的代码 &#x27;&#x27;&#x27; print(&quot;I am flying&quot;)class CivilAircraft(FlyableMixin, Vehicle): # 民航飞机 passclass Helicopter(FlyableMixin, Vehicle): # 直升飞机 passclass Car(Vehicle): # 汽车 pass# ps: 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路 可以看到，上面的CivilAircraft、Helicopter类实现了多继承，不过它继承的第一个类我们起名为FlyableMixin，而不是Flyable，这个并不影响功能，但是会告诉后来读代码的人，这个类是一个Mixin类，表示混入(mix-in)，这种命名方式就是用来明确地告诉别人（python语言惯用的手法），这个类是作为功能添加到子类中，而不是作为父类，它的作用同Java中的接口。所以从含义上理解，CivilAircraft、Helicopter类都只是一个Vehicle，而不是一个飞行器。 使用Mixin类实现多重继承要非常小心 首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀 其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类 然后，它不依赖于子类的实现 最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了） Mixins是从多个类中重用代码的好方法，但是需要付出相应的代价，我们定义的Minx类越多，子类的代码可读性就会越差，并且更恶心的是，在继承的层级变多时，代码阅读者在定位某一个方法到底在何处调用时会晕头转向，如下 123456789101112131415161718192021222324252627282930class Displayer: def display(self, message): print(message)class LoggerMixin: def log(self, message, filename=&#x27;logfile.txt&#x27;): with open(filename, &#x27;a&#x27;) as fh: fh.write(message) def display(self, message): super().display(message) # super的用法请参考下一小节 self.log(message)class MySubClass(LoggerMixin, Displayer): def log(self, message): super().log(message, filename=&#x27;subclasslog.txt&#x27;) obj = MySubClass()obj.display(&quot;This string will be shown and logged in subclasslog.txt&quot;)# 属性查找的发起者是obj,所以会参照类MySubClass的MRO来检索属性#[&lt;class &#x27;__main__.MySubClass&#x27;&gt;, &lt;class &#x27;__main__.LoggerMixin&#x27;&gt;, &lt;class &#x27;__main__.Displayer&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]# 1、首先会去对象obj的类MySubClass找方法display，没有则去类LoggerMixin中找，找到开始执行代码# 2、执行LoggerMixin的第一行代码：执行super().display(message)，参照MySubClass.mro(),super会去下一个类即类Displayer中找，找到display，开始执行代码，打印消息&quot;This string will be shown and logged in subclasslog.txt&quot;# 3、执行LoggerMixin的第二行代码：self.log(message)，self是对象obj，即obj.log(message)，属性查找的发起者为obj，所以会按照其类MySubClass.mro(),即MySubClass-&gt;LoggerMixin-&gt;Displayer-&gt;object的顺序查找，在MySubClass中找到方法log，开始执行super().log(message, filename=&#x27;subclasslog.txt&#x27;)，super会按照MySubClass.mro()查找下一个类，在类LoggerMixin中找到log方法开始执行，最终将日志写入文件subclasslog.txt ps：课外了解小知识 12345Java只允许接口的多重继承。接口本质上是抽象基类，具有所有抽象方法，没有数据成员。与java一样，python也有抽象类的概念但是同样需要借助模块实现，抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化，继承的子类必须实现抽象基类规定的方法，这样便可保证始终只有一个特定方法或属性的实现，并且不会产生歧义，因而也可以起到避免菱形问题的作用java的interface：https://www.cnblogs.com/linhaifeng/articles/7340153.html#_label6python的抽象基类：https://www.cnblogs.com/linhaifeng/articles/7340153.html#_label7 五 派生与方法重用子类可以派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找，例如每个老师还有职称这一属性，我们就需要在Teacher类中定义该类自己的__init__覆盖父类的 1234567891011121314151617181920&gt;&gt;&gt; class People:... school=&#x27;清华大学&#x27;... ... def __init__(self,name,sex,age):... self.name=name... self.sex=sex... self.age=age... &gt;&gt;&gt; class Teacher(People):... def __init__(self,name,sex,age,title): # 派生... self.name=name... self.sex=sex... self.age=age... self.title=title... def teach(self):... print(&#x27;%s is teaching&#x27; %self.name)... &gt;&gt;&gt; obj=Teacher(&#x27;lili&#x27;,&#x27;female&#x27;,28,&#x27;高级讲师&#x27;) #只会找自己类中的__init__，并不会自动调用父类的&gt;&gt;&gt; obj.name,obj.sex,obj.age,obj.title(&#x27;lili&#x27;, &#x27;female&#x27;, 28, &#x27;高级讲师&#x27;) 很明显子类Teacher中__init__内的前三行又是在写重复代码，若想在子类派生出的方法内重用父类的功能，有两种实现方式 方法一：“指名道姓”地调用某一个类的函数 1234567&gt;&gt;&gt; class Teacher(People):... def __init__(self,name,sex,age,title):... People.__init__(self,name,age,sex) #调用的是函数,因而需要传入self... self.title=title... def teach(self):... print(&#x27;%s is teaching&#x27; %self.name)... 方法二：super() 调用super()会得到一个特殊的对象，该对象专门用来引用父类的属性，且严格按照MRO规定的顺序向后查找 1234567&gt;&gt;&gt; class Teacher(People):... def __init__(self,name,sex,age,title):... super().__init__(name,age,sex) #调用的是绑定方法，自动传入self... self.title=title... def teach(self):... print(&#x27;%s is teaching&#x27; %self.name)... 提示：在Python2中super的使用需要完整地写成super(自己的类名,self) ,而在python3中可以简写为super()。 这两种方式的区别是：方式一是跟继承没有关系的，而方式二的super()是依赖于继承的，并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找 1234567891011121314151617&gt;&gt;&gt; #A没有继承B... class A:... def test(self):... super().test()... &gt;&gt;&gt; class B:... def test(self):... print(&#x27;from B&#x27;)... &gt;&gt;&gt; class C(A,B):... pass... &gt;&gt;&gt; C.mro() # 在代码层面A并不是B的子类，但从MRO列表来看，属性查找时，就是按照顺序C-&gt;A-&gt;B-&gt;object，B就相当于A的“父类”[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;,&lt;class ‘object&#x27;&gt;]&gt;&gt;&gt; obj=C()&gt;&gt;&gt; obj.test() # 属性查找的发起者是类C的对象obj，所以中途发生的属性查找都是参照C.mro()from B obj.test()首先找到A下的test方法，执行super().test()会基于MRO列表(以C.mro()为准)当前所处的位置继续往后查找()，然后在B中找到了test方法并执行。 关于在子类中重用父类功能的这两种方式，使用任何一种都可以，但是在最新的代码中还是推荐使用super() 六 组合在一个类中以另外一个类的对象作为数据属性，称为类的组合。组合与继承都是用来解决代码的重用性问题。不同的是：继承是一种“是”的关系，比如老师是人、学生是人，当类之间有很多相同的之处，应该使用继承；而组合则是一种“有”的关系，比如老师有生日，老师有多门课程，当类之间有显著不同，并且较小的类是较大的类所需要的组件时，应该使用组合，如下示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Course: def __init__(self,name,period,price): self.name=name self.period=period self.price=price def tell_info(self): print(&#x27;&lt;%s %s %s&gt;&#x27; %(self.name,self.period,self.price))class Date: def __init__(self,year,mon,day): self.year=year self.mon=mon self.day=day def tell_birth(self): print(&#x27;&lt;%s-%s-%s&gt;&#x27; %(self.year,self.mon,self.day))class People: school=&#x27;清华大学&#x27; def __init__(self,name,sex,age): self.name=name self.sex=sex self.age=age#Teacher类基于继承来重用People的代码，基于组合来重用Date类和Course类的代码class Teacher(People): #老师是人 def __init__(self,name,sex,age,title,year,mon,day): super().__init__(name,age,sex) self.birth=Date(year,mon,day) #老师有生日 self.courses=[] #老师有课程，可以在实例化后，往该列表中添加Course类的对象 def teach(self): print(&#x27;%s is teaching&#x27; %self.name)python=Course(&#x27;python&#x27;,&#x27;3mons&#x27;,3000.0)linux=Course(&#x27;linux&#x27;,&#x27;5mons&#x27;,5000.0)teacher1=Teacher(&#x27;lili&#x27;,&#x27;female&#x27;,28,&#x27;博士生导师&#x27;,1990,3,23)# teacher1有两门课程teacher1.courses.append(python)teacher1.courses.append(linux)# 重用Date类的功能teacher1.birth.tell_birth()# 重用Course类的功能for obj in teacher1.courses: obj.tell_info() 此时对象teacher1集对象独有的属性、Teacher类中的内容、Course类中的内容于一身（都可以访问到），是一个高度整合的产物","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"24、封装","slug":"24、封装","date":"2018-05-13T06:04:24.000Z","updated":"2022-05-13T12:28:39.357Z","comments":true,"path":"2018/05/13/24、封装/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/24%E3%80%81%E5%B0%81%E8%A3%85/","excerpt":"","text":"引入 隐藏属性 开放接口 隐藏数据接口 隐藏函数接口 property 一 引入面向对象编程有三大特性：封装、继承、多态，其中最重要的一个特性就是封装。封装指的就是把数据与功能都整合到一起，听起来是不是很熟悉，没错，我们之前所说的”整合“二字其实就是封装的通俗说法。除此之外，针对封装到对象或者类中的属性，我们还可以严格控制对它们的访问，分两步实现：隐藏与开放接口 二 隐藏属性Python的Class机制采用双下划线开头的方式将属性隐藏起来（设置成私有的），但其实这仅仅只是一种变形操作，类中所有双下滑线开头的属性都会在类定义阶段、检测语法时自动变成“_类名__属性名”的形式： 123456789101112131415class Foo: __N=0 # 变形为__Foo__N def __init(self): # 定义函数时，会检测语法函数，所以__开头的属性也会变形 self.__x = 10 # 变形为self._Foo__x def __f1(self): # 变形为_Foo__f1 print(&#x27;__f1 run&#x27;) def f2(self): # 定义函数时，会检测语法，所以__开头的属性也会变形 self.__f1(): # 变形为self.Foo__f1()print(Foo.__N): # 报错AttributeError：类Foo没有属性__Nobj = Foo()print(obj.__x): # 报错AttributeError：对象obj没有属性__x 这种变形需要注意的问题是： 1、在类外部无法直接访问双下滑线开头的属性，但知道了类名和属性名就可以拼出名字：_类名__属性，然后就可以访问了，如Foo._A__N，所以说这种操作并没有严格意义上地限制外部访问，仅仅只是一种语法意义上的变形。 123456789101112&gt;&gt;&gt; Foo.__dict__mappingproxy(&#123;..., &#x27;_Foo__N&#x27;: 0, ...&#125;)&gt;&gt;&gt; obj.__dict__&#123;&#x27;_Foo__x&#x27;: 10&#125;&gt;&gt;&gt; Foo._Foo__N0&gt;&gt;&gt; obj._Foo__x10&gt;&gt;&gt; obj._Foo__N0 2、在类内部是可以直接访问双下滑线开头的属性的，比如self.__f1()，因为在类定义阶段类内部双下滑线开头的属性统一发生了变形。 12&gt;&gt;&gt; obj.f2()__f1 run 3、变形操作只在类定义阶段发生一次,在类定义之后的赋值操作，不会变形。 1234567891011&gt;&gt;&gt; Foo.__M=100&gt;&gt;&gt; Foo.__dict__mappingproxy(&#123;..., &#x27;__M&#x27;: 100,...&#125;)&gt;&gt;&gt; Foo.__M100&gt;&gt;&gt; obj.__y=20&gt;&gt;&gt; obj.__dict__&#123;&#x27;__y&#x27;: 20, &#x27;_Foo__x&#x27;: 10&#125;&gt;&gt;&gt; obj.__y20 三 开放接口定义属性就是为了使用，所以隐藏并不是目的 1、隐藏数据属性将数据隐藏起来就限制了类外部对数据的直接操作，然后类内应该提供相应的接口来允许类外部间接地操作数据，接口之上可以附加额外的逻辑来对数据的操作进行严格地控制 123456789101112131415161718192021222324&gt;&gt;&gt; class Teacher:... def __init__(self,name,age): #将名字和年纪都隐藏起来... self.__name=name... self.__age=age... def tell_info(self): #对外提供访问老师信息的接口... print(&#x27;姓名:%s,年龄:%s&#x27; %(self.__name,self.__age))... def set_info(self,name,age): #对外提供设置老师信息的接口，并附加类型检查的逻辑... if not isinstance(name,str):... raise TypeError(&#x27;姓名必须是字符串类型&#x27;)... if not isinstance(age,int):... raise TypeError(&#x27;年龄必须是整型&#x27;)... self.__name=name... self.__age=age... &gt;&gt;&gt;&gt;&gt;&gt; t=Teacher(&#x27;lili&#x27;,18)&gt;&gt;&gt; t.set_info(‘LiLi&#x27;,&#x27;19&#x27;) # 年龄不为整型，抛出异常Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 11, in set_infoTypeError: 年龄必须是整型&gt;&gt;&gt; t.set_info(&#x27;LiLi&#x27;,19) # 名字为字符串类型，年龄为整形，可以正常设置&gt;&gt;&gt; t.tell_info() # 查看老师的信息姓名:LiLi,年龄:19 2、隐藏函数属性目的的是为了隔离复杂度，例如ATM程序的取款功能,该功能有很多其他功能组成，比如插卡、身份认证、输入金额、打印小票、取钱等，而对使用者来说,只需要开发取款这个功能接口即可,其余功能我们都可以隐藏起来 1234567891011121314151617181920&gt;&gt;&gt; class ATM:... def __card(self): #插卡... print(&#x27;插卡&#x27;)... def __auth(self): #身份认证... print(&#x27;用户认证&#x27;)... def __input(self): #输入金额... print(&#x27;输入取款金额&#x27;)... def __print_bill(self): #打印小票... print(&#x27;打印账单&#x27;)... def __take_money(self): #取钱... print(&#x27;取款&#x27;)... def withdraw(self): #取款功能... self.__card()... self.__auth()... self.__input()... self.__print_bill()... self.__take_money()...&gt;&gt;&gt; obj=ATM()&gt;&gt;&gt; obj.withdraw() 总结隐藏属性与开放接口，本质就是为了明确地区分内外，类内部可以修改封装内的东西而不影响外部调用者的代码；而类外部只需拿到一个接口，只要接口名、参数不变，则无论设计者如何改变内部实现代码，使用者均无需改变代码。这就提供一个良好的合作基础，只要接口这个基础约定不变，则代码的修改不足为虑。 四 propertyBMI指数是用来衡量一个人的体重与身高对健康影响的一个指标，计算公式为 12体质指数（BMI）=体重（kg）÷身高^2（m）EX：70kg÷（1.75×1.75）=22.86 身高或体重是不断变化的，因而每次想查看BMI值都需要通过计算才能得到，但很明显BMI听起来更像是一个特征而非功能，为此Python专门提供了一个装饰器property，可以将类中的函数“伪装成”对象的数据属性，对象在访问该特殊属性时会触发功能的执行，然后将返回值作为本次访问的结果，例如 123456789101112&gt;&gt;&gt; class People:... def __init__(self,name,weight,height):... self.name=name... self.weight=weight... self.height=height... @property... def bmi(self):... return self.weight / (self.height**2)...&gt;&gt;&gt; obj=People(&#x27;lili&#x27;,75,1.85)&gt;&gt;&gt; obj.bmi #触发方法bmi的执行，将obj自动传给self，执行后返回值作为本次引用的结果21.913805697589478 使用property有效地保证了属性访问的一致性。另外property还提供设置和删除属性的功能，如下 123456789101112131415161718192021&gt;&gt;&gt; class Foo:... def __init__(self,val):... self.__NAME=val #将属性隐藏起来... @property... def name(self):... return self.__NAME... @name.setter... def name(self,value):... if not isinstance(value,str): #在设定值之前进行类型检查... raise TypeError(&#x27;%s must be str&#x27; %value)... self.__NAME=value #通过类型检查后,将值value存放到真实的位置self.__NAME... @name.deleter... def name(self):... raise PermissionError(&#x27;Can not delete&#x27;)...&gt;&gt;&gt; f=Foo(&#x27;lili&#x27;)&gt;&gt;&gt; f.namelili&gt;&gt;&gt; f.name=&#x27;LiLi&#x27; #触发name.setter装饰器对应的函数name(f,’Egon&#x27;)&gt;&gt;&gt; f.name=123 #触发name.setter对应的的函数name(f,123),抛出异常TypeError&gt;&gt;&gt; del f.name #触发name.deleter对应的函数name(f),抛出异常PermissionError","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"23、面向对象编程","slug":"23、面向对象编程","date":"2018-05-13T06:04:23.000Z","updated":"2022-05-13T12:28:37.172Z","comments":true,"path":"2018/05/13/23、面向对象编程/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/23%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"对象的概念 类与对象 面对对象编程 类的定义与实例化 属性访问 类属性与对象属性 属性查找顺序与绑方法 小结 一、对象的概念”面向对象“的核心是“对象”二字，而对象的精髓在于“整合“，什么意思？ 所有的程序都是由”数据”与“功能“组成，因而编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。在学习”对象“之前，程序中的数据与功能是分离开的，如下 1234567891011# 数据：name、age、sexname = &#x27;lili&#x27;age = &#x27;18&#x27;sex = &#x27;female&#x27;# 功能：tell_infodef tell_info(name,age,sex): print(&#x27;&lt;%s:%s:%s&gt;&#x27; %(name,age,sex))# 此时若想执行查看个人信息的功能，需要同时拿来两样东西，一类是功能tell_info，另外一类则是多个数据name、age、sex，然后才能执行，非常麻烦tell_info(name,age,sex) 在学习了“对象”之后，我们就有了一个容器，该容器可以盛放数据与功能，所以我们可以说：对象是把数据与功能整合到一起的产物，或者说”对象“就是一个盛放数据与功能的容器&#x2F;箱子&#x2F;盒子。 如果把”数据“比喻为”睫毛膏“、”眼影“、”唇彩“等化妆所需要的原材料；把”功能“比喻为眼线笔、眉笔等化妆所需要的工具，那么”对象“就是一个彩妆盒，彩妆盒可以把”原材料“与”工具“都装到一起 如果我们把”化妆“比喻为要执行的业务逻辑，此时只需要拿来一样东西即可，那就是彩妆盒，因为彩妆盒里整合了化妆所需的所有原材料与功能，这比起你分别拿来原材料与功能才能执行，要方便的多。 在了解了对象的基本概念之后，理解面向对象的编程方式就相对简单很多了，面向对象编程就是要造出一个个的对象，把原本分散开的相关数据与功能整合到一个个的对象里，这么做既方便使用，也可以提高程序的解耦合程度，进而提升了程序的可扩展性（需要强调的是，软件质量属性包含很多方面，面向对象解决的仅仅只是扩展性问题） 二、类与对象类即类别&#x2F;种类，是面向对象分析和设计的基石，如果多个对象有相似的数据与功能，那么该多个对象就属于同一种类。有了类的好处是：我们可以把同一类对象相同的数据与功能存放到类里，而无需每个对象都重复存一份，这样每个对象里只需存自己独有的数据即可，极大地节省了空间。所以，如果说对象是用来存放数据与功能的容器，那么类则是用来存放多个对象相同的数据与功能的容器 综上所述，虽然我们是先介绍对象后介绍类，但是需要强调的是：在程序中，必须要事先定义类，然后再调用类产生对象（调用类拿到的返回值就是对象）。产生对象的类与对象之间存在关联，这种关联指的是：对象可以访问到类中共有的数据与功能，所以类中的内容仍然是属于对象的，类只不过是一种节省空间、减少代码冗余的机制，面向对象编程最终的核心仍然是去使用对象 在了解了类与对象这两大核心概念之后，我们就可以来介绍一下面向对象编程啦 三、面向对象编程1、类的定义与实例化我们以开发一个清华大学的选课系统为例，来简单介绍基于面向对象的思想如何编写程序 面向对象的基本思路就是把程序中要用到的、相关联的数据与功能整合到对象里，然后再去使用，但程序中要用到的数据以及功能那么多，如何找到相关连的呢？我需要先提取选课系统里的角色：学生、老师、课程等，然后显而易见的是：学生有学生相关的数据于功能，老师有老师相关的数据与功能，我们单以学生为例： 1234567891011121314151617181920212223242526272829303132333435363738# 学校的数据有学校名字年龄性别# 学生的功能有选课详细的：# 学生1： 数据: 学校=清华大学 姓名=李建刚 性别=男 年龄=28 功能： 选课# 学生2： 数据: 学校=清华大学 姓名=王大力 性别=女 年龄=18 功能： 选课# 学生3： 数据: 学校=清华大学 姓名=牛嗷嗷 性别=男 年龄=38 功能： 选课 我们可以总结出一个学生类，用来存放学生们相同的数据与功能 12345# 学生类 相同的特征： 学校 = 清华大学 相同发的功能： 选课 基于上述分析的结果，我们接下来需要做的就是在程序中定义出类，然后调用类产生对象 12345class Student: school = &#x27;清华大学&#x27; def choose(self): print(&#x27;%s is choosing a course&#x27; % self.name) 类体最常见的是变量的定义和函数的定义，但其实类体可以包含任意的Python代码，类体的代码在类定义阶段就会执行，因而会产生新的名称空间用来存放类中定义的名字，可以大一Student.__dict__来查看类这个容器内盛放的东西 12&gt;&gt;&gt; print(Student.__dict__)&#123;..., &#x27;school&#x27;: &#x27;清华大学&#x27;, &#x27;choose&#x27;: &lt;function Student.choose at 0x1018a2950&gt;, ...&#125; 调用类的过程称为将类实例化，拿到的返回值就是程序中的对象，或称为一个实例 123&gt;&gt;&gt; stu1=Student() # 每实例化一次Student类就得到一个学生对象&gt;&gt;&gt; stu2=Student()&gt;&gt;&gt; stu3=Student() 如此stu1、stu2、stu3全都一样了（只有类中共有的内容，而没有各自独有的数据），想在实例化的过程中就为三位学生定制各自独有的数据：姓名，性别，年龄，需要我们在类内部新增一个__init__方法,如下 1234567891011class Student: school = &#x27;清华大学&#x27; # 该方法会在对象产生之后自动执行，专门为对象进行初始化操作，可以有任意代码，但一定不能返回非None的值 def __init__(self, name, sex, age): self.name = name self.sex = sex self.age = age def choose(self): print(&#x27;%s is choosing a course&#x27; % self.name) 然后我们重新实例化三位学生 123&gt;&gt;&gt; stu1 = Student(&#x27;李建刚&#x27;, &#x27;男&#x27; , 28)&gt;&gt;&gt; stu2 = Student(&#x27;王大力&#x27;, &#x27;女&#x27;, 38)&gt;&gt;&gt; stu3 = Student(&#x27;牛姐&#x27;, &#x27;女&#x27;, 18) 单拿stu1的产生过程来分析，调用类会先产生一个空对象stu1，然后将stu1连同调用类时括号内参数一起传给Student.init(stu1,’李建刚’,28) 1234def __init__(self, name, sex, age): self.name = name # stu1.name = &#x27;李建刚&#x27; self.sex = sex # stu1.sex = &#x27;男&#x27; self.age = age # stu1.age = 28 会产生对象名称空间，同样可以用__dict__查看 12&gt;&gt;&gt; stu1.__dict__&#123;&#x27;name&#x27;: &#x27;李建刚&#x27;, &#x27;sex&#x27;: &#x27;男&#x27;, &#x27;age&#x27;: 28&#125; 至此，我们造出了三个对象与一个类，对象存放各自独有的数据，类中存放对象们共有的内容 存的目的是为了用，那么如何访问对象或者类中存放的内容呢？ 2、属性访问类属性与对象属性在类中定义的名字，都是类的属性，细说的话，类有两种属性：数据属性和函数属性，可以通过__dict__访问属性的值，比如Student.dict[‘school’]，但Python提供了专门的属性访问语法 123456&gt;&gt;&gt; Student.school&#x27;清华大学&#x27;&gt;&gt;&gt; Student.choose&lt;function Student.choose at 0x1018a2950&gt;# 除了查看属性外，我们还可以使用Student.attrib = value(修改或新增属性)，用del Student.attrib删除属性 操作对象的属性也是一样 12345&gt;&gt;&gt; stu1.name # 查看，等同于obj1.__dict__[&#x27;name&#x27;]&#x27;李建刚&#x27;&gt;&gt;&gt; stu1.course = &#x27;python&#x27; # 新增，等同于obj1.__dict__[‘course&#x27;]=&#x27;python&#x27;&gt;&gt;&gt; stu1.age=38 # 修改，等同于obj1.__dict__[‘age&#x27;]=38&gt;&gt;&gt; del obj1.course 属性查找顺序与绑定方法对象的名称空间里只存放着对象独有的属性，而对象们相似的属性是存放于类中的。对象在访问属性时，会优先从对象本身的__dict__中查找，未找到，则去类的__dict__中查找 类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址 123456# id都一样print(id(Student.school)) # 4301108704print(id(stu1.school)) # 4301108704print(id(stu2.school)) # 4301108704print(id(stu3.school)) # 4301108704 类中定义的函数是类的函数属性，类可以使用，但必须遵循函数的参数规则，有几个参数需要传几个参数 1234Student.choose(stu1) # 李建刚 is choosing a courseStudent.choose(stu2) # 王大力 is choosing a courseStudent.choose(stu3) # 牛嗷嗷 is choosing a course 但其实类中定义的函数主要是给对象使用的，而且是绑定给对象的，虽然所有对象指向的都是相同的功能，但是绑定到不同的对象就是不同的绑定方法，内存地址各不相同 12345print(id(Student.choose)) # 4335426280print(id(stu1.choose)) # 4300433608print(id(stu2.choose)) # 4300433608print(id(stu3.choose)) # 4300433608 绑定到对象的方法特殊之处在于，绑定给谁就应该由谁来调用，谁来调用，就会将’谁’本身当做第一个参数自动传入（方法__init__也是一样的道理） 123stu1.choose() # 等同于Student.choose(stu1)stu2.choose() # 等同于Student.choose(stu2)stu3.choose() # 等同于Student.choose(stu3) 绑定到不同对象的choose技能，虽然都是选课，但李建刚选的课，不会选给王大力，这正是”绑定“二字的精髓所在 1#注意：绑定到对象方法的这种自动传值的特征，决定了在类中定义的函数都要默认写一个参数self，self可以是任意名字，但命名为self是约定俗成的。 Python中一切皆为对象，且Python3中类与类型是一个概念，因而绑定方法我们早就接触过 12345678910111213141516171819202122232425#类型list就是类&gt;&gt;&gt; list&lt;class &#x27;list&#x27;&gt;#实例化的到3个对象l1,l2,l3&gt;&gt;&gt; l1=list([1,2,3])&gt;&gt;&gt; l2=list([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;])&gt;&gt;&gt; l3=list([&#x27;x&#x27;,&#x27;y&#x27;])#三个对象都有绑定方法append,是相同的功能,但内存地址不同&gt;&gt;&gt; l1.append&lt;built-in method append of list object at 0x10b482b48&gt;&gt;&gt;&gt; l2.append&lt;built-in method append of list object at 0x10b482b88&gt;&gt;&gt;&gt; l3.append&lt;built-in method append of list object at 0x10b482bc8&gt;#操作绑定方法l1.append(4),就是在往l1添加4,绝对不会将4添加到l2或l3&gt;&gt;&gt; l1.append(4) #等同于list.append(l1,4)&gt;&gt;&gt; l1[1,2,3,4]&gt;&gt;&gt; l2[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; l3[&#x27;x&#x27;,&#x27;y&#x27;] 小结在上述介绍类与对象的使用过程中，我们更多的是站在底层原理的角度去介绍类与对象之间的关联关系，如果只是站在使用的角度，我们无需考虑语法“对象.属性”中”属性“到底源自于哪里，只需要知道是通过对象获取到的就可以了，所以说，对象是一个高度整合的产物，有了对象，我们只需要使用”对象.xxx“的语法就可以得到跟这个对象相关的所有数据与功能，十分方便且解耦合程度极高","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"22、软件开发的目录规范","slug":"22、软件开发的目录规范","date":"2018-05-13T06:04:22.000Z","updated":"2022-05-13T12:28:34.774Z","comments":true,"path":"2018/05/13/22、软件开发的目录规范/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/22%E3%80%81%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/","excerpt":"","text":"软件开发的目录规范为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。软件的目录规范并无硬性标准，只要清晰可读即可，假设你的软件名为foo，笔者推荐目录结构如下 1234567891011121314151617181920Foo/|-- core/| |--core.py||-- api/| |-- api.py||-- db/| |-- db_handle.py||--lib/| |-- common.py||--conf/| |-- settings.py||-- run.py|-- setup.py|-- requirements.txt|--READEME 简要解释一下： core&#x2F; 存放业务逻辑相关代码 api&#x2F; 存放接口文件，接口主要用于为业务逻辑提供数据操作 db&#x2F; 存放操作数据库相关文件，主要用于与数据库交互 lib&#x2F; 存放程序中常用的自定义模块 conf 存放配置文件 run.py 程序的启动文件，一般放在项目的根目录下，因为在运行时会默认将运行文件所在的文件夹作为sys.path的第一个路径，这样就省去了处理环境变量的步骤 setup.py 安装、部署、打包的脚本 requirements.txt 存放软件依赖的外部Python包列表 README 项目说明文件 除此之外，有一些方案给出了更加多的内容，比如LICENSE.txt,ChangeLog.txt文件等，主要是在项目需要开源时才会用得到，请读者自行查阅 关于README的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目，它需要说明以下几个事项： 1234567891、软件定位，软件的基本功能2、运行代码的方法：安装环境、启动命令等3、简要的使用说明4、代码目录结构说明，更详细地可以说明软件的基本原理5、常见问题说明 关于setup.py和requirements.txt: 一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。 requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在setup.py安装依赖库时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。 这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;&#x3D;0.10这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python依赖库都装好了","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"21、包","slug":"21、包","date":"2018-05-13T06:04:21.000Z","updated":"2022-05-13T12:28:32.693Z","comments":true,"path":"2018/05/13/21、包/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/21%E3%80%81%E5%8C%85/","excerpt":"","text":"包的介绍 包的使用 导入包与__init__.py 绝对导入与相对导入 from包import* 一、包的介绍随着模块数目的增多，把所有模块不加区分地放到一起也是极不合理的，于是python为我们提供了一种把模块组织到一起的方法，即创建一个包。包就是一个含有__init__.py文件的文件夹，文件夹内可以组织子模块或子包，例如 12345678pool/|——__init__.py|——futures| |——__init__.py| |——process.py| |——thread.py└── versions.py 需要强调的是 123# 1. 在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错# 2. 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包的本质就是一种模块 接下来我们就以包pool为例来介绍包的使用，包内各文件内容如下 123456789101112131415161718192021# process.pyclass ProcessPoolExecutor: def __init__(self, max_workers): self.max_workers = max_workers def submt(self): print(&#x27;ProcessPool submit&#x27;) # thread.pyclass ThreadPoolExcutor: def __init__(self, max_workers): self.max_workers = max_workers # versions.pydef check(): print(&#x27;check versions&#x27;) # __init__.py文件内容均为空 二、包的使用1.导入包与__init__.py包属于模块的一种，因而包以及包内的模块均是用来被导入使用的，而绝非被直接执行，首次导入包（如import pool）同样会做三件事： 1.执行包下的__init__.py文件 2.产生一个新的名称空间用于存放__init__.py执行过程中产生的名字 3.在当前执行文件所在的名称空间中得到一个名字pool，该名子指向__init__.py的名称空间，例如pool.xxx和poo.yyy中的xxx和yyy都是来自于pool下的__init__.py，也就是说导入包时并不会导入包下所有的子模块与子包 1234import poolpool.versions.check() # 抛出异常AttributeErrorpool.futures.process.ProcessExecutor(3) # 抛出异常AttributeError pool.versions.check()要求pool下有名字versions，进而pool.versions下有名字check。pool.versions下已经有名字check了，所以问题出现在pool下没有名字versions，这就需要在pool下的__init__.py中导入模块versions 强调 11.关于包相关的导入语句也分为import和from...import...两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如import 顶级包.子包.子模块，但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包，模块，函数，类 2.绝对导入与相对导入针对包内的模块之间互相导入，导入的方式有两种 1.绝对导入：以顶级包为起始 12# pool下的__init__.pyfrom pool import versions 2.相对导入：代表当前文件所在的目录，..代表当前目录的上一级目录，依次类推 12# pool 下的__init__.pyfrom . import versions 同理，针对pool.futures.process.ProcessPoolExecutor(3)，则需要 12345#操作pool下的__init__.py，保证pool.futuresfrom . import futures #或from pool import futures#操作futrues下的__init__.py，保证pool.futures.processfrom . import process #或from pool.futures import process 相对导入只能用from module import symbol的形式,import ..versions语法是不对的，且symbol只能是一个明确的名字 12from pool import futures.process # 语法错误from pool.futures import process # 语法正确 针对包内部模块之间的相互导入推荐使用相对导入，需要特别强调： 1、相对导入只能在包内部使用，用相对导入不同目录下的模块是非法的 2、无论是import还是from-import，但凡是在导入时带点的，点的左边必须是包,否则语法错误 3.总结包的使用总结包的使用需要牢记三点1、导包就是在导包下__init__.py文件2、包内部的导入应该使用相对导入，相对导入也只能在包内部使用，而且…取上一级不能出包3、 使用语句中的点代表的是访问属性 m.n.x —-&gt; 向m要n，向n要x 而导入语句中的点代表的是路径分隔符 import a.b.c –&gt; a&#x2F;b&#x2F;c，文件夹下a下有子文件夹b，文件夹b下有子文件或文件夹c 所以导入语句中点的左边必须是一个包 4.from包和import *在使用包时同样支持from pool.futures import * ，毫无疑问代表的是futures下__init__.py中所有的名字，通用是用变量__all__来控制代表的意思 12#futures下的__init__.py__all__ = [&#x27;process&#x27;, &#x27;thread&#x27;] 最后说明一点，包内部的目录结构通常是包的开发者为了方便自己管理和维护代码而创建的，这种目录结构对包的使用者往往是无用的，此时通过操作__init__.py可以“隐藏”包内部的目录结构，降低使用难度，比如想要让使用者直接使用 pool下的__init__.py中导入子模块或子包 123from .versions import checkfrom .futures.process import ProcessPoolExecutorfrom .futures.thread import ThreadPoolExecutor 程序运行 12345import poolpool.check()pool.ProcessPoolExecutor(3)pool.ThreadPoolExecutor(3)","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"20、模块","slug":"20、模块","date":"2018-05-13T06:04:20.000Z","updated":"2022-05-13T12:28:29.716Z","comments":true,"path":"2018/05/13/20、模块/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/20%E3%80%81%E6%A8%A1%E5%9D%97/","excerpt":"","text":"http://pypi.douban.com/simple/ 模块介绍 模块的使用 import语句 from-import语句 其他导入语法（as） 循环导入问题 搜索模块的路径与优先级 区分py文件的两种用途 编写一个规范的模块 一、模块介绍在Python中，一个py文件就是一个模块，文件名为xxx.py模块名则是xxx，导入模块可以引用模块中已经写好的功能，如果把开发程序比喻成制造一台电脑，编写模块就像是在制造电脑的零部件，准备好零部件后，剩下的工作就是按照逻辑把它们组装到一起 将程序模块化会使得程序的组织结构清晰，维护起来更加方便，比起直接开发一个完整的程序，单独开发一个小的模块也会更加简单，并且程序中的模块与电脑中的零部件稍微不同的是：程序中的模块可以被重复利用。所以总结下来，使用模块既保证了代码的重要性，又增加了程序的结构性和可维护性。另外除了自定义模块外，我们还可以导入使用内置或第三方模块提供的现成功能，这种”拿来主义“极大地提高了程序员的开发效率 二、模块的使用1.import语句12345678910111213141516# 文件名：foo.pyx = 1def get(): print(x) def change(): global x x = 0 class Foo: def func(self): print(&#x27;from the func&#x27;) 想要在另外一个py文件中引用foo.py中的功能，需要使用import foo，首次导入模块会做三件事： 1.执行源文件代码 2.产生一个新的名称空间用于存放源文件执行过程中产生的名字 3.在当前执行文件所在的名称空间中得到一个名字foo，该名子指向新创建的模块名称空间，若要引用模块名称空间中的名字，需要加上该前缀，如下 12345imprt foo # 导入模块fooa = foo.x # 引用模块foo中变量x的值赋值给当前名称空间中的名字afoo.get() # 调用模块foo的get函数foo.change() # 调用foo中的change函数obj = foo.Foo() # 使用模块foo的类Foo来实例化，进一步可以执行obj.func() 加上foo.作为前缀就相当于指名道姓地说明要引用foo名称空间中的名字，所以肯定不会与当前执行文件所在名称空间中的名字相冲突，并且若当前执行文件的名称空间中存在x，执行foo.get()或foo.change()操作的都是源文件中的全局变量x 需要强调一点是，第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名。 提示： 12# 1.在python中模块也属于第一类对象，可以进行赋值、以数据形式传递以及作为容器类型的元素等操作# 2.模块名应该遵循小写形式，标准库从python2过度到python3做出了很多这类调整，比如ConfigParser、Queue、SocketServer全更新为纯小写形式 用import语句导入多个模块，可以写多行import语句 1234import module1import module2import module3... 还可以在一行导入，用逗号分开不同的模块 1import module1, module2 但其实第一种形式更为规范，可读性更强，推荐使用，而且我们导入的模块中可能包含有python内置的模块、第三方模块、自定义的模块，为了便于明显的区分它们，我们通常子啊文件的开头导入模块，并且分类导入，一类模块与另外一类模块的导入用空行隔开，不同类别的导入顺序如下： 123import python内置模块import 第三方模块import 程序员自定义模块 当然，我们也可以在函数内导入模块，对比在文件开头导入模块属于全局作用域，在函数内导入的模块则属于局部的作用域。 2.from-import 语句rom…import…与import语句基本一致，唯一不同的是：使用import foo导入模块后，引用模块中的名字都需要加上foo.作为前缀，而使用from foo omport x, get ,change, Foo则可以在当前执行文件中直接引用模块foo的名字，如下 1234from foo import x, get, change # 将模块foo中的x，get，change导入当前名称空间a = x # 直接使用模块foo中的x赋值给aget() # 直接执行foo中的get函数change() # 即便是当前又重名的x，修改的仍然是源文件中的x 无需加前缀的好处是使得我们的代码更加简洁，坏处则是容易与当前名称空间中的名字冲突，如果当前名称空间存在相同的名字，则后定义的名字会覆盖之前定义的名字 另外from语句支持from foo import * 语法，*代表将foo中所有的名字都导入到当前位置 123456from foo import * # 把foo中所有的名字都导入到当前执行文件的名称空间中，在当前位置直接可以使用这些名字a = xget()change()obj = Foo() 如果我们需要引用模块中的名字过多的话，可以采用上述的导入形式来达到节省代码量的效果，但是需要强调的一点是：只能在模块最顶层使用的方式导入，在函数内则非法，并且这种方式会带来一个副作用，即我们无法搞清楚究竟从源文件中导入了哪些名字到当前位置，这极有可能与当前位置的名字产生冲突，模块的编写者可以在自己的文件中定义__all__变量用来控制*代表的意思 12345678910111213# foo.py__all__ = [&#x27;x&#x27;, &#x27;get&#x27;] # 该列表中所有的元素必须是字符串类型，每个元素对应foo.py中的一个名字x = 1def get(): print(x)def change(): global x x = 0 class Foo: def func(self): print(&#x27;from the func&#x27;) 这样我们在另外一个文件中使用*导入时，就只能导入__all__定义的名字了 1234567from foo import * # 此时的*只代表x和getx # 可用get() # 可用change() # 不可用Foo() # 不可用 3.其他导入语法（as）我们还可以在当前位置为导入的模块起一个别名 123import foo as f # 为导入的模块foo在当前位置起别名f，以后再使用时就用这个别名ff.xf.get() 还可以为导入的一个名字起别名 12from foo import get as get_xget_x() 通常在被导入的名字过长时采用起别名的方式来精简代码，另外为被导入的名字起别名可以很好地避免与当前名字发生冲突，还有很重要的一点就是：可以保持调用方式的一致性，例如我们有两个模块json和pickle同时实现了load方法，作用是从一个打开的文件中解析出结构化的数据，但解析的格式不同，可以用下述代码有选择性地加载不同的模块 123456if data_format == &#x27;json&#x27;: import json as serialize # 如果数据格式是json，那么导入json模块并命名为serializeelif data_format == &#x27;pickle&#x27;: import pikle as serialize # 如果数据格式是&#x27;pickle&#x27;那么导入pickle，模块并命名为serialize data = serialize.load(fn) # 最终的调用方式是一样的 4.循环导入问题循环导入问题指的是在一个模块加载&#x2F;导入的过程中带入另一个模块，而在另一个模块中又返回回来第一个模块的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中马桶一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未加载完毕也不会去重复执行内部代码 我们以下述文件为例，来详细分析循环&#x2F;嵌套导入出现异常的原因以及解决的方案 m1.py 1234print(&#x27;正在导入m1&#x27;)from m2 import yx = &#x27;m1&#x27; m2.py 1234print(&#x27;正在导入m2&#x27;)from m1 import xy = &#x27;m2&#x27; run.py 1import m1 测试一 1234567891011121314# 1、执行run.py会抛出异常正在导入m1正在导入m2Traceback (most recent call last): File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/aa.py&quot;, line 1, in &lt;module&gt; import m1 File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;, line 2, in &lt;module&gt; from m2 import y File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m2.py&quot;, line 2, in &lt;module&gt; from m1 import xImportError: cannot import name &#x27;x&#x27; # 2、分析先执行run.py---&gt;执行import m1，开始导入m1并运行其内部代码---&gt;打印内容“正在导入m1”---&gt;执行from m2 import y 开始导入m2并运行其内部代码---&gt;打印内容“正在导入m2”---&gt;执行 from m1 import x，由于m1已经被导入过了，所以不会重新导入，所以直接去m1中拿x，然而x此时并没有存在于m1中，所以报错 测试二 12345678910111213141516# 1、执行文件不等于导入文件，比如执行m1.py不等于导入了m1直接执行m1.py抛出异常正在导入m1正在导入m2正在导入m1Traceback (most recent call last): File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;, line 2, in &lt;module&gt; from m2 import y File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m2.py&quot;, line 2, in &lt;module&gt; from m1 import x File &quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;, line 2, in &lt;module&gt; from m2 import yImportError: cannot import name &#x27;y&#x27;# 2、分析执行m1.py，打印“正在导入m1”，执行from m2 import y ，导入m2进而执行m2.py内部代码---&gt;打印&quot;正在导入m2&quot;，执行from m1 import x，此时m1是第一次被导入，执行m1.py并不等于导入了m1，于是开始导入m1并执行其内部代码---&gt;打印&quot;正在导入m1&quot;，执行from m1 import y，由于m1已经被导入过了，所以无需继续导入而直接问m2要y，然而y此时并没有存在于m2中所以报错 解决方案 12345678910111213141516171819202122232425262728293031323334353637383940414243# 方案一：导入语句放到最后，保证在导入时，所有名字都已经加载过# 文件：m1.pyprint(&#x27;正在导入m1&#x27;)x=&#x27;m1&#x27;from m2 import y# 文件：m2.pyprint(&#x27;正在导入m2&#x27;)y=&#x27;m2&#x27;from m1 import x# 文件：run.py内容如下，执行该文件，可以正常使用import m1print(m1.x)print(m1.y)# 方案二：导入语句放到函数中，只有在调用函数时才会执行其内部代码# 文件：m1.pyprint(&#x27;正在导入m1&#x27;)def f1(): from m2 import y print(x,y)x = &#x27;m1&#x27;# 文件：m2.pyprint(&#x27;正在导入m2&#x27;)def f2(): from m1 import x print(x,y)y = &#x27;m2&#x27;# 文件：run.py内容如下，执行该文件，可以正常使用import m1m1.f1() 注意：循环导入问题大多数情况是因为程序设计失误导致，上述解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环&#x2F;嵌套导入，如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入 5.搜索模块的路径与优先级模块其实分为四个通用类别，分别是 1.使用纯python代码编写的py文件 2.包含一系列模块的包 3.使用C编写并链接到python解释器中的内置模块 4.使用C或C++编译的扩展模块 在导入模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找到模块对应的文件为主，否则抛出异常。sys.path也被称为模块的搜索路径，它是一个列表类型 123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&#x27;&#x27;, &#x27;D:\\\\python38\\\\python38.zip&#x27;, &#x27;D:\\\\python38\\\\DLLs&#x27;, &#x27;D:\\\\python38\\\\lib&#x27;, &#x27;D:\\\\python38&#x27;, &#x27;D:\\\\python38\\\\lib\\\\site-packages&#x27;] 列表中的每个元素其实都可以当作一个目录来看：在列表中会发现有.zip或.egg结尾的文件，二者是不同形式的压缩文件，事实上Python确实支持从一个压缩文件中导入模块，我们也只需要把它们都当成目录去看即可 sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为&#x2F;pythoner&#x2F;projects&#x2F; 1234import syssys.append(r&#x27;/pythoner/projects/&#x27;) # 也可以使用sys.insert(...)import foo # 无论foo.py在何处,我们都可以导入它了 6.区分py文件的两种用贴图一个python文件有两种用途，一种被当主程序&#x2F;脚本执行，另一种被当作模块导入，为了区别同一个文件的不同用途，每个py文件都内置了__name__变量，该变量在py文件被当作脚本执行时赋值为“__main__”,在py文件被当作模块导入时赋值为模块名 作为模块foo.py的开发者，可以在文件末尾基于__name__在不同应用场景下值的不同来控制文件执行不同的逻辑 123456# foo.py...if name == &#x27;__name__&#x27;: foo.py被当作脚本执行时运行的代码else: foo.py被当作模块导入时运行的代码 通常我们会在if的子代码中编写针对模块功能的测试代码，这样foo.py在被当作脚本运行时，就会执行测试代码，而被当作模块导入时则不用执行测试代码 编写一个规范的模块我们子啊编写py文件时，需要时刻提醒自己，该文件是给自己用的，也有可能会被其他人使用，因而代码的可读性与易维护性显得十分重要，为此我们在编写一个模块时最好按照统一的规范去编写，如下 123456789101112131415161718# !/usr/bin/env python # 通常只在unix环境有效，作用是可以使用脚本名来执行，而无需直接调用解释器&quot;The module is usde to ...&quot; # 模块的文档描述import sysx = 1class Foo: &#x27;Class Foo is used to ...&#x27; # 定义类，并写好类的注释 passdef test(): # 定义函数，并写好函数的注释 &#x27;Function test is used to ...&#x27; passif name == &#x27;__main__&#x27;: # 主程序 test() # 在被当作脚本执行时，执行此处的代码","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"19、面向过程编程与函数式","slug":"19、面向过程编程与函数式","date":"2018-05-13T06:04:19.000Z","updated":"2022-05-13T12:28:27.052Z","comments":true,"path":"2018/05/13/19、面向过程编程与函数式/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/19%E3%80%81%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/","excerpt":"","text":"编程范式 面向过程 函数式 匿名函数与lambda map、reduce、filter 一、编程范式很多初学者在了解了一门编程语言的基本语法和使用之后，面对一个’开发需求‘时仍然会觉得无从下手、没有思路&#x2F;套路，本节主题“编程范式”正是为了解决该问题，那到底什么是编程范式呢？ 编程范式指的就是编程的套路，打个比方，如果把编程的过程比喻为练习武功，那编程范式指的就是武林中的各种流派，而在编程的世界里常见的流派有：面向过程、函数式、面向对象等，本节我们主要介绍面向过程与函数式。 在正式介绍前，我们需要强调：“功夫的流派没有高低之分，只有习武的人才有高低之分“，在编程世界里更是这样，各种编程范式在不同的场景下都各有优劣，谁好谁坏不能一概而论，下面就让我们来一一解读它们。 二、面向过程 ”面向过程“核心是“过程”二字，“过程”指的是解决问题的步骤，即先干什么再干什么……，基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行，即无论采用什么语言、无论依据何种编程范式设计出的程序，最终的执行都是过程式的。 详细的，若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。举例如下： 写一个数据远程备份程序，分三步：本地数据打包，上传至云服务器，检测备份文件可用性 12345678910111213141516171819202122232425262728293031323334import os,time# 一：基于本章所学，我们可以用函数去实现这一个个的步骤# 1、本地数据打包def data_backup(folder): print(&quot;找到备份目录: %s&quot; %folder) print(&#x27;正在备份...&#x27;) zip_file=&#x27;/tmp/backup_%s.zip&#x27; %time.strftime(&#x27;%Y%m%d&#x27;) print(&#x27;备份成功，备份文件为: %s&#x27; %zip_file) return zip_file#2、上传至云服务器def cloud_upload(file): print(&quot;\\nconnecting cloud storage center...&quot;) print(&quot;cloud storage connected&quot;) print(&quot;upload [%s] to cloud...&quot; %file) link=&#x27;https://www.xxx.com/bak/%s&#x27; %os.path.basename(file) print(&#x27;close connection&#x27;) return link#3、检测备份文件可用性def data_backup_check(link): print(&quot;\\n下载文件: %s , 验证文件是否无损...&quot; %link)#二：依次调用# 步骤一：本地数据打包zip_file = data_backup(r&quot;/Users/cx/欧美100G高清无码&quot;)# 步骤二：上传至云服务器link=cloud_upload(zip_file)# 步骤三：检测备份文件的可用性data_backup_check(link) 面向过程总结：优点 1将复杂的问题流程化，进而简单化 缺点 1234567891011121314151617181920212223&#x27;&#x27;&#x27;程序的可扩展性极差，因为一套流水线或者流程就是用来解决一个问题，就好比生产汽水的流水线无法生产汽车一样，即便是能，也得是大改，而且改一个组件，与其相关的组件可能都需要修改，比如我们修改了cloud_upload的逻辑，那么依赖其结果才能正常执行的data_backup_check也需要修改，这就造成了连锁反应，而且这一问题会随着程序规模的增大而变得越发的糟糕。&#x27;&#x27;&#x27;def cloud_upload(file): # 加上异常处理，在出现异常的情况下，没有link返回 try: print(&quot;\\nconnecting cloud storage center...&quot;) print(&quot;cloud storage connected&quot;) print(&quot;upload [%s] to cloud...&quot; %file) link=&#x27;https://www.xxx.com/bak/%s&#x27; %os.path.basename(file) print(&#x27;close connection&#x27;) return link except Exception: print(&#x27;upload error&#x27;) finally: print(&#x27;close connection.....&#x27;)def data_backup_check(link): # 加上对参数link的判断 if link: print(&quot;\\n下载文件: %s , 验证文件是否无损...&quot; %link) else: print(&#x27;\\n链接不存在&#x27;) 应用场景 1面向过程的程序设计一般用于那些功能一旦实现之后就很少需要改变的场景， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。 三、函数式函数式编程并非用函数编程那么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有：Haskell、Erlang。而python并不是一门函数式编程语言，但是仍为我们提供了很多函数式编程好的特性，如lambda，map，reduce，filter 匿名函数与lambda对比使用def关键字创建的是由名字的函数，使用lambda关键字创建则是没有名字的函数，即匿名函数，语法如下 1lambda 参数1，参数2，...:expression 举例 1234567891011# 1.定义lambda x,y,z:x+y+z# 等同于def func(x,y,z): return x+y+z# 2.调用# 方式一res = lambda x,y,z:x+y+z # “匿名”的本质就是要没有名字，所以此处为匿名函数指定名字是没有意义的res = func(1,2,3) 匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为0，使用一次就释放，所以匿名函数用于临时使用一次的场景，匿名函数通常与其他函数配合使用，我们以下述字典为例来介绍它 123456salaries=&#123; &#x27;siry&#x27;:3000, &#x27;tom&#x27;:7000, &#x27;lili&#x27;:10000, &#x27;jack&#x27;:2000&#125; 要想取得薪水最大值和最小值，我们可以使用内置函数max和min（为了方便开发，python解释器已经为我们定义好了一系列常用的功能，称之为内置的函数，我们只需要拿来使用即可） 1234&gt;&gt;&gt; max(salaries)&#x27;tom&#x27;&gt;&gt;&gt; min(salaries)&#x27;jack&#x27; 内置max和min都支持迭代器协议，工作原理都是迭代字典，取得是字典的键，因而比较的是键的最大和最小值，而我们想要的是比较值的最大值与最小值，于是做出如下改动 12345# 函数max会迭代字典salaries，每取出一个“人名“就会当作参数传给指定的匿名函数，然后将匿名函数的返回值当作比较依据，最终返回薪资最高的那个人的名字&gt;&gt;&gt; max(salaries,key = lambda k:salaries[k])&#x27;lili&#x27;&gt;&gt;&gt; min(salaries,key = lambda k:salaries[k])&#x27;jack&#x27; 同理，我们直接对字典进行排序，默认也是按照字典的键去排序的 12&gt;&gt;&gt; sorted(salaries)[&#x27;jack&#x27;, &#x27;lili&#x27;, &#x27;siry&#x27;, &#x27;tom&#x27;] map、reduce、filter函数map、reduce、filter都支持迭代器协议，用来处理可迭代对象，我们以一个可迭代对象array为例来介绍它们三个的用法 1array = [1, 2, 3, 4， 5] 要求一：对array的每个元素做平方处理，可以使用map函数map函数可以接收两个参数，一个是函数，另外一个是可迭代对象，具体用法如下 1234&gt;&gt;&gt; res = map(lambda x:x**2,array)&gt;&gt;&gt; res&lt;map object at 0x000001BBFE072790&gt; 解析：map会依次迭代array，得到的值依次传给匿名函数（也可以是有名函数），而map函数得到的结果仍然是迭代器。 12&gt;&gt;&gt; list(res)[1, 4, 9, 16， 25] 要求二：对array进行合并操作，比如求和运算，这就用到了reduce函数reduce函数可以接收三个参数，一个是函数，第二个是可迭代对象，第三个是初始值 12345# reduce在python2中是内置函数，在python3中则被集成到模块functools中，需要导入才能使用&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; res = reduce(lambda x,y:x+y,array)&gt;&gt;&gt; res15 解析： 1.没有初始值，reduce函数会先迭代依次array，得到的值作为初始值，作为第一个值数传给x，然后继续迭代依次array得到的值作为第二个值传给y，运算的结果为3 2.将上一次reduce运算的结果作为第一个值传给x，然后迭代一次array得到的结果作为第二个值传给y，以此类推，直到迭代完array所有元素，得到最终的结果15 也可以为reduce指定初始值 123&gt;&gt;&gt; res = reduce(lambda x,y:x+y,array,100)&gt;&gt;&gt; res 115 要求三：对array进行过滤操作，这就用到了filter函数，比如过滤出大于3的元素1&gt;&gt;&gt; res = filter(lambda x:x&gt;3,array) 解析：filter函数会依次迭代array，得到的值依次传给匿名函数，如果匿名函数的返回值为真，则过滤出该元素，而filter函数得到的结果仍然是迭代器 12&gt;&gt;&gt; list(res)[4, 5] 提示：我们介绍map、filter、reduce只是为了带大家了解函数式编程的大致思想，在实际开发中，我们完全可以用列表生成式或者生成器表达式来实现三者功能","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"18、函数递归","slug":"18、函数递归","date":"2018-05-13T06:04:18.000Z","updated":"2022-05-13T12:28:24.930Z","comments":true,"path":"2018/05/13/18、函数递归/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/18%E3%80%81%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92/","excerpt":"","text":"函数递归调用介绍 回溯与递推 一、函数递归调用介绍函数不仅可以嵌套定义，话可以桥套调用，即在调用一个函数的过程中，函数内部又调用另一个函数，而函数的递归调用指的是在调用一个函数的过程中又直接或间接地调用该函数本身 例如，在调用f1地过程中，又调用f1，这就是直接调用函数f1本身 1234def f1(): peint(&#x27;from f1&#x27;) f1()f1() 在调用f1的过程中，又调用f2，而在调用f2的过程中又调用f1，这就是间接调用f1函数本身 12345678910def f1(): print(&#x27;from f1&#x27;) f2()def f1(): print(&#x27;from f2&#x27;) f1() f1() 可以看出，两种情况下递归调用都是一个无限循环的过程，但在python对函数的递归调用的深度做了限制，因而并不会像大家想的那样进入无线循环，会抛出异常，要避免出现这种情况，就必须让递归调用在某个特定条件下终止 提示： 1234# 1.可以使用sys.getrecursionlimit()去查看递归深度，默认值为1000，虽然可以使用sys.setrecursionlimit() # 去设置该值，但仍受限于主机操作系统栈大小的限制# 2.python不是一门函数式编程语言，无法对递归进行尾递归优化 二、回溯与递推下面我们用一个浅显的例子，为了让读者阐释递归的原理和使用： 某公司四个员工坐在一起，问第四个人薪水，他说比第三个人多1000，问第三个人薪水，第他说比第二个人多1000，问第二个人薪水，他说比第一个人多1000，最后第一人说自己每月5000，请问第四个人的薪水是多少？ 思路解析： 要知道第四个人的月薪，就必须知道第三个人的，第三个人的又取决于第二个人的，第二个人的又取决于第一个人的，而且每一个员工都比前一个多一千，数学表达式即： 12345678salary(4)=salary(3)+1000 salary(3)=salary(2)+1000 salary(2)=salary(1)+1000 salary(1)=5000# 总结为：salary(n) = salary(n-1) + 1000 # n&gt;1salary(1) = 5000 # n = 1 很明显这是一个递归的过程，可以将该过程分为两个阶段：回溯和递推。 在回溯阶段，要求第n个员工的薪水，需要回溯得到(n-1)个员工的薪水，以此类推，直到得到第一个员工的薪水，此时，salary(1)已知，因而不必再向前回溯了。然后进入递推阶段：从第一个员工的薪水可以推算出第二个员工的薪水(6000)，从第二个员工的薪水可以推算出第三个员工的薪水(7000)，以此类推，一直推算出第第四个员工的薪水(8000)为止，递归结束。需要注意的一点是，递归一定要有一个结束条件，这里n&#x3D;1就是结束条件。 代码实现： 123456789def salary(n): if n == 1: return 5000 return salary(n - 1) + 1000s = salary(4)print(s)# 执行结果为 8000 程序分析： 在未满足n==1的条件时，一直进行递归调用，即一直回溯，见图4.3的左半部分。而在满足n==1的条件时，终止递归调用，即结束回溯，从而进入递推阶段，依次推导直到得到最终的结果。 递归本质就是在做重复的事情，所以理论上递归可以解决的问题循环也都可以解决，只不过在某些情况下，使用递归会更容易实现，比如有一个嵌套多层的列表，要求打印出所有的元素，代码实现如下 123456789101112items = [[1,2], 3, [4, [5, [6, 7]]]]def foo(items): for i in items: if isinstance(i, list): foo(i) else: print(i, end=&#x27; &#x27;) foo(items) # 打印结果1 2 3 4 5 6 7 使用递归，我们只需要分析出要重复执行的代码逻辑，然后提取进入下一次递归调用的条件或者说递归结束的条件即可，代码实现起来简洁清晰","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"17、生成器","slug":"17、生成器","date":"2018-05-13T06:04:17.000Z","updated":"2022-05-13T12:28:22.657Z","comments":true,"path":"2018/05/13/17、生成器/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/17%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/","excerpt":"","text":"一、生成器与yield若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象 12345678910&gt;&gt;&gt; def my_range(start,stop,step=1):... print(&#x27;start...&#x27;)... while start &lt; stop:... yield start... start+=step... print(&#x27;end...&#x27;)...&gt;&gt;&gt; g=my_range(0,3)&gt;&gt;&gt; g&lt;generator object my_range at 0x000002283363A970&gt; 生成器内置有__iter__和__next__方法，所以生成器本身就是一个迭代器 1234&gt;&gt;&gt; g.__iter__&lt;method-wrapper &#x27;__iter__&#x27; of generator object at 0x000002283363A970&gt;&gt;&gt;&gt; g.__next__&lt;method-wrapper &#x27;__next__&#x27; of generator object at 0x000002283363A970&gt; 因而我们可以用next（生成器）触发生成器所对应函数的执行 123456789101112&gt;&gt;&gt; next(g) # 触发函数执行直到遇到yield则停止，将yield后的值返回，并在当前位置挂起函数start...0&gt;&gt;&gt; next(g) # 再次调用next(g)，函数从上次暂停的位置继续执行，知道重新遇到yield...1&gt;&gt;&gt; next(g)2&gt;&gt;&gt; next(g)end...Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 既然生成器对象属于迭代器，那么必然可以使用for循环迭代，如下： 12345678&gt;&gt;&gt; for i in countdown(3):... print(i)... countdown start321Done! 有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值 二、yield表达式应用在函数内可以采用表达式形式的yield 12345&gt;&gt;&gt; def eater():... print(&#x27;Ready to eat&#x27;)... while True:... food = yield... print(&#x27;get the food:%s,and start to eat&#x27; % food) 可以拿到函数的生成器对象持续为函数体send值，如下 123456789&gt;&gt;&gt; g = eater()&gt;&gt;&gt; g&lt;generator object eater at 0x00000228335DAB30&gt;&gt;&gt;&gt; next(g)Ready to eat&gt;&gt;&gt; g.send(&#x27;包子&#x27;)get the food:包子,and start to eat&gt;&gt;&gt; g.send(&#x27;馒头&#x27;)get the food:馒头,and start to eat 针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂在food&#x3D;yield的位置，等待调用g.send()为函数体传值，g.send(None)等同于next(g) 我们可以编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作，如下 1234567891011def init(func): def wrapper(*args, **kwargs): g = func(*args, **kwargs) next(g) return wrapper@initdef eater(): print(&#x27;Ready to eat&#x27;) while True: food = yield print(&#x27;get the food:%s,and start to eat&#x27; % food) 表达式形式的yield也可以用于返回多次值，即变量名&#x3D;yield值的形式，如下 1234567891011121314151617181920def init(func): def wrapper(*args, **kwargs): g = func(*args, **kwargs) next(g) return g return wrapper@initdef eater(): print(&#x27;Ready to eat&#x27;) while True: food = yield print(&#x27;get the food:%s,and start to eat&#x27; % food)g = eater()g.send(&#x27;包子&#x27;) 三、三元表达式、列表生成式、生成器表达式三元表达式三元表达式是python为我们提供的一种简化代码的解决方案，语法如下 1res = 条件成立时返回的值 if 条件 else 条件不成立时返回的值 针对下述场景 12345678def max(x, y): if x &gt; y: return x else: return y res = max(1, 2) 用三元表达式可以一行解决 123x = 1y = 2res = x if x &gt; y else y 列表生成器列表生成器是python为我们提供的一种简化代码的解决方案，用来快速生成列表，语法如下 12345678910111213141516[expression for item1 in iterable1 if condition1for item2 in iterable2 if condition2...for itemN in iterableN if conditionN]#类似于res=[]for item1 in iterable1: if condition1: for item2 in iterable2: if condition2 ... for itemN in iterableN: if conditionN: res.append(expression) 针对下述场景 123egg_list=[]for i in range(10): egg_list.append(&#x27;鸡蛋%s&#x27; %i) 用列表生成器可以一行代码解决 12&gt;&gt;&gt; [&#x27;鸡蛋%s&#x27; %i for i in range(10)][&#x27;鸡蛋0&#x27;, &#x27;鸡蛋1&#x27;, &#x27;鸡蛋2&#x27;, &#x27;鸡蛋3&#x27;, &#x27;鸡蛋4&#x27;, &#x27;鸡蛋5&#x27;, &#x27;鸡蛋6&#x27;, &#x27;鸡蛋7&#x27;, &#x27;鸡蛋8&#x27;, &#x27;鸡蛋9&#x27;] 生成器表达式创建一个生成器对象有两种方式，一种是调用带yield关键字的函数，另一种就是生成器表达式，与列表生成器的语法格式相同，只需要将[]切换成(),即： 1(expression for item in iterable if condition) 对比列表生成式返回的是一个列表，生成器表达式返回的是一个生成器对象 12345&gt;&gt;&gt; [x*x for x in range(3)][0, 1, 4]&gt;&gt;&gt; g = (x*x for x in range(3))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x00000206CD15AB30&gt; 对比列表生成式，生成器表达式的优点自然是节省内存(一次只产生一个值在内存中) 12345678910&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g) # 抛出异常StopIterationTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 如果我们要读取一个大文件的字节数，应该基于生成器表达式的方式完成 1234with open(r&#x27;1.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf8&#x27;) as f: num = (len(line) for line in f) # for循环默认每次读取一行 totle = sum(num) # 依次执行next(num)，然后累加到一起得到结果 print(totle)","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"16、迭代器","slug":"16、迭代器","date":"2018-05-13T06:04:16.000Z","updated":"2022-05-13T12:28:20.268Z","comments":true,"path":"2018/05/13/16、迭代器/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/16%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"一、迭代器介绍 可迭代对象 迭代器对象 二、for循环原理 三、迭代器的优缺点 优点 缺点 一 迭代器介绍迭代器即用来迭代取值的工具，而迭代是重复反馈过程的活动，其目的通常是为了逼近所需的目标或结果，每一次对过程的重复称为一次”迭代“，而每一次迭代得到的结果会作为下一次迭代的初始值，单纯的重复并不是迭代 123while Ture: msg = input(&#x27;&gt;&gt;&gt;:&#x27;).strip() print(msg) 下述while循环才是一个迭代过程，不仅满足重复，而且以每次重新赋值后的index值作为下一次循环中的新的索引进行取值，反复迭代，最终可以取尽列表中的值 123456goods = [&#x27;mac&#x27;, &#x27;lenovo&#x27;, &#x27;acer&#x27;, &#x27;dell&#x27;, &#x27;sony&#x27;]index = 0while index &lt; len(goods): print(goods(index)) index += 1 可迭代对象通过索引的方式进行迭代取值，实现简单，但仅使用于序列类型：字符串，列表，元组。对于没有索引的字典、集合等非序列类型，必须找到一种不依赖索引来进行迭代取值的方式，这就用到了迭代器。 要想了解迭代器为何物，必须事先搞清楚一个很重要的概念：可迭代对象（Iterable）。从语法形式上讲，内置有__iter__方法的对象都是可迭代对象，字符串、列表、元组、字典、集合、打开的文件都是可迭代对象： 123&#123;&#x27;name&#x27;:&#x27;egon&#x27;&#125;.__iter__&#123;7, 8, 9&#125;.__iter__...... 迭代器对象调用obj.iter()方法返回的结果就是一个迭代器对象(Iterator)。迭代器对象是内置有iter和next方法的对象，打开的文件本身就是一个迭代器对象，执行迭代器对象.iter()方法得到的仍然是迭代器本身，不依赖于索引的迭代取值方式，只要存在多个”值“，无论序列类型还是非序列类型都可以按照迭代器的方式取值 123456789101112&gt;&gt;&gt; s = &#123;1, 2, 3&#125; # 可迭代对象s&gt;&gt;&gt; i = iter(s) # 本质就是载调用s.__iter__()，返回s的迭代器对象&gt;&gt;&gt; next(i) # 本质就是再调用i.__next__()1&gt;&gt;&gt; next(i)2&gt;&gt;&gt; next(i)3&gt;&gt;&gt; next(i) # 抛出StopIteration的异常，代表无值可取，迭代结束Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration for循环原理有了迭代器后，我们便可以不依赖索引迭代取值了，使用while循环的实现方式如下 1234567goods = [&#x27;mac&#x27;, &#x27;lenovo&#x27;, &#x27;acer&#x27;, &#x27;dell&#x27;, &#x27;sony&#x27;]i = iter(goods) # 每次都需要重新获取一个迭代器对象while Ture: try: print(next(i)) except StopIteration: # 捕捉异常终止循环 break for循环又称为迭代循环，in后可以跟任意可迭代对象，上述while循环可以简写为 123goods = [&#x27;mac&#x27;, &#x27;lenovo&#x27;, &#x27;acer&#x27;, &#x27;dell&#x27;, &#x27;sony&#x27;]for item in goods: print(item) for循环再工作时，首先会调用可迭代对象goods内置的iter方法拿到一个迭代器对象，然后再调用该迭代器对象的next方法将取到的值赋给iten，执行循环体完成一次循环，周而复始，直到捕捉StopIteration异常，结束迭代。 三 迭代器的优缺点基于索引的迭代取值，所有的状态都保存在了索引中，而基于迭代器实现迭代的方式不再需要索引，所有迭代的状态就保存在迭代器中，然而这种处理方式优点于缺点并存： 优点 为序列和非序列类型提供了统一的迭代取值方式。 惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用next来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。 缺点 除非取尽，否则无法获取迭代器的长度 只能取下一个值，不能回到开始，更像是’一次性的‘，迭代器产生后的唯一目标就是重复执行next方法直到值取尽，否则就会停留在某个位置，等待下一次调用next；若是要再次迭代同个对象，你只能重新调用iter方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值。","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"15、装饰器","slug":"15、装饰器","date":"2018-05-13T06:04:15.000Z","updated":"2022-05-13T12:28:17.980Z","comments":true,"path":"2018/05/13/15、装饰器/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/15%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8/","excerpt":"","text":"一、装饰器介绍 1.1 为什么要用装饰器 1.2 什么是装饰器 二、装饰器的实现 2.1 无参装饰器的实现 2.2 有参装饰器的实现 一、装饰器介绍为何要用装饰器软件的设计应该遵循开放封闭原则，即对扩展是开放的，而对修改是封闭的。对扩展开放，意味着有新的需求或变化时，可以对现有的代码进行扩展，以适应新的情况。对修改封闭，意味着对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改。 软件包含的所有功能的源代码以及调用方式，都应该避免修改，否则一旦改错，则极有可能产生连锁反应，最终导致程序崩溃，而对于上线后的软件，新需求或者变化又层出不穷，我们必须为程序提供扩展的可能性，这就用到了装饰器。 什么是装饰器‘装饰’代指为被装饰对象添加新的功能，‘器’代指器具&#x2F;工具，装饰器与被装饰的对象均可以是任意可调用对象。概括地讲，装饰器的作用就是在不修改装饰器对象源代码和调用方式的前提下为被装饰对象添加额外的功能。装饰器经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等应用场景，装饰器是解决这类问题的绝佳设计，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续使用。 提示：可调用对象有函数，方法或者类，此处我们单以函数为例，来介绍装饰器，并且被装饰的对象也是函数。 二、装饰器的实现函数装饰器分为：无参装饰器和有参装饰器两种，二者实现原理一样，都是‘函数+闭包+函数对象’的组合使用的产物。 无参装饰器的实现如果想为下述函数添加统计其执行时间的功能 12345678910import timedef index(): time.sleep(3) print(&#x27;Welcome to the index page&#x27;) return 200index() # 函数执行 遵循不修改被装饰器对象源代码的原则，我们想到的解决方法可能是这样 1234start_time = time.time()index()stop_time = time.time()print(&#x27;run time is %s&#x27; % (stop_time-start_time)) 考虑到还有可能要统计其他函数的执行之间，于是我们将其做成一个单独的工具，，函数体需要外部传入被装饰的函数从而进行调用，我们可以使用参数的形式传入 123456def wrapper(func): # 通过参数接收外部的值 start_time = time.time() res = func() stop_time = time.time() print(&#x27;run time is %s&#x27; % (stop_time-start_time)) return res 但之后函数的调用方式都需要改成 12wrapper(index)wrapper(其他函数) 这便违反了不能修改被装饰对象调用方式的原则，于是我们换一种为函数体传值的方式，即将值包给函数，如下 12345678def timer(func): def wrapper(): # 通过参数接收外部的值 start_time = time.time() res = func() stop_time = time.time() print(&#x27;run time is %s&#x27; % (stop_time-start_time)) return res return wrapper 这样我们便可以在不修改被装饰函数源代码和调用方式的前提下为其加上统计时间的功能，只不过需要事先执行一次timer将被装饰的函数传入，返回一个闭包函数wrapper重新赋值给变量名&#x2F;函数名index，如下 12index = timer(index) # 得到index = wrapper,wrapper携带对外作用域的引用；func = 原始的indexindex() # 执行的是wrapper(),在wrapper的函数体内再执行最原始的index 至此我们便实现了一个无参装饰器timer，可以在不修改被装饰对象index源代码和调用方式的前提下为其加上新功能。但我们忽略了若被装饰的函数是一个有参函数，便会抛出异常 123456789def home(name): time.sleep(2) print(&#x27;Welcome to the home page&#x27;, name) home = timer(home)home(&#x27;egon&#x27;)# 抛出异常TypeError: wrapper() takes 0 positional arguments but 1 was given 之所以会抛出异常，是因为home(‘egon’)调用的其实是wrapper(‘egon’),而函数wrapper没有参数。wrapper函数接收的参数其实是给最原始的func用的，为了能满足被装饰函数参数的所有情况，使用上*args+**kwargs组合，于是修正装饰器timer如下 12345678def timer(func): def wrapper(*args,**kwargs): start_time = time.time() res = func(*args,**kwargs) stop_time = time.time() print(&#x27;run time is %s&#x27; % (stop_time-start_time)) return res return wrapper 此时我们就可以用timer来装饰带参数或不带参数的函数了，但是为了简洁而优雅地使用装饰器，python提供了专门的装饰器语法来取代index&#x3D;timer(index)的形式，需要在被装饰对象的正上方单独一行添加@timer,当解释器解释到@time函数，且把它正下方的函数名当作实参传入，然后将返回的结果重新赋值给原函数名 1234567891011@timer # index = timer(index)def index(): time.sleep(3) print(&#x27;Welcome to the index page&#x27;) return 200@timer # home = timer(home)def home(name): time.sleep(2) print(&#x27;Welcome to the home page&#x27;, name) 如果我们有多个装饰器，可以叠加多个 1234567@deco3@deco2@deco1def index(): pass# 本质：index = deco3(deco2(deco1(index))) 有参装饰器的实现了解无参装饰器的实现原理后，我们可以再实现一个用来为被装饰对象添加认证功能的装饰器，实现的基本形式如下 1234def deco(func): def wrapper(*args,**kwargs): res=func(*args,**kwargs) # 编写基于文件的认证，认证通过则执行,并返回res return wrapper 如果我们想提供多种不同的认证方式以供选择，单从wrapper函数的实现角度改写如下 1234567def deco(func): def wrapper(*args,**kwargs): if driver == &#x27;file&#x27;: res=func(*args,**kwargs) # 编写基于文件的认证，认证通过则执行,并返回res elif driver == &#x27;mysql&#x27;: res=func(*args,**kwargs) # 编写基于文件的认证，认证通过则执行,并返回res return wrapper 函数wrapper需要一个driver参数，而函数deco与wrapper的参数都有其特定的功能，不能用来接收其他类别的参数，可以再deco的外部再包一层auth，用来专门接收额外的参数，这样便保证了再auth函数内无论有多少层都可以引用到 1234def auth(driver): def deco(func): ... return deco 此时我们就实现了一个有参装饰器，使用方式如下 123456789# 先调用auth_type(drive=&#x27;file&#x27;),得到@deco,deco是一个闭包函数，包含了对外部作用域名字driver的引用，@driver的语义与无参装饰器一样@auth(driver=&#x27;file&#x27;)def index(): pass@auth(driver=&#x27;mysql&#x27;)def home(): pass 可以使用help(函数名)来查看函数的文档注释，本质就是查看函数的doc属性，但对于装饰之后的函数，查看文档注释 1","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"14、函数对象与闭包","slug":"14、函数对象和闭包","date":"2018-05-13T06:04:14.000Z","updated":"2022-05-13T12:28:14.812Z","comments":true,"path":"2018/05/13/14、函数对象和闭包/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/14%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/","excerpt":"","text":"一 函数对象 1.1 函数可以被引用 1.2 函数可以作为容器类型的元素 1.3 函数可以作为参数传入另外一个函数 1.4 函数的返回值可以是一个函数 二 闭包函数 2.1 闭与包 2.2 闭包的用途 一 函数对象函数对象指的是函数可以被当做’数据’来处理，具体可以分为四个方面的使用，我们如下 1、函数可以被引用123456&gt;&gt;&gt; def add(x,y):... return x+y... &gt;&gt;&gt; func=add&gt;&gt;&gt; func(1,2)3 2、函数可以作为容器类型的元素12345&gt;&gt;&gt; dic=&#123;&#x27;add&#x27;:add,&#x27;max&#x27;:max&#125;&gt;&gt;&gt; dic&#123;&#x27;add&#x27;: &lt;function add at 0x100661e18&gt;, &#x27;max&#x27;: &lt;built-in function max&gt;&#125;&gt;&gt;&gt; dic[&#x27;add&#x27;](1,2)3 3、函数可以作为参数传入另一个函数12345&gt;&gt;&gt; def foo(x,y,func):... return func(x,y)...&gt;&gt;&gt; foo(1,2,add)3 4、函数的返回值可以是一个函数12345def bar(): return add func=bar() func(1,2)3 二 闭包函数1、闭与包基于函数对象的概念，可以将函数返回到任意位置去调用，但作用域的关系是在定义完函数时就已经被确定了的，与函数的调用位置无关。 1234567891011121314x=1def f1(): def f2(): print(x) return f2def f3(): x=3 f2=f1() #调用f1()返回函数f2 f2() #需要按照函数定义时的作用关系去执行，与调用位置无关f3() #结果为1 也就是说函数被当做数据处理时，始终以自带的作用域为准。若内嵌函数包含对外部函数作用域（而非全局作用域）中变量的引用，那么该’内嵌函数’就是闭包函数，简称闭包(Closures) 123456789x=1def outer(): x=2 def inner(): print(x) return innerfunc=outer()func() # 结果为2 可以通过函数的closure属性，查看到闭包函数所包裹的外部变量 1234&gt;&gt;&gt; func.__closure__(&lt;cell at 0x10212af78: int object at 0x10028cca0&gt;,)&gt;&gt;&gt; func.__closure__[0].cell_contents2 “闭”代表函数是内部的，“包”代表函数外’包裹’着对外层作用域的引用。因而无论在何处调用闭包函数，使用的仍然是包裹在其外层的变量。 2、闭包的用途目前为止，我们得到了两种为函数体传值的方式，一种是直接将值以参数的形式传入，另外一种就是将值包给函数 1234567891011import requests#方式一：def get(url): return requests.get(url).text#方式二：def page(url): def get(): return requests.get(url).text return get 提示：requests模块是用来模拟浏览器向网站发送请求并将页面内容下载到本地，需要事先安装：pip3 install requests 对比两种方式，方式一在下载同一页面时需要重复传入url，而方式二只需要传一次值，就会得到一个包含指定url的闭包函数，以后调用该闭包函数无需再传url 123456789101112# 方式一下载同一页面get(&#x27;https://www.python.org&#x27;)get(&#x27;https://www.python.org&#x27;)get(&#x27;https://www.python.org&#x27;)……# 方式二下载同一页面python=page(&#x27;https://www.python.org&#x27;)python()python()python()…… 闭包函数的这种特性有时又称为惰性计算。使用将值包给函数的方式，在接下来的装饰器中也将大有用处","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"13、名称空间与作用域","slug":"13、名称空间与作用域","date":"2018-05-13T06:04:13.000Z","updated":"2022-05-13T12:28:12.053Z","comments":true,"path":"2018/05/13/13、名称空间与作用域/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/13%E3%80%81%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"一、名称空间 ​ 1.内建名称空间 ​ 2、全局名称空间 ​ 3、局部名称空间 二、作用域 ​ 1、全局作用域 ​ 2、作用域与名字查找的优先级 一、名称空间名称空间即存放名字与对象映射&#x2F;绑定关系的地方。对于x&#x3D;3，Python会申请内存空间存放对象3，然后将名字x与3的绑定关系存放于名称空间中，del x表示清除该绑定关系 在程序执行期间最多会存在三种名称空间 1.内建名称空间伴随python解释器的启动&#x2F;关闭而产生&#x2F;回收，因而是第一个被加载的名称空间，用来存放一些内置的名字，比如内建函数名 12&gt;&gt;&gt; max&lt;built-in function max&gt; #built-in内建 2、全局名称空间伴随python文件的开始执行&#x2F;执行完毕而产生&#x2F;回收，是第二个被加载的名称空间，文件执行过程中产生的名字都会存放于该名称空间中，如下名字 1234567891011121314import sys #模块名sysx=1 #变量名xif x == 1: y=2 #变量名ydef foo(x): #函数名foo y=1 def bar(): passClass Bar: #类名Bar pass 3、局部名称空间伴随函数的调用&#x2F;结束而临时产生&#x2F;回收，函数的形参、函数内定义的名字都会被存放于该名称空间中 12def foo(x): y=3 #调用函数时，才会执行函数代码，名字x和y都存放于该函数的局部名称空间中 二、作用域1、全局作用域与局部作用域按照名字作用范围的不同可以将三个名称空间划分为两个区域： 全局作用域:位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活（除非被删除，否则在整个文件执行过程中存活）、全局有效（在任意位置都可以使用）； 局部作用域:位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活（即在函数调用时临时生成，函数调用结束后就释放）、局部有效（只能在函数内使用）。 2、作用域与名字查找的优先级在局部作用域查找名字时，起始位置是局部作用域，所以先查找局部名称空间，没有找到，再去全局作用域查找：先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常 12345x=100 #全局作用域的名字xdef foo(): x=300 #局部作用域的名字x print(x) #在局部找xfoo()#结果为300 在全局作用域查找名字时，起始位置便是全局作用域，所以先查找全局名称空间，没有找到，再查找内置名称空间，最后都没有找到就会抛出异常 12345x=100def foo(): x=300 #在函数调用时产生局部作用域的名字xfoo()print(x) #在全局找x,结果为100 提示：可以调用内建函数locals()和globals()来分别查看局部作用域和全局作用域的名字，查看的结果都是字典格式。在全局作用域查看到的locals()的结果等于globals() Python支持函数的嵌套定义，在内嵌的函数内查找名字时，会优先查找自己局部作用域的名字，然后由内而外一层层查找外部嵌套函数定义的作用域，没有找到，则查找全局作用域 1234567891011121314x=1def outer(): x=2 def inner(): # 函数名inner属于outer这一层作用域的名字 x=3 print(&#x27;inner x:%s&#x27; %x) inner() print(&#x27;outer x:%s&#x27; %x)outer() #结果为inner x:3outer x:2 在函数内，无论嵌套多少层，都可以查看到全局作用域的名字，若要在函数内修改全局名称空间中名字的值，当值为不可变类型时，则需要用到global关键字 123456x=1def foo(): global x #声明x为全局名称空间的名字 x=2foo()print(x) #结果为2 当实参的值为可变类型时，函数体内对该值的修改将直接反应到原值， 12345678num_list=[1,2,3]def foo(nums): nums.append(5)foo(num_list)print(num_list)#结果为[1, 2, 3, 5] 对于嵌套多层的函数，使用nonlocal关键字可以将名字声明为来自外部嵌套函数定义的作用域（非全局） 123456789101112def f1(): x=2 def f2(): nonlocal x x=3 f2() #调用f2(),修改f1作用域中名字x的值 print(x) #在f1作用域查看xf1()#结果3 nonlocal x会从当前函数的外层函数开始一层层去查找名字x，若是一直到最外层函数都找不到，则会抛出异常。","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"12、函数的参数","slug":"12、函数的参数","date":"2018-05-13T06:04:12.000Z","updated":"2022-05-13T12:28:08.881Z","comments":true,"path":"2018/05/13/12、函数的参数/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/12%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/","excerpt":"","text":"一 形参与实参介绍 二 形参与实参的具体使用 1.位置参数 2.关键字参数 3.默认参数 4.可变长度的参数 可变长度的位置参数 可变长度的关键字参数 5.命名关键字参数 6.组合使用 一 形参与实参介绍函数的参数分为形式参数和实际参数，简称形参和实参： 形参即在定义函数时，括号内声明的参数。形参本质就是一个变量名，用来接收外部传来的值。 实参即在调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合: 1234567891011121314#1：实参是常量res=my_min(1,2)#2：实参是变量a=1b=2res=my_min(a,b)#3：实参是表达式res=my_min(10*2,10*my_min(3,4))#4：实参可以是常量、变量、表达式的任意组合a = 2my_min(1, a, 10*my_min(1,2)) 在调用有参函数时，实参（值）会赋值给形参（变量名）。在Python中，变量名与值只是单纯的绑定关系，而对于函数来说，这种绑定关系只在函数调用时生效，在调用结束后解除。 二 形参与实参的具体使用1.位置参数位置即顺序，位置参数指的是按顺序定义的参数，需要从两个角度去看： ​ (1) 在定义函数时，按照从左到右的顺序依次定义形参,称为位置形参，凡是按照这种形式定义的形参都必须被传值 123def register(name,age,sex): #定义位置形参：name，age，sex，三者都必须被传值 print(&#x27;Name:%s Age:%s Sex:%s&#x27; %(name,age,sex))register() #TypeError：缺少3个位置参数 ​ (2)在调用函数时，按照从左到右的顺序依次定义实参，称为位置实参，凡是按照这种形式定义的实参会按照从左到右的顺序与形参一一对应 123def register(name,age,sex): #定义位置形参：name，age，sex，三者都必须被传值 print(&#x27;Name:%s Age:%s Sex:%s&#x27; %(name,age,sex))register(1,2,3) #3个位置实参 2.关键字参数在调用函数时，实参可以是key&#x3D;value的形式，称为关键字参数，凡是按照这种形式定义的实参，可以完全不按照从左到右的顺序定义，但仍能为指定的形参赋值 12&gt;&gt;&gt; register(sex=&#x27;male&#x27;,name=&#x27;lili&#x27;,age=18)Name:lili Age:18 Sex:male 需要注意在调用函数时，实参也可以是按位置或按关键字的混合使用，但必须保证关键字参数在位置参数后面，且不可以对一个形参重复赋值 123&gt;&gt;&gt; register(&#x27;lili&#x27;,sex=&#x27;male&#x27;,age=18) #正确使用&gt;&gt;&gt; register(name=&#x27;lili&#x27;,18,sex=&#x27;male&#x27;) #SyntaxError：关键字参数name=‘lili’在位置参数18之前&gt;&gt;&gt; register(&#x27;lili&#x27;,sex=&#x27;male&#x27;,age=18,name=&#x27;jack&#x27;) #TypeError：形参name被重复赋值 3.默认参数在定义函数时，就已经为形参赋值，这类形参称之为默认参数，当函数有多个参数时，需要将值经常改变的参数定义成位置参数，而将值改变较少的参数定义成默认参数。例如编写一个注册学生信息的函数，如果大多数学生的性别都为男，那完全可以将形参sex定义成默认参数 123&gt;&gt;&gt; def register(name,age,sex=&#x27;male&#x27;): #默认sex的值为male... print(&#x27;Name:%s Age:%s Sex:%s&#x27; %(name,age,sex))... 定义时就已经为参数sex赋值，意味着调用时可以不对sex赋值，这降低了函数调用的复杂度 1234&gt;&gt;&gt; register(&#x27;tom&#x27;,17) #大多数情况,无需为sex传值,默认为maleName:tom Age:17 Sex:male&gt;&gt;&gt; register(&#x27;Lili&#x27;,18,&#x27;female&#x27;) #少数情况,可以为sex传值femaleName:Lili Age:18 Sex:female 需要注意： 默认参数必须在位置参数之后 默认参数的值仅在函数定义阶段被赋值一次 123456x = 1def foo(arg=x): print(arg)x = 5foo() # 1 ​ 3.默认参数的值通常应设为不可变类型 123456789def foo(n,arg=[]): arg.append(n) return arg foo(1) [1] foo(2) [1, 2] foo(3) [1, 2, 3] 每次调用是在上一次的基础上向同一列表增加值，修改如下 1234567891011def foo(n,arg=None): if arg is None: arg=[] arg.append(n) return arg foo(1) [1] foo(2) [2] foo(3) [3] 4.可变长度的参数（*、**）参数的长度可变指的是在调用函数时，实参的个数可以不固定，而在调用函数时，实参的定义无非是按位置或者按关键字两种形式，这就要求形参提供两种解决方案来分别处理两种形式的可变长度的参数 1） 可变长度的位置参数如果在最后一个形参名前加星号,那么在调用函数时，溢出的位置实参，都会被星接收，以元组的形式保存下来赋值给该形参 123456789101112&gt;&gt;&gt; def foo(x,y,z=1,*args): #在最后一个形参名args前加*号... print(x)... print(y)... print(z)... print(args)... &gt;&gt;&gt; foo(1,2,3,4,5,6,7) #实参1、2、3按位置为形参x、y、z赋值，多余的位置实参4、5、6、7都被*接收，以元组的形式保存下来，赋值给args，即args=(4, 5, 6,7)123(4, 5, 6, 7) 如果我们事先生成了一个列表,仍然是可以传值给*args的 12345678910&gt;&gt;&gt; def foo(x,y,*args):... print(x)... print(y)... print(args)... &gt;&gt;&gt; L=[3,4,5]&gt;&gt;&gt; foo(1,2,*L) # *L就相当于位置参数3，4，5, foo(1,2,*L)就等同于foo(1,2,3,4,5)12(3, 4, 5) 注意：如果在传入L时没有加*,那L就只是一个普通的位置参数了 1234&gt;&gt;&gt; foo(1,2,L) #仅多出一个位置实参L12([1, 2, 3],) 如果形参为常规的参数（位置或默认），实参仍可以是*的形式 123456789&gt;&gt;&gt; def foo(x,y,z=3):... print(x)... print(y)... print(z)... &gt;&gt;&gt; foo(*[1,2]) #等同于foo(1,2)123 如果我们想要求多个值的和，*args就派上用场了 12345678&gt;&gt;&gt; def add(*args):... res=0... for i in args:... res+=i... return res... &gt;&gt;&gt; add(1,2,3,4,5)15 2） 可变长度的关键字参数如果在最后一个形参名前加双星号,那么在调用函数时，溢出的关键字参数，都会被双星接收，以字典的形式保存下来赋值给该形参 1234567&gt;&gt;&gt; def foo(x,**kwargs): #在最后一个参数kwargs前加**... print(x) ... print(kwargs) ... &gt;&gt;&gt; foo(y=2,x=1,z=3) #溢出的关键字实参y=2，z=3都被**接收，以字典的形式保存下来，赋值给kwargs1&#123;&#x27;z&#x27;: 3, &#x27;y&#x27;: 2&#125; 如果我们事先生成了一个字典,仍然是可以传值给**kwargs的 12345678910&gt;&gt; def foo(x,y,**kwargs):... print(x)... print(y)... print(kwargs)... &gt;&gt;&gt; dic=&#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2&#125; &gt;&gt;&gt; foo(1,2,**dic) #**dic就相当于关键字参数a=1，b=2，foo(1,2,**dic)等同foo(1,2,a=1,b=2)12&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125; 注意：如果在传入dic时没有加**,那dic就只是一个普通的位置参数了 1&gt;&gt;&gt; foo(1,2,dic) #TypeError:函数foo只需要2个位置参数，但是传了3个 如果形参为常规参数（位置或默认），实参仍可以是**的形式 123456789&gt;&gt;&gt; def foo(x,y,z=3):... print(x)... print(y)... print(z)... &gt;&gt;&gt; foo(**&#123;&#x27;x&#x27;:1,&#x27;y&#x27;:2&#125;) #等同于foo(y=2,x=1)123 如果我们要编写一个用户认证的函数，起初可能只基于用户名密码的验证就可以了，可以使用**kwargs为日后的扩展供良好的环境，同时保持了函数的简洁性。 123&gt;&gt;&gt; def auth(user,password,**kwargs): ... pass ... 5. 命名关键字参数在定义了**kwargs参数后，函数调用者就可以传入任意的关键字参数key&#x3D;value，如果函数体代码的执行需要依赖某个key，必须在函数内进行判断 12345678&gt;&gt;&gt; def register(name,age,**kwargs):... if &#x27;sex&#x27; in kwargs:... #有sex参数... pass... if &#x27;height&#x27; in kwargs:... #有height参数... pass... 想要限定函数的调用者必须以key&#x3D;value的形式传值，Python3提供了专门的语法：需要在定义形参时，用星作为一个分隔符号，星号之后的形参称为命名关键字参数。对于这类参数，在函数调用时，必须按照key&#x3D;value的形式为其传值，且必须被传值 123456&gt;&gt;&gt; def register(name,age,*,sex,height): #sex,height为命名关键字参数... pass... &gt;&gt;&gt; register(&#x27;lili&#x27;,18,sex=&#x27;male&#x27;,height=&#x27;1.8m&#x27;) #正确使用&gt;&gt;&gt; register(&#x27;lili&#x27;,18,&#x27;male&#x27;,&#x27;1.8m&#x27;) # TypeError:未使用关键字的形式为sex和height传值&gt;&gt;&gt; register(&#x27;lili&#x27;,18,height=&#x27;1.8m&#x27;) # TypeError没有为命名关键字参数sex传值。 命名关键字参数也可以有默认值，从而简化调用 12345&gt;&gt;&gt; def register(name,age,*,sex=&#x27;male&#x27;,height):... print(&#x27;Name:%s,Age:%s,Sex:%s,Height:%s&#x27; %(name,age,sex,height))... &gt;&gt;&gt; register(&#x27;lili&#x27;,18,height=&#x27;1.8m&#x27;)Name:lili,Age:18,Sex:male,Height:1.8m 需要强调的是：sex不是默认参数，height也不是位置参数，因为二者均在星后，所以都是命名关键字参数，形参sex&#x3D;’male’属于命名关键字参数的默认值，因而即便是放到形参height之前也不会有问题。另外，如果形参中已经有一个星args了，命名关键字参数就不再需要一个单独的星作为分隔符号了 12345&gt;&gt;&gt; def register(name,age,*args,sex=&#x27;male&#x27;,height):... print(&#x27;Name:%s,Age:%s,Args:%s,Sex:%s,Height:%s&#x27; %(name,age,args,sex,height))... &gt;&gt;&gt; register(&#x27;lili&#x27;,18,1,2,3,height=&#x27;1.8m&#x27;) #sex与height仍为命名关键字参数Name:lili,Age:18,Args:(1, 2, 3),Sex:male,Height:1.8m 6.组合使用综上所述所有参数可任意组合使用，但定义顺序必须是：位置参数、默认参数、*args、命名关键字参数、**kwargs 可变参数*args与关键字参数kwargs通常是组合在一起使用的，如果一个函数的形参为*args与kwargs，那么代表该函数可以接收任何形式、任意长度的参数 123&gt;&gt;&gt; def wrapper(*args,**kwargs):... pass... 在该函数内部还可以把接收到的参数传给另外一个函数（这在4.6小节装饰器的实现中大有用处） 12345678&gt;&gt;&gt; def func(x,y,z):... print(x,y,z)... &gt;&gt;&gt; def wrapper(*args,**kwargs):... func(*args,**kwargs)...&gt;&gt;&gt; wrapper(1,z=3,y=2)1 2 3 按照上述写法，在为函数wrapper传参时，其实遵循的是函数func的参数规则，调用函数wrapper的过程分析如下： 位置实参1被*接收，以元组的形式保存下来，赋值给args，即args&#x3D;(1,),关键字实参z&#x3D;3，y&#x3D;2被**接收，以字典的形式保存下来，赋值给kwargs，即kwargs&#x3D;{‘y’: 2, ‘z’: 3} 执行func(args,kwargs),即func((1,),* {‘y’: 2, ‘z’: 3}),等同于func(1,z&#x3D;3,y&#x3D;2) 1提示： *args、**kwargs中的args和kwargs被替换成其他名字并无语法错误，但使用args、kwargs是约定俗成的。","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"11、函数的基本使用","slug":"11、函数的基本使用","date":"2018-05-13T06:04:11.000Z","updated":"2022-05-13T12:28:06.403Z","comments":true,"path":"2018/05/13/11、函数的基本使用/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/11%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176&quot;&quot;&quot;1 什么是函数 函数就是盛放功能(一系列代码)的容器 定义函数就是造出了一个工具 事先准备工具的过程-&gt;函数的定义 遇到应用场景拿来就用-&gt;函数的调用2 为何要用函数 不用函数写出的代码问题是: 1 程序的组织结构不清晰,可读性差,可维护性差 2 可扩展性差3 如何用函数 原则: 先定义 后调用 定义函数的语法: def 函数名(参数1,参数2,参数3,...): 代码1 代码2 代码3 return 值 调用函数语法: res = 函数名(值1,值2,值3)&quot;&quot;&quot;1 定义函数与调用函数x = 10y = xprint(x)def func(): # func = 函数的内存地址 print(&quot;*&quot; * 40) print(&quot;hello&quot;.center(40, &#x27; &#x27;)) print(&#x27;=&#x27; * 40)print(func)f = funcf()func()func()func()2 函数定义阶段发生的事情: 申请内存空间,把函数体代码放进去,然后把内存地址绑定给函数名def func(): print(1) print(2 print(3)3 函数调用阶段发生的事情: 执行函数体代码def func(): print(1) print(2) asdf print(3)func()ps: 函数定义阶段只检测语法不执行代码,只有在调用函数时才会执行函数体代码# 例1:def bar(): print(&#x27;from bar&#x27;)def foo(): print(&#x27;from foo&#x27;) bar()foo()例2:def foo(): print(&#x27;from foo&#x27;) bar()def bar(): print(&#x27;from bar&#x27;)foo() # 函数的参数：def add(x,y): res = x + y print(res)add(1,2)def func(x, y): if x &gt; y: print(x) else: print(y)func(11231231231, 22123123123213)def login(inp_user,inp_pwd): if inp_user == &#x27;egon&#x27; and inp_pwd == &quot;123&quot;: print(&#x27;ok&#x27;) else: print(&#x27;error&#x27;)login(&#x27;egon&#x27;,&quot;123&quot;)l = [111, 222, 333, 444, 555]size = len(l)if size &gt; 3: print(&#x27;ok&#x27;)else: print(&#x27;no&#x27;)def max2(sal1, sal2): if sal1 &gt; sal2: return sal1 else: return sal2res = max2(1000,2000)print(res * 12)l = [111, 22, 333]res = l.append(4444)res = l.pop()print(res)return返回值的语法:函数内可以有多个return,但只要执行一次,整个函数就立即结束,并且将return后的值当作本次调用的产品返回def func(): print(&#x27;aaaa&#x27;) return 11111111111111 print(&#x27;bbbb&#x27;) return 2222222222 print(&#x27;cccc&#x27;) return 333333333res = func()print(res)具体来说函数的返回值有三种形式1 return 值: 返回的就是改值本身/-2 return 值1,值2,值3:返回的是小元组def func(): return 1111,&quot;aaa&quot;,[11,222]x,y,z = func()print(x,y,z)# 3 没有return或者return无值或者return None:返回的都是Nonedef func(): res = 1 + 2 returnres = func()print(res)","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"10、文件处理","slug":"10、文件处理","date":"2018-05-13T06:04:10.000Z","updated":"2022-05-13T12:28:03.827Z","comments":true,"path":"2018/05/13/10、文件处理/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/10%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"","text":"文件操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272操作系统 windows mac linux双击文件 硬盘转 磁头读取数据保存文件 硬盘转 磁头写入数据 我们在操作文件的时候其实操作的是硬盘&#x27;&#x27;&#x27;文件其实是操作系统暴露给我们可以简单快捷的操作硬盘的接口&#x27;&#x27;&#x27;绝对路径与相对路径 绝对路径 非常详细的路径描述 无论什么人什么位置都可以找到 相对路径 有一个参考 只有对应的人才可以找到 # 一、文件处理 # res = open(r&#x27;a.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf8&#x27;)# print(res.read())# res.close()# 打开a.txt 使用变量名f指代改文件# with open(r&#x27;a.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf8&#x27;) as f:# print(f.read()) # 读取文件内容 # with子代码运行结束之后会自动调用close关闭文件资源# &quot;&quot;&quot;# with open(文件路径,读写模式,编码格式) as 变量名:# 子代码块# 文件路径是必须的# 读写模式和编码格式是可选的# &quot;&quot;&quot;# 如果不指定读写模式 那么默认使用r# 如果不指定编码格式 那么默认使用当前计算机内部默认编码&quot;&quot;&quot;在中国所有的windows电脑内部默认的编码是gbk&quot;&quot;&quot;with open(r&#x27;a.txt&#x27;) as f: print(f.read()) # 读取文件内容# 取消转义# res = r&#x27;D:\\day08\\a.txt&#x27;# res1 = r&#x27;D:\\day08\\n.txt&#x27;# res2 = r&#x27;D:\\day08\\t.txt&#x27;# print(res,res1,res2)with open(r&#x27;a.txt&#x27;, mode=&#x27;rt&#x27;, encoding=&#x27;utf-8&#x27;) as f, \\ open(r&#x27;b.txt&#x27;, mode=&#x27;wt&#x27;, encoding=&#x27;utf-8&#x27;) as f2: pass# 二、文件打开模式# 1、控制文件读写操作的模式# r（默认）# w# a# 2、控制文件读写内容的模式# t（默认的）：读写都是以字符串为单位的，只适用于文件文件，必须指定encoding参数# b：读写都是以bytes为单位的，适用于所有文件，一定不能指定encoding参数# r模式：只读模式，如果文件不存在则报错,文件存在则文件指针处于文件开头f = open(&#x27;a.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;)print(f.read())print(&#x27;=&#x27;*50)print(f.read())print(f.readable())print(f.writable())f.close()# w模式：只写模式，如果文件不存在则创建空文档,文件存在则清空，文件指针处于文件开头f = open(&#x27;a.txt&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;)f.write(&quot;你好\\n&quot;)f.write(&quot;哈哈哈\\n&quot;)f.write(&quot;我擦勒\\n&quot;)f.write(&quot;你好\\n哈哈哈\\n我擦勒\\n&quot;)print(f.readable())print(f.writable())f.close()# 总结：w模式，在打开了文件不关的情况下，连续的write写入，新写的内容永远跟在后面# a模式：只追加写模式，如果文件不存在则创建空文档,文件存在不会清空，文件指针处于文件末尾f = open(&#x27;c.txt&#x27;,mode=&#x27;at&#x27;,encoding=&#x27;utf-8&#x27;)f.write(&quot;4444\\n&quot;)f.write(&quot;555\\n&quot;)f.write(&quot;6666\\n&quot;)print(f.readable())print(f.writable())f.close()# 总结：a模式，在打开了文件不关的情况下，连续的write写入，新写的内容永远跟在后面,这一点与w模式相同# 不同的是，在打开了文件关闭然后重新打开的情况下，a模式永远写在后面# b模式：读写都是以bytes为单位的，适用于所有文件，一定不能指定encoding参数with open(&#x27;1.mp4&#x27;,mode=&#x27;rb&#x27;) as f: res = f.read() print(res.decode(&#x27;utf-8&#x27;))with open(&#x27;a.txt&#x27;,mode=&#x27;rb&#x27;) as f: res = f.read() print(res.decode(&#x27;utf-8&#x27;))with open(&#x27;a.txt&#x27;,mode=&#x27;ab&#x27;) as f: f.write(&quot;啊手动阀手动阀&quot;.encode(&#x27;utf-8&#x27;))# 例：文件拷贝功能# # 方案一：with open(&#x27;1.mp4&#x27;,mode=&#x27;rb&#x27;) as f1,open(r&#x27;D:\\1111111.mp4&#x27;,mode=&#x27;wb&#x27;) as f2: res = f1.read() f2.write(res)# 方案二：# 储备知识：with open(&#x27;a.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f: # f.read() for line in f: print(line,end=&#x27;&#x27;)with open(&#x27;1.mp4&#x27;,mode=&#x27;rb&#x27;) as f: for line in f: print(line)# 具体实现：with open(&#x27;1.mp4&#x27;,mode=&#x27;rb&#x27;) as f1,open(r&#x27;D:\\1111111.mp4&#x27;,mode=&#x27;wb&#x27;) as f2: for line in f1: f2.write(line)# 可读可写# r+t# w+t# a+t## r+b# w+b# a+bwith open(&#x27;a.txt&#x27;,mode=&#x27;r+t&#x27;,encoding=&#x27;utf-8&#x27;) as f: print(f.readable()) print(f.writable()) print(f.read()) f.write(&quot;22222222222222222222\\n&quot;)with open(&#x27;a.txt&#x27;,mode=&#x27;w+t&#x27;,encoding=&#x27;utf-8&#x27;) as f: print(f.readable()) print(f.writable()) # 三、文件操作的其他方法with open(&#x27;a.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f: # lines = f.readlines() # print(lines) print(f.readline()) print(f.readline())with open(&#x27;a.txt&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f: # f.write(&quot;111\\n222\\n333\\n&quot;) # lines = [&#x27;111\\n&#x27;,&#x27;222\\n&#x27;,&#x27;3333\\n&#x27;] # for line in lines: # f.write(line) # f.writelines(lines) f.write(&#x27;hello&#x27;) f.flush() # 令操作系统直接存储硬盘，而不是等缓存到一定大小后在存 # f.writelines(&#x27;hello&#x27;)# 四、操控文件指针移动# 大前提：只有t模式下的，f.read(n)中的n代表的是字符个数，除此以外，关于指针的移动，单位都是字节bytes# f.read()# with open(&#x27;a.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f:# res = f.read(6)# print(res)# with open(&#x27;a.txt&#x27;,mode=&#x27;rb&#x27;) as f:# # res = f.read(6)# res = f.read(8)# print(res.decode(&#x27;utf-8&#x27;))# f.truncate()# with open(&#x27;a.txt&#x27;,mode=&#x27;r+t&#x27;,encoding=&#x27;utf-8&#x27;) as f:# f.truncate(8)# f.seek移动的全都是字节个数，字符串中：在UTF-8编码中：一个中文等于三个字节，中文标点占三个字节.一个英文字符等于一个字节，英文标点占一个字节。# Unicode中：一个英文等于两个字节，一个中文（含繁体）等于两个字节。中文标点占两个字节，英文标点。 f.seek(字节个数,0)f.seek(字节个数,1)f.seek(字节个数,2)ps：只有0模式可以t下使用，其中1和2模式只能在b模式下使用，但是无论在t模式还是b模式下，移动的都是字节个数with open(&#x27;a.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f: print(f.tell()) # f.seek(9,0) # f.seek(3,0) print(f.tell())with open(&#x27;a.txt&#x27;,mode=&#x27;rb&#x27;) as f: print(f.tell()) f.seek(9,1) f.seek(3,1) print(f.tell())with open(&#x27;a.txt&#x27;,mode=&#x27;rb&#x27;) as f: print(f.tell()) f.seek(0,2) print(f.tell())with open(&#x27;a.txt&#x27;,mode=&#x27;ab&#x27;) as f: print(f.tell()) # 文件修改的两种方式with open(&#x27;test.txt&#x27;, mode=&#x27;r+t&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.seek(9,0) f.write(&quot;hello&quot;)文件修改的原理：把硬盘数据读入内存，在内存修改完毕后，再覆盖回硬盘具体来说又分为两种方案方案一：with open(&#x27;test.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f: data = f.read()with open(&#x27;test.txt&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f: f.write(data.replace(&#x27;egon&#x27;,&#x27;EGON&#x27;))方案二：import oswith open(&#x27;test.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f1,\\ open(&#x27;.test.txt.swp&#x27;,mode=&#x27;wt&#x27;,encoding=&#x27;utf-8&#x27;) as f2: for line in f1: f2.write(line.replace(&#x27;EGON&#x27;,&quot;egon&quot;))os.remove(&#x27;test.txt&#x27;)os.rename(&#x27;.test.txt.swp&#x27;,&#x27;test.txt&#x27;)","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"9、字符编码","slug":"09、字符编码","date":"2018-05-13T06:04:09.000Z","updated":"2022-05-13T12:28:01.463Z","comments":true,"path":"2018/05/13/09、字符编码/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/09%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/","excerpt":"","text":"字典与集合练习题实操 字符编码 字符编码发展史 字符编码实操 字典与集合练习题详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283841.字典练习题 1.将列表中大于等于66的元素放入字典k1键对应的列表中 将列表中小于66的元素放入字典k2键对应的列表中 nums = [11, 22, 33, 44, 55, 66, 77, 88, 99, 90] dic = &#123; &#x27;k1&#x27;: [], &#x27;k2&#x27;: [] &#125; for i in nums: if i &gt;= 66: dic[&#x27;k1&#x27;].append(i) else: dic[&#x27;k2&#x27;].append(i) print(dic) 2.s=&#x27;hello jason jason say hello sb sb sb&#x27; 统计字符串中每个单词出现的次数 &#123;&#x27;jason&#x27;:2,...&#125; # 第一种方法 s = &#x27;hello jason jason say hello sb sb sb&#x27; res = s.split() dic = &#123;&#125; for i in res: dic[i] = res.count(i) print(dic) # 第二种方法 s = &#x27;hello jason jason say hello sb sb sb&#x27; res = s.split() dic = &#123;&#125; for i in res: if i not in dic: dic[i] = 1 else: dic[i] += 1 print(dic) #第三种方法 s = &#x27;hello jason jason say hello sb sb sb&#x27; res = s.split() dic = &#123;&#125; for i in res: if dic.get(i) == None: dic[i] = 1 else: dic[i] += 1 print(dic) 2.集合练习题 一.关系运算 有如下两个集合，pythons是报名python课程的学员名字集合，linuxs是报名linux课程的学员名字集合 pythons=&#123;&#x27;alex&#x27;,&#x27;egon&#x27;,&#x27;yuanhao&#x27;,&#x27;wupeiqi&#x27;,&#x27;gangdan&#x27;,&#x27;biubiu&#x27;&#125; linuxs=&#123;&#x27;wupeiqi&#x27;,&#x27;oldboy&#x27;,&#x27;gangdan&#x27;&#125; 1. 求出即报名python又报名linux课程的学员名字集合 2. 求出所有报名的学生名字集合 3. 求出只报名python课程的学员名字 4. 求出没有同时这两门课程的学员名字集合 二 去重并且保留原来的顺序 l = [11,22,33,22,22,33,11,22,55,66,66,77,77] 1.去重不保留顺序 2.去重并且保留顺序 pythons = &#123;&#x27;alex&#x27;, &#x27;egon&#x27;, &#x27;yuanhao&#x27;, &#x27;wupeiqi&#x27;, &#x27;gangdan&#x27;, &#x27;biubiu&#x27;&#125; linuxs = &#123;&#x27;wupeiqi&#x27;, &#x27;oldboy&#x27;, &#x27;gangdan&#x27;&#125; print(&#x27;两个班都报名的人员集合为：&#x27;, pythons &amp; linuxs) print(&#x27;所有报名人员的集合为：&#x27;, pythons | linuxs) print(&#x27;只报名python的人员的集合为：&#x27;, pythons - linuxs) print(&#x27;没有同时报两个班的人员的集合为：&#x27;, pythons ^ linuxs) l = [11, 22, 33, 22, 22, 33, 11, 22, 55, 66, 66, 77, 77] se = list(set(l)) print(&#x27;去重不保留顺序：&#x27;, se) l2 = [] for i in l: if i not in l2: l2.append(i) print(&#x27;去重保留顺序：&#x27;, l2) 字符编码123456789101112131415161718192021222324252627282930313233343536计算机内部存储数据都是以二进制数字的形式存储 计算机基于电工作 而电信号只有高低电平两种状态 也就意味着计算机的世界里只能识别两种状态 我们人为的将高电平定义为数字1 低电平定义为数字0 0 你 1 我 00 01 10 11 000 ... 单位换算(重要) 比特位bit(二进制数的个数) 8bit = 1bytes(字节) 1024bytes = 1KB 1024KB = 1MB 1024MB = 1GB 1024GB = 1TB 1024TB = 1PB 字符编码的研究仅限于文本文件(******)为什么我们人类在使用计算机输入字符的时候电脑展示是人类能够看懂的字符而计算机内部只识别01二进制 00001010 我 00001101 你 计算机二进制 设定好的对应关系 人类的字符 字符编码表 规定了人类的字符与数字之间的对应关系 字符编码发展史123456789101112131415161718192021222324252627282930313233343536373839一家独大 计算机是由美国人发明的 美国人需要计算机能够识别英文 所以发明了ASCII码(字符编码表) 记录了英文与数字的对应关系 1bytes来表示所有的英文及符号 8bit 256 # 所有的英文字母及符号加起来其实也不会超过128种可能群雄割据 中国 中国人为了计算机能够识别中文发明了GBK码 GBK码表 记录了中文、英文与数字的对应关系 2bytes来表示中文及符号 16bit 65535 1bytes来表示所有的英文及符号 # 生僻字可能会使用更多的bytes来表示 日本 日本人为了计算机能识别日文发明了shift_JIS码 shift_JIS码表 记录了日文、英文与数字的对应关系 1bytes来表示所有的英文及符号 韩国 韩国人为了计算机能识别韩文发明了Euc_kr码 Euc_kr码表 记录了韩文、英文与数字的对应关系 1bytes来表示所有的英文及符号天下一统 群雄割据导致数据交互不通畅(乱码) unicode万国码 兼容万国字符 所有的字符同意使用2bytes表示 不够增加更多bytes utf8 unicode transformation format 英文还是用1bytes 中文改用3bytes # 内存使用的编码表是unicode 硬盘使用的是utf8&#x27;&#x27;&#x27;已经你们只需要记住文本文件编码统一使用utf8即可&#x27;&#x27;&#x27; 字符编码实操123456789101112131415161.解决文件乱码的核心 文件以什么编码存的就以什么编码取2.编码与解码(重要) 编码 将人类的字符按照指定的编码转换成计算机能够识别的数据 encode() 解码 将计算机能否识别的数据按照指定的编码转换成人类能够读懂的字符 decode()3.python解释器默认编码 python2默认的是ASCII码 在python2中定义字符串在前面加一个字母u 文件头指定编码 # -*- coding:utf8 -*- name = u&#x27;jason&#x27; python3默认的是utf8码","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"8、基本数据类型与内置方法","slug":"08、python语法入门--基本数据类型及内置方法","date":"2018-05-13T06:04:08.000Z","updated":"2022-05-13T12:27:58.819Z","comments":true,"path":"2018/05/13/08、python语法入门--基本数据类型及内置方法/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/08%E3%80%81python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8--%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/","excerpt":"","text":"数字类型int与float 定义 类型转换 使用 字符串 定义 类型转换 使用 优先掌握的操作 需要掌握的操作 了解操作 列表 定义 类型转化 使用 优先掌握的操作 需要掌握的操作 了解操作 元组 作用 定义方法 类型转换 使用 字典 定义 类型转换 使用 优先掌握的操作 需要掌握的操作 集合 作用 定义 类型转换 使用 关系运算 去重 其他操作 练习 可变类型与不可变类型 数据类型总结 一、数字类型int、float定义12345678910# 定义：# 整形int的定义age = 10 # 本质：age = int(20)# 浮点型float的定义salary = 3000.3 # 本质：salary = float(3000.3)# 注意：名字+括号的意思就是调用某个功能，比如：# print(...)调用打印功能# int(...)调用创建整形数据功能# float(...)调用创造浮点型数据功能 类型转换123456789101112131415161718192021222324252627282930313233# 数据类型转换# int()可以将由纯整数构成的字符串直接转换成整形，若包含其他任意非整数符号，则会报错&gt;&gt;&gt; s = &#x27;123&#x27;&gt;&gt;&gt; res = int(s)&gt;&gt;&gt; res,type(res)(123, &lt;class &#x27;int&#x27;&gt;)&gt;&gt;&gt; int(&#x27;12.3&#x27;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &#x27;12.3&#x27;# 进制转换# 十进制转其他进制&gt;&gt;&gt; bin(3)&#x27;0b11&#x27;&gt;&gt;&gt; oct(9)&#x27;0o11&#x27;&gt;&gt;&gt; hex(17)&#x27;0x11&#x27;# 其他进制转十进制&gt;&gt;&gt; int(&#x27;0b11&#x27;,2)3&gt;&gt;&gt; int(&#x27;0o11&#x27;,8)9&gt;&gt;&gt; int(&#x27;0x11&#x27;,16)17# float同样可以用来做数据类型的转换&gt;&gt;&gt; s = &#x27;12.3&#x27;&gt;&gt;&gt; res = float(s)&gt;&gt;&gt; res,type(res)(12.3, &lt;class &#x27;float&#x27;&gt;) 使用数字类型主要就是用来做数学运算和比较运算，因此数字类型除了掌握与运算符结合使用之外，并无需要掌握的内置方法 二、字符串定义1234# 定义：在单引号、双引号、三引号内包含的一串字符name1 = &#x27;json&#x27; # 本质：name = str(&#x27;任意形式内容&#x27;)name1 = &quot;json&quot; # 本质：name = str(&quot;任意形式内容&quot;)name1 = &quot;&quot;&quot;json&quot;&quot;&quot; # 本质：name = str(&quot;&quot;&quot;任意形式内容&quot;&quot;&quot;) 类型转换123456789# 数据类型转换：str()可以将任意数据类型转换成字符串类型，例如&gt;&gt;&gt; type(str([1,2,3])) # list-&gt;str&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(str(&#123;&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:&#x27;18&#x27;&#125;)) # dict-&gt;str&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(str((1,2,3))) # tuple-&gt;str&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(str(&#123;1,2,3,4&#125;)) # set-&gt;str&lt;class &#x27;str&#x27;&gt; 使用优先掌握的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&gt;&gt;&gt; str1 = &#x27;hello python!&#x27;# 1.按索引取值# 正向取&gt;&gt;&gt; str1[6]&#x27;p&#x27;# 反向取&gt;&gt;&gt; str1[-4]&#x27;h&#x27;# 对于str来说，只能按照索引取值，不能改&gt;&gt;&gt; str1[0]=&#x27;H&#x27;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;str&#x27; object does not support item assignment # 2.切片# 顾头不顾尾&gt;&gt;&gt; str1[0:9]&#x27;hello pyt&#x27;# 步长：第三个参数2代表步长，会从0开始，每次累加一个2即可，所以会取出索引0，2，4，6，8的字符&gt;&gt;&gt; str1[0:9:2]&#x27;hlopt&#x27;# 反向切片：-1表示从右往左依次取值&gt;&gt;&gt; str1[::-1]&#x27;!nohtyp olleh&#x27;# 3.长度len# 获取字符串的长度，即字符的个数，但凡存在于引号内的都算作字符&gt;&gt;&gt; len(str1)13# 4.成员运算 in 和 not in&gt;&gt;&gt; &#x27;hello&#x27; in str1True&gt;&gt;&gt; &#x27;tony&#x27; not in str1True# 5.strip移除字符串首尾指定的字符(默认移除空格)# 括号内不指定字符，默认移除首位空白字符(空格、\\n、\\t)&gt;&gt;&gt; str1 = &#x27; life is short! &#x27;&gt;&gt;&gt; str1.strip()life is short!# 括号内指定字符，移除首位指定的字符&gt;&gt;&gt; str2 = &#x27;**tony**&#x27;&gt;&gt;&gt; str2.strip(&#x27;*&#x27;)tony# 6.切分split# 括号内不指定字符，默认以空格作为分隔符&gt;&gt;&gt; str3 = &#x27;hello world&#x27;&gt;&gt;&gt; str3.split()[&#x27;hello&#x27;,&#x27;world&#x27;]# 括号内指定分隔符，则按照括号内指定的字符切割字符串&gt;&gt;&gt; str4 = &#x27;127.0.0.1&#x27;&gt;&gt;&gt; str4.split(&#x27;.&#x27;)[&#x27;127&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;] # 注意：split切割得到的结果是列表数据类型# 7.循环&gt;&gt;&gt; str5 = &#x27;今天你好吗？&#x27;&gt;&gt;&gt; for line in str5:... print(line)...今天你好吗？ 需要掌握的操作1.strip,lstrip,rstrip (left、right)1234567&gt;&gt;&gt; str1 = &#x27;**tony***&#x27;&gt;&gt;&gt; str1.strip(&#x27;*&#x27;)&#x27;tony&#x27;&gt;&gt;&gt; str1.lstrip(&#x27;*&#x27;)&#x27;tony***&#x27;&gt;&gt;&gt; str1.rstrip(&#x27;*&#x27;)&#x27;**tony&#x27; 2.lower(),upper() 小写大写转换12345&gt;&gt;&gt; str2 = &#x27;My nAme is tonY!&#x27;&gt;&gt;&gt; str2.lower()&#x27;my name is tony!&#x27;&gt;&gt;&gt; str2.upper()&#x27;MY NAME IS TONY!&#x27; 3.startswith,endswith12345678910111213&gt;&gt;&gt; str3 = &#x27;tony jam&#x27;# startswith()判断字符串是否以括号内指定的字符开头，结果为布尔值true或False&gt;&gt;&gt; str3.startswith(&#x27;t&#x27;)True&gt;&gt;&gt; str3.startswith(&#x27;j&#x27;)False# endswith()判断字符串是否以括号内指定的字符开头，结果为布尔值true或False&gt;&gt;&gt; str3.endswith(&#x27;jam&#x27;)True&gt;&gt;&gt; str3.endswith(&#x27;tony&#x27;)False 4.格式化输出之format之前我们使用%s来做字符串的格式化输出，在传值时，必须严格按照位置与%s一一对应，而字符串的内置方法format则提供了一种不依赖位置的传值方式 案例： 12345678# format括号内在传参数时完全可以打乱顺序，但仍然能指名道姓地为指定的参数传值，name=&#x27;tony&#x27;就是传给&#123;name&#125;&gt;&gt;&gt; str4 = &#x27;my name is &#123;name&#125;,my age is &#123;age&#125;!&#x27;.format(age=18,name=&#x27;egon&#x27;)&gt;&gt;&gt; str4&#x27;my name is egon,my age is 18!&#x27;&gt;&gt;&gt; str4 = &#x27;my name is &#123;name&#125;&#123;name&#125;&#123;name&#125;,my age is &#123;name&#125;!&#x27;.format(name = &#x27;tony&#x27;,age=18)&gt;&gt;&gt; str4&#x27;my name is tonytonytony,my age is tony!&#x27; format的其他使用方式（了解） 12345678910111213# 类似于%s的用法，传入的值会按照位置与&#123;&#125;一一对应&gt;&gt;&gt; str4 = &#x27;my name is &#123;&#125;,my age is&#123;&#125;!&#x27;.format(&#x27;tony&#x27;,18)&gt;&gt;&gt; str4&#x27;my name is tony,my age is18!&#x27;# 把format传入的多个值当作一个列表，然后用&#123;索引&#125;取值&gt;&gt;&gt; str4 = &#x27;my name is &#123;0&#125;,my age is&#123;1&#125;!&#x27;.format(&#x27;tony&#x27;,18)&gt;&gt;&gt; str4&#x27;my name is tony,my age is18!&#x27;&gt;&gt;&gt;&gt;&gt;&gt; str4 = &#x27;my name is &#123;1&#125;,my age is&#123;1&#125;!&#x27;.format(&#x27;tony&#x27;,18)&gt;&gt;&gt; str4&#x27;my name is 18,my age is18!&#x27; 5.split，rsplit12345678# split会按照从左到右的顺序对字符串进行切分，可以指定切割次数&gt;&gt;&gt; str5 = &#x27;C:/a/b/c/d.txt&#x27;&gt;&gt;&gt; str5.split(&#x27;/&#x27;,1)[&#x27;C:&#x27;, &#x27;a/b/c/d.txt&#x27;]# rsplit刚好与split相反，从右往左切割，可以指定切割次数&gt;&gt;&gt; str5.rsplit(&#x27;/&#x27;,1)[&#x27;C:/a/b/c&#x27;, &#x27;d.txt&#x27;] 6.join12345# 从可迭代对象中取出多个字符串，然后按照指定的分隔符进行拼接，拼接的结果为字符串&gt;&gt;&gt; &#x27;%&#x27;.join(&#x27;hello&#x27;)&#x27;h%e%l%l%o&#x27;&gt;&gt;&gt; &#x27;|&#x27;.join([&#x27;tony&#x27;,&#x27;18&#x27;,&#x27;read&#x27;])&#x27;tony|18|read&#x27; 7.replace1234567891011# 用新的字符替换字符串中旧的字符&gt;&gt;&gt; str7 = &#x27;my name is tony,my age is 18!&#x27;&gt;&gt;&gt; str7 = str7.replace(&#x27;18&#x27;,&#x27;73&#x27;)&gt;&gt;&gt; str7&#x27;my name is tony,my age is 73!&#x27;# 可以指定修改的个数&gt;&gt;&gt; str7 = &#x27;my name is tony,my age is 18!&#x27;&gt;&gt;&gt; str7 = str7.replace(&#x27;my&#x27;,&#x27;MY&#x27;,1) # 只把第一个my改为MY&gt;&gt;&gt; str7&#x27;MY name is tony,my age is 18!&#x27; 8.isdigit12345678# 判断字符串是否时纯数字组成，返回结果为True或False&gt;&gt;&gt; str8 = &#x27;5201314&#x27;&gt;&gt;&gt; str8.isdigit()True&gt;&gt;&gt;&gt;&gt;&gt; str8 = &#x27;123g123&#x27;&gt;&gt;&gt; str8.isdigit()False 了解操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120# 1.find，rfind（略），index，rindex（略），count# find：从指定范围内查找子字符串的起始索引，找得到则返回数字1，找不到则返回-1&gt;&gt;&gt; msg = &#x27;tony say hello&#x27;&gt;&gt;&gt; msg.find(&#x27;o&#x27;,1,3) # 在索引为1和2（顾头不顾尾）的字符中查找字符o的索引1# index:同find，但在找不到时会报错&gt;&gt;&gt; msg.index(&#x27;e&#x27;,2,4) # 报错ValueError# count：统计字符串在大字符串中出现的次数&gt;&gt;&gt; msg=&#x27;hello everyone&#x27;&gt;&gt;&gt; msg.count(&#x27;e&#x27;) # 统计字符串e出现的次数4&gt;&gt;&gt; msg.count(&#x27;e&#x27;,1,6) # 字符串e在索引1-5范围内出现的次数1# 2.center，ljust，rjust，zfill&gt;&gt;&gt; name = &#x27;tony&#x27;&gt;&gt;&gt; name.center(30,&#x27;-&#x27;) # 总宽度为30，字符串居中显示，不够用-填充&#x27;-------------tony-------------&#x27;&gt;&gt;&gt; name.ljust(30,&#x27;*&#x27;) # 总宽度为30，字符串左对齐显示，不够用*填充&#x27;tony**************************&#x27;&gt;&gt;&gt; name.rjust(30,&#x27;*&#x27;) # 总宽度为30，字符串右对齐显示，不够用*填充&#x27;**************************tony&#x27;&gt;&gt;&gt; name.zfill(50) # 总宽度为50，字符串右对齐显示，不够用0填充...z代表zero&#x27;0000000000000000000000000000000000000000000000tony&#x27;# 3.expandtabs&gt;&gt;&gt; name = &#x27;hello\\tworld&#x27; # \\t代表制表符（tab键）&gt;&gt;&gt; print(name)hello world&gt;&gt;&gt; name.expandtabs(1) # 修改\\t制表符代表的空格数&#x27;hello world&#x27;# 4.captalize，swapcase，title# capitalize：首字母大写&gt;&gt;&gt; message = &#x27;hello everyoen nice to meet you!&#x27;&gt;&gt;&gt; message.capitalize()&#x27;Hello everyoen nice to meet you!&#x27;# swapcase：大小写翻转&gt;&gt;&gt; message1 = &#x27;Hi girl,I want to make friends with you!&#x27;&gt;&gt;&gt; message1.swapcase()&#x27;hI GIRL,i WANT TO MAKE FRIENDS WITH YOU!&#x27;# title：每个首字母大写&gt;&gt;&gt; msg = &#x27;dear my friend,i miss you so much&#x27;&gt;&gt;&gt; msg.title()&#x27;Dear My Friend,I Miss You So Much&#x27;# is数字系列# 在python3中&gt;&gt;&gt; num1 = b&#x27;4&#x27; # bytes&gt;&gt;&gt; num2 = u&#x27;4&#x27; # unicode,python3中无需加u就是unicode&gt;&gt;&gt; num3 = &#x27;四&#x27; # 中文数字&gt;&gt;&gt; num4 = &#x27;IV&#x27; # 罗马数字# isdigit：bytes，unicode&gt;&gt;&gt; num1.isdigit()True&gt;&gt;&gt; num2.isdigit()True&gt;&gt;&gt; num3.isdigit()False&gt;&gt;&gt; num4.isdigit()False# isdecimal:unicode(bytes类型无isdecimal方法)&gt;&gt;&gt; num2.isdecimal()True&gt;&gt;&gt; num3.isdecimal()False&gt;&gt;&gt; num4.isdecimal()False# isnumberic:unicode,中文数字，罗马数字(bytes类型无isnumberic方法)&gt;&gt;&gt; num2.isnumberic()True&gt;&gt;&gt; num3.isnumberic()True&gt;&gt;&gt; num4.isnumberic()True# 三者不能判断浮点数&gt;&gt;&gt; num5 = &#x27;4.3&#x27;&gt;&gt;&gt; num5.isdigit()False&gt;&gt;&gt; num5.isdecimal()False&gt;&gt;&gt; num5,isnumberic()False&#x27;&#x27;&#x27;# 总结： 最常用的是isdigit，可以判断bytes和uncode类型，这也是最常用的数字应用场景 如果要判断中文数字或罗马数字，则需要用到isnumberic&#x27;&#x27;&#x27;# 6.is其他&gt;&gt;&gt; name = &#x27;tony123&#x27;&gt;&gt;&gt; name.isalnum() # 字符串中既可以包含数字也可以包含字母True&gt;&gt;&gt; name.isalpha() # 字符串中只包含字母False&gt;&gt;&gt; name.islower() # 字符串是否是纯小写True&gt;&gt;&gt; name.isupper() # 字符串是否是纯大写False&gt;&gt;&gt; name.isspace() # 字符串是否全是空格False&gt;&gt;&gt; name.istitle() # 字符串中的单词首字母是否都是大写False&gt;&gt;&gt; 三、列表定义12# 定义：在[]内，用逗号分隔开多个任意数据类型的值l1 = [1, &#x27;a&#x27;, [1, 2]] # 本质：l1 = list[1, &#x27;a&#x27;, [1, 2]] 类型转换1234567891011# 但凡能被for循环遍历的数据类型都可以传给list()转换成列表类型，list()会跟for循环一遍历出数据类型中包含的每一个元素然后放到列表中&gt;&gt;&gt; list(&#x27;wdad&#x27;)[&#x27;w&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; list([1,2,3])[1, 2, 3]&gt;&gt;&gt; list(&#123;&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:18&#125;)[&#x27;name&#x27;, &#x27;age&#x27;]&gt;&gt;&gt; list((1,2,3))[1, 2, 3]&gt;&gt;&gt; list(&#123;1,2,3,4&#125;)[1, 2, 3, 4] 使用优先掌握的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# 1.按索引存取值(正向取值+反向取值)：既可存也可取# 正向取（从左往右）&gt;&gt;&gt; my_friends = [&#x27;tony&#x27;,&#x27;json&#x27;,&#x27;tom&#x27;,4,5]&gt;&gt;&gt; my_friends[0]&#x27;tony&#x27;# 反向取（负号表示从右往左）&gt;&gt;&gt; my_friends[-1]5# 对于list来说，既可以按照索引取值，又可以按照索引修改指定位置的值，但是如果索引不存在就会报错&gt;&gt;&gt; my_friends = [&#x27;tony&#x27;,&#x27;jack&#x27;,&#x27;tom&#x27;,4,5]&gt;&gt;&gt; my_friends[1]=&#x27;martthow&#x27;&gt;&gt;&gt; my_friends[&#x27;tony&#x27;, &#x27;martthow&#x27;, &#x27;tom&#x27;, 4, 5]# 2.切片（顾头不顾尾，步长）&gt;&gt;&gt; my_friends[0:4] # 取出索引0-3的元素[&#x27;tony&#x27;, &#x27;martthow&#x27;, &#x27;tom&#x27;, 4]&gt;&gt;&gt; my_friends[0:4:2] # 第三个参数2代表步长，会从0开始，每次累加一个2即可，所以会取出索引0、2的元素[&#x27;tony&#x27;, &#x27;tom&#x27;]# 长度&gt;&gt;&gt; len(my_friends)5# 成员运算in和not in&gt;&gt;&gt; &#x27;tony&#x27; in my_friendsTrue&gt;&gt;&gt; &#x27;xxx&#x27; not in my_friendsTrue# 3.添加# append()：列表尾部追加元素&gt;&gt;&gt; l1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]&gt;&gt;&gt; l1.append(&#x27;d&#x27;)&gt;&gt;&gt; l1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]# extend()一次性在列表尾部添加多个元素&gt;&gt;&gt; l1.extend([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;])&gt;&gt;&gt; l1[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]# insert()在指定位置插入元素&gt;&gt;&gt; l1.insert(0,&#x27;first&#x27;) # 0表示按索引位置插值&gt;&gt;&gt; l1[&#x27;first&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]# 4.删除# del&gt;&gt;&gt; l=[11,22,33,44]&gt;&gt;&gt; del l[2]&gt;&gt;&gt; l[11, 22, 44]# pop():默认删除列表最后一个元素，并将删除的值返回，括号内可以通过加索引值来指定删除元素&gt;&gt;&gt; l = [11,22,33,22,44]&gt;&gt;&gt; res = l.pop()&gt;&gt;&gt; res44&gt;&gt;&gt; res = l.pop(1)&gt;&gt;&gt; res22# remove()括号内指名道姓表示要删除哪个元素，没有返回值&gt;&gt;&gt; l = [11,22,33,44]&gt;&gt;&gt; res = l.remove(22) # 从左往右查找第一个括号内需要删除的元素&gt;&gt;&gt; print(res)None# 5.排序# reverse()颠倒列表内元素顺序&gt;&gt;&gt; l=[11,22,33,44]&gt;&gt;&gt; l.reverse()&gt;&gt;&gt; l[44, 33, 22, 11]# sort()给列表内所有元素排序# 排序时列表元素之间必须是相同数据类型，不可混搭，否则报错&gt;&gt;&gt; l=[11,22,3,42,55]&gt;&gt;&gt; l.sort()&gt;&gt;&gt; l[3, 11, 22, 42, 55] # 默认从小到大排序&gt;&gt;&gt; l = [11,22,3,43,7,55]&gt;&gt;&gt; l.sort(reverse=True) # reverse用来指定是否颠倒排序，默认为False&gt;&gt;&gt; l[55, 43, 22, 11, 7, 3]# 6.了解知识# 我们常用的数字类型直接比大小，但其实，字符串、列表等都可以比较大小，原理相同：都是依次比较对应位置的元素的大小，如果分出大小，则无需比较下一个元素，比如&gt;&gt;&gt; l1=[1,2,3]&gt;&gt;&gt; l2=[2,]&gt;&gt;&gt; l2&gt;l1 True字符之间的大小取决于它们在ASCII表中的先后顺序，越往后越大&gt;&gt;&gt; s1=&#x27;abc&#x27;&gt;&gt;&gt; s2=&#x27;az&#x27;&gt;&gt;&gt; s2&gt;s1 # s1与s2的第一个字符没有分出胜负，但第二个字符&#x27;z&#x27;&gt;&#x27;a&#x27;,所以s2&gt;s1成立True# 所以我们也可以对下面这个列表排序&gt;&gt;&gt; l = [&#x27;A&#x27;,&#x27;z&#x27;,&#x27;adjk&#x27;,&#x27;hello&#x27;,&#x27;hea&#x27;]&gt;&gt;&gt; l.sort()&gt;&gt;&gt; l[&#x27;A&#x27;, &#x27;adjk&#x27;, &#x27;hea&#x27;, &#x27;hello&#x27;, &#x27;z&#x27;]# 7.循环# 循环遍历my_friends列表里面的值&gt;&gt;&gt; for line in my_friends:... print(line)···&#x27;tony&#x27;&#x27;jack&#x27;&#x27;jason&#x27;45 了解操作123456789&gt;&gt;&gt; l=[1,2,3,4,5,6]&gt;&gt;&gt; l[0:3:1][1, 2, 3] # 正向步长&gt;&gt;&gt; l[2::-1][3, 2, 1] # 反向步长# 通过索引取值实现列表反转&gt;&gt;&gt; l[::-1][6, 5, 4, 3, 2, 1] 队列堆栈的实现12345678910111213141516171819202122232425262728293031队列 先进先出堆栈 先进后出 需求:使用列表模拟出上述两个概念的特征 # 队列 先进先出&#x27;&#x27;&#x27;先进去的元素 先出来&#x27;&#x27;&#x27;# l = []# # 添加元素# l.append(111) # l = [111,]# l.append(222) # l = [111, 222]# l.append(333) # l = [111, 222, 333]# # 取出元素# print(l.pop(0)) # 111 l = [222, 333]# print(l.pop(0)) # 222 l = [333,]# print(l.pop(0)) # 333 l = []# 堆栈 先进后出&#x27;&#x27;&#x27;先进去元素 后出来&#x27;&#x27;&#x27;l = []# 添加元素l.append(111)l.append(222)l.append(333) # l = [111, 222, 333]# 取值print(l.pop()) # 333 l = [111, 222]print(l.pop()) # 222 l = [111,]print(l.pop()) # 111 l = [] 四、元组作用元组与列表类似，也是可以存多个任意类型的元素，不同之处在于元组的元素不能修改，即元组下相当于不可变的列表，用于记录多个固定不允许修改的值，单纯用于取 定义方式1234# 在()内用都好分隔开多个任意类型的值&gt;&gt;&gt; countries = (&quot;中国&quot;，&quot;美国&quot;，&quot;英国&quot;) # 本质：countries = tuple(&quot;中国&quot;，&quot;美国&quot;，&quot;英国&quot;)# 强调：如果元组内只有一个值，则必须加一个逗号，否则()就只是包含的意思而非定义元组&gt;&gt;&gt; countyies = (&#x27;中国&#x27;,) # 本质：countyies = tuple(&#x27;中国&#x27;) 类型转换123456789101112# 但凡能够被for循环遍历的数据类型都可以传给tuple()转换成元Zu类型&gt;&gt;&gt; tuple(&#x27;wdad&#x27;)(&#x27;w&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;d&#x27;)&gt;&gt;&gt; tuple([1,2,3])(1, 2, 3)&gt;&gt;&gt; tuple(&#123;&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:&#x27;18&#x27;&#125;)(&#x27;name&#x27;, &#x27;age&#x27;)&gt;&gt;&gt; tuple((1,2,3))(1, 2, 3)&gt;&gt;&gt; tuple(&#123;1,2,3,4&#125;)(1, 2, 3, 4)# tuple()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到元组中 使用12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; tuple = (1, &#x27;hhaha&#x27;, 15000.00, 11, 22, 33)# 按索引取值(正向取、反向取)：只能取不能改，否则报错&gt;&gt;&gt; tuple[0]1&gt;&gt;&gt; tuple[-2]22&gt;&gt;&gt; tuple[0] = &#x27;hehe&#x27;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;tuple&#x27; object does not support item assignment # 切片(顾头不顾尾，步长) &gt;&gt;&gt; tuple1[0:6:2]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#x27;tuple1&#x27; is not defined&gt;&gt;&gt; tuple[0:6:2](1, 15000.0, 22)# 长度&gt;&gt;&gt; len(tuple)6# 成员运算&gt;&gt;&gt; &#x27;hhaha&#x27; in tupleTrue&gt;&gt;&gt; &#x27;hhaha&#x27; not in tupleFalse# 循环&gt;&gt;&gt; for line in tuple:... print(line)...1hhaha15000.0112233 五、字典定义方式1234# 定义：在&#123;&#125;内用都好隔开多个元素，每一个元素都是key:value的形式，其中value可以是任意类型，而key则必须是不可变类型，通常key应该是str类型，因为str类型会对value有描述性的功能info = &#123;&#x27;name&#x27;:&#x27;tony&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125; # 本质info = dict(&#123;...&#125;)# 也可以这样定义字典info = dict(name=&#x27;tony&#x27;,age=18,&#x27;sex&#x27;=&#x27;male&#x27;) # info = &#123;&#x27;name&#x27;:&#x27;tony&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125; 类型转换123456789# 转换1：&gt;&gt;&gt; info = dict([[&#x27;name&#x27;,&#x27;tony&#x27;],(&#x27;age&#x27;,18)])&gt;&gt;&gt; info&#123;&#x27;name&#x27;: &#x27;tony&#x27;, &#x27;age&#x27;: 18&#125;# 转换2：fromkey会从元组中取出每个值当作key，然后与None组成key：value放到字典中&gt;&gt;&gt; &#123;&#125;.fromkeys((&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;),None)&#123;&#x27;name&#x27;: None, &#x27;age&#x27;: None, &#x27;sex&#x27;: None&#125; 使用优先掌握的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 1.按keycunqu值：可存可取# 1.1取&gt;&gt;&gt; dic = &#123;... &#x27;name&#x27;:&#x27;xxx&#x27;,... &#x27;age&#x27;:18,... &#x27;hobbies&#x27;:[&#x27;play game&#x27;,&#x27;basketball&#x27;]... &#125;&gt;&gt;&gt; dic[&#x27;name&#x27;]&#x27;xxx&#x27;&gt;&gt;&gt; dic[&#x27;hobbies&#x27;][1]&#x27;basketball&#x27;# 1.2 对于赋值操作，如果key原先不存在于字典，则会新增key:value&gt;&gt;&gt; dic[&#x27;gender&#x27;]=&#x27;male&#x27;&gt;&gt;&gt; dic&#123;&#x27;name&#x27;: &#x27;xxx&#x27;, &#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;], &#x27;gender&#x27;: &#x27;male&#x27;&#125;# 1.3 对于赋值操作，如果key原先存在于字典，则会修改对应value的值&gt;&gt;&gt; dic[&#x27;name&#x27;]=&#x27;tony&#x27;&gt;&gt;&gt; dic&#123;&#x27;name&#x27;: &#x27;tony&#x27;, &#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;], &#x27;gender&#x27;: &#x27;male&#x27;&#125;# 2、长度len&gt;&gt;&gt; len(dic) 3# 3、成员运算in和not in&gt;&gt;&gt; &#x27;name&#x27; in dic # 判断某个值是否是字典的keyTrue# 4、删除&gt;&gt;&gt; dic.pop(&#x27;name&#x27;) # 通过指定字典的key来删除字典的键值对&gt;&gt;&gt; dic&#123;&#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;]&#125;# 5、键keys()，值values()，键值对items()&gt;&gt;&gt; dic = &#123;&#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;], &#x27;name&#x27;: &#x27;xxx&#x27;&#125;# 获取字典所有的key&gt;&gt;&gt; dic.keys() dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;hobbies&#x27;])# 获取字典所有的value&gt;&gt;&gt; dic.values()dict_values([&#x27;xxx&#x27;, 18, [&#x27;play game&#x27;, &#x27;basketball&#x27;]])# 获取字典所有的键值对&gt;&gt;&gt; dic.items()dict_items([(&#x27;name&#x27;, &#x27;xxx&#x27;), (&#x27;age&#x27;, 18), (&#x27;hobbies&#x27;, [&#x27;play game&#x27;, &#x27;basketball&#x27;])])# 6、循环# 6.1 默认遍历的是字典的key&gt;&gt;&gt; for key in dic:... print(key)... agehobbiesname# 6.2 只遍历key&gt;&gt;&gt; for key in dic.keys():... print(key)... agehobbiesname# 6.3 只遍历value&gt;&gt;&gt; for key in dic.values():... print(key)... 18[&#x27;play game&#x27;, &#x27;basketball&#x27;]xxx# 6.4 遍历key与value&gt;&gt;&gt; for key in dic.items():... print(key)... (&#x27;age&#x27;, 18)(&#x27;hobbies&#x27;, [&#x27;play game&#x27;, &#x27;basketball&#x27;])(&#x27;name&#x27;, &#x27;xxx&#x27;) 需要掌握的操作1.get()12345678910&gt;&gt;&gt; dic= &#123;&#x27;k1&#x27;:&#x27;jason&#x27;,&#x27;k2&#x27;:&#x27;Tony&#x27;,&#x27;k3&#x27;:&#x27;JY&#x27;&#125;&gt;&gt;&gt; dic.get(&#x27;k1&#x27;)&#x27;jason&#x27; # key存在，则获取key对应的value值&gt;&gt;&gt; res=dic.get(&#x27;xxx&#x27;) # key不存在，不会报错而是默认返回None&gt;&gt;&gt; print(res)None &gt;&gt;&gt; res=dic.get(&#x27;xxx&#x27;,666) # key不存在时，可以设置默认返回的值&gt;&gt;&gt; print(res)666 # ps:字典取值建议使用get方法 2.pop()123456&gt;&gt;&gt; dic= &#123;&#x27;k1&#x27;:&#x27;jason&#x27;,&#x27;k2&#x27;:&#x27;Tony&#x27;,&#x27;k3&#x27;:&#x27;JY&#x27;&#125;&gt;&gt;&gt; v = dic.pop(&#x27;k2&#x27;) # 删除指定的key对应的键值对,并返回值&gt;&gt;&gt; dic&#123;&#x27;k1&#x27;: &#x27;jason&#x27;, &#x27;kk2&#x27;: &#x27;JY&#x27;&#125;&gt;&gt;&gt; v&#x27;Tony&#x27; 3.popitem()123456&gt;&gt;&gt; dic= &#123;&#x27;k1&#x27;:&#x27;jason&#x27;,&#x27;k2&#x27;:&#x27;Tony&#x27;,&#x27;k3&#x27;:&#x27;JY&#x27;&#125;&gt;&gt;&gt; item = dic.popitem() # 随机删除一组键值对，并将删除的键值放到元组返回&gt;&gt;&gt; dic&#123;&#x27;k3&#x27;: &#x27;JY&#x27;, &#x27;k2&#x27;: &#x27;Tony&#x27;&#125;&gt;&gt;&gt; item(&#x27;k1&#x27;, &#x27;jason&#x27;) 4.update()12345# 用新字典更新旧字典，有则修改，无则添加&gt;&gt;&gt; dic= &#123;&#x27;k1&#x27;:&#x27;jason&#x27;,&#x27;k2&#x27;:&#x27;Tony&#x27;,&#x27;k3&#x27;:&#x27;JY&#x27;&#125;&gt;&gt;&gt; dic.update(&#123;&#x27;k1&#x27;:&#x27;JN&#x27;,&#x27;k4&#x27;:&#x27;xxx&#x27;&#125;)&gt;&gt;&gt; dic&#123;&#x27;k1&#x27;: &#x27;JN&#x27;, &#x27;k3&#x27;: &#x27;JY&#x27;, &#x27;k2&#x27;: &#x27;Tony&#x27;, &#x27;k4&#x27;: &#x27;xxx&#x27;&#125; 5.fromkeys()123&gt;&gt;&gt; dic = dict.fromkeys([&#x27;k1&#x27;,&#x27;k2&#x27;,&#x27;k3&#x27;],[])&gt;&gt;&gt; dic&#123;&#x27;k1&#x27;: [], &#x27;k2&#x27;: [], &#x27;k3&#x27;: []&#125; 6.setdefault()123456789101112131415# key不存在则新增键值对，并将新增的value返回&gt;&gt;&gt; dic=&#123;&#x27;k1&#x27;:111,&#x27;k2&#x27;:222&#125;&gt;&gt;&gt; res=dic.setdefault(&#x27;k3&#x27;,333)&gt;&gt;&gt; res333&gt;&gt;&gt; dic # 字典中新增了键值对&#123;&#x27;k1&#x27;: 111, &#x27;k3&#x27;: 333, &#x27;k2&#x27;: 222&#125;# key存在则不做任何修改，并返回已存在key对应的value值&gt;&gt;&gt; dic = &#123;&#x27;k1&#x27;:111,&#x27;k2&#x27;:222&#125;&gt;&gt;&gt; res = dic.setdefault(&#x27;k1&#x27;,666)&gt;&gt;&gt; res111&gt;&gt;&gt; dic&#123;&#x27;k1&#x27;: 111, &#x27;k2&#x27;: 222&#125; 六、集合作用集合、list、tuple、dict一样都可以存放多个值，但是主要用于：去重、关系运算 定义定义：在{}内用逗号分隔开多个元素，集合具备以下三个特点： 每个元素必须是不可变类型 集合内没有重复的元素 集合内元素无序 1234567s = &#123;1,2,3,4&#125; # 本质 s = set(&#123;1,2,3,4&#125;)# 注意1：列表类型是索引对应值，字典是key对应值，均可以取得单个指定的值，而集合类型既没有索引也没有key与值对应，所以无法取得单个的值，而且对于集合来说，主要用于去重与关系运算，根本没有取出单个指定值这种需求# 注意2：&#123;&#125;既可以用于定义dict，也可以用于定义集合，但是字典内的元素必须是key:value的格式，现在我们想定义一个空字典和空集合，该如何准确去定义两者？d = &#123;&#125; # 默认是空字典s = set() # 这才是定义空集合 类型转换1234567# 但凡能被for循环的遍历的数据类型（强调：遍历出的每一个值都必须为不可变类型）都可以传给set()转换成集合类型&gt;&gt;&gt; s = set([1,2,3,4])&gt;&gt;&gt; s1 = set((1,2,3,4))&gt;&gt;&gt; s2 = set(&#123;&#x27;name&#x27;:&#x27;jason&#x27;,&#125;)&gt;&gt;&gt; s3 = set(&#x27;egon&#x27;)&gt;&gt;&gt; s,s1,s2,s3(&#123;1, 2, 3, 4&#125;, &#123;1, 2, 3, 4&#125;, &#123;&#x27;name&#x27;&#125;, &#123;&#x27;n&#x27;, &#x27;e&#x27;, &#x27;o&#x27;, &#x27;g&#x27;&#125;) 使用关系运算我们定义两个集合friends与friends2来分别存放两个人的好友名字，然后以这两个集合为例讲解集合的关系运算 12&gt;&gt;&gt; friends1 = &#123;&quot;zero&quot;,&quot;kevin&quot;,&quot;jason&quot;,&quot;egon&quot;&#125; # 用户1的好友们 &gt;&gt;&gt; friends2 = &#123;&quot;Jy&quot;,&quot;ricky&quot;,&quot;jason&quot;,&quot;egon&quot;&#125; # 用户2的好友们 两个集合的关系如下图所示 12345678910111213141516171819202122232425262728293031323334353637383940# 1.合集/并集(|)：求两个用户所有的好友（重复好友只留一个）&gt;&gt;&gt; friends1 | friends2&#123;&#x27;kevin&#x27;, &#x27;ricky&#x27;, &#x27;zero&#x27;, &#x27;jason&#x27;, &#x27;Jy&#x27;, &#x27;egon&#x27;&#125;# 2.交集(&amp;)：求两个用户的共同好友&gt;&gt;&gt; friends1 &amp; friends2&#123;&#x27;jason&#x27;, &#x27;egon&#x27;&#125;# 3.差集(-)：&gt;&gt;&gt; friends1 - friends2 # 求用户1独有的好友&#123;&#x27;kevin&#x27;, &#x27;zero&#x27;&#125;&gt;&gt;&gt; friends2 - friends1 # 求用户2独有的好友&#123;&#x27;ricky&#x27;, &#x27;Jy&#x27;&#125;# 4.对称差集(^) # 求两个用户独有的好友们（即去掉共有的好友）&gt;&gt;&gt; friends1 ^ friends2&#123;&#x27;kevin&#x27;, &#x27;zero&#x27;, &#x27;ricky&#x27;, &#x27;Jy&#x27;&#125;# 5.值是否相等(==)&gt;&gt;&gt; friends1 == friends2False# 6.父集：一个集合是否包含另外一个集合# 6.1 包含则返回True&gt;&gt;&gt; &#123;1,2,3&#125; &gt; &#123;1,2&#125;True&gt;&gt;&gt; &#123;1,2,3&#125; &gt;= &#123;1,2&#125;True# 6.2 不存在包含关系，则返回False&gt;&gt;&gt; &#123;1,2,3&#125; &gt; &#123;1,3,4,5&#125;False&gt;&gt;&gt; &#123;1,2,3&#125; &gt;= &#123;1,3,4,5&#125;False# 7.子集&gt;&gt;&gt; &#123;1,2&#125; &lt; &#123;1,2,3&#125;True&gt;&gt;&gt; &#123;1,2&#125; &lt;= &#123;1,2,3&#125;True 去重集合去重复有局限性 12345678910111213141516171819202122232425262728293031323334# 1. 只能针对不可变类型# 2. 集合本身是无序的，去重之后无法保留原来的顺序# 实例如下&gt;&gt;&gt; l=[&#x27;a&#x27;,&#x27;b&#x27;,1,&#x27;a&#x27;,&#x27;a&#x27;]&gt;&gt;&gt; s=set(l)&gt;&gt;&gt; s # 将列表转成了集合&#123;&#x27;b&#x27;, &#x27;a&#x27;, 1&#125;&gt;&gt;&gt; l_new=list(s) # 再将集合转回列表&gt;&gt;&gt; l_new[&#x27;b&#x27;, &#x27;a&#x27;, 1] # 去除了重复，但是打乱了顺序# 针对不可变类型，并且保证顺序则需要我们自己写代码实现，例如l=[ &#123;&#x27;name&#x27;:&#x27;lili&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;jack&#x27;,&#x27;age&#x27;:73,&#x27;sex&#x27;:&#x27;male&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;tom&#x27;,&#x27;age&#x27;:20,&#x27;sex&#x27;:&#x27;female&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;lili&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;, &#123;&#x27;name&#x27;:&#x27;lili&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;,]new_l=[]for dic in l: if dic not in new_l: new_l.append(dic)print(new_l)# 结果：既去除了重复，又保证了顺序，而且是针对不可变类型的去重[ &#123;&#x27;age&#x27;: 18, &#x27;sex&#x27;: &#x27;male&#x27;, &#x27;name&#x27;: &#x27;lili&#x27;&#125;, &#123;&#x27;age&#x27;: 73, &#x27;sex&#x27;: &#x27;male&#x27;, &#x27;name&#x27;: &#x27;jack&#x27;&#125;, &#123;&#x27;age&#x27;: 20, &#x27;sex&#x27;: &#x27;female&#x27;, &#x27;name&#x27;: &#x27;tom&#x27;&#125;] 其他操作12345678910111213141516# 1.长度&gt;&gt;&gt; s=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;&gt;&gt;&gt; len(s)3# 2.成员运算&gt;&gt;&gt; &#x27;c&#x27; in sTrue# 3.循环&gt;&gt;&gt; for item in s:... print(item)... cab 父级子级123456789# 父集 子集&quot;&quot;&quot;父级:A包含B 那么A就是B的父级子级:A包含B 那么B就是A的子级&quot;&quot;&quot;s1 = &#123;1,2,3,4,5&#125;s2 = &#123;1,2,3&#125;print(s1 &gt; s2) # Trueprint(s1 &lt; s2) # False 练习123456789101112131415161718&quot;&quot;&quot;一.关系运算 有如下两个集合，pythons是报名python课程的学员名字集合，linuxs是报名linux课程的学员名字集合 pythons=&#123;&#x27;jason&#x27;,&#x27;egon&#x27;,&#x27;kevin&#x27;,&#x27;ricky&#x27;,&#x27;gangdan&#x27;,&#x27;biubiu&#x27;&#125; linuxs=&#123;&#x27;kermit&#x27;,&#x27;tony&#x27;,&#x27;gangdan&#x27;&#125; 1. 求出即报名python又报名linux课程的学员名字集合 2. 求出所有报名的学生名字集合 3. 求出只报名python课程的学员名字 4. 求出没有同时这两门课程的学员名字集合&quot;&quot;&quot;# 求出即报名python又报名linux课程的学员名字集合&gt;&gt;&gt; pythons &amp; linuxs# 求出所有报名的学生名字集合&gt;&gt;&gt; pythons | linuxs# 求出只报名python课程的学员名字&gt;&gt;&gt; pythons - linuxs# 求出没有同时报这两门课程的学员名字集合&gt;&gt;&gt; pythons ^ linuxs 可变类型与不可变类型可变数据类型：值发生改变时，内存地址不变，即id不变，证明在改变原值 不可变类型：值发生改变时，内存地址也发生改变，即id也变，证明是没有在改变原值，是产生了新的值","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"7、流程控制","slug":"07、python语法入门--流程控制","date":"2018-05-13T06:04:06.000Z","updated":"2022-05-13T12:27:56.610Z","comments":true,"path":"2018/05/13/07、python语法入门--流程控制/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/07%E3%80%81python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8--%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"分支结构 什么是分支结构 为什么要用分支结构 如何使用分支结构 if语法 if应用案例 循环结构 什么是循环结构 为什么要用循环结构 如何使用循环结构 while循环语法 while循环应用案例 for循环语法 for循环应用案例 分支结构什么是分支结构1# 分支结构就是根据条件判断的真假去执行不同分支对应的子代码 为什么要用分支结构12# 人类某些时候需要根据条件老决定做什么事情，比如：如果今天下雨，就带伞# 所以程序中必须有相应的机制来控制计算机具备人的这种判断能力 如何使用分支结构if语法用if语法实现分支结构，完整语法如下 123456789101112131415161718if 条件1: # 如果条件1成立，就依次运行代码1、代码2 代码1 代码2elif 条件2: # 如果条件2成立，就依次运行代码3、代码4 代码3 代码4elif 条件3: # 如果条件3成立，就依次运行代码5、代码6 代码5 代码6else: # 其他情况，就依次运行代码7、代码8 代码7 代码8# 注意：# 1、python用相同缩进（4个空格标识一个缩进）来标识一组代码块，同一组代码会自上而下依次运行# 2、条件可以是任意表达式，但执行结果必须是布尔类型 # 在if判断中所有的数据类型也都会转换成布尔类型 # None、0、空（空字符串、空列表、空字典等）三种情况下转换成的布尔值为False，其余均为True if应用案例案例1： 如果：女人年龄&gt;30,叫阿姨 123age_of_girl = 31if age_of_girl &gt; 30: print(&#x27;阿姨好&#x27;) 案例2： 如果：女人年龄&gt;30,叫阿姨，否则：叫小姐 12345age_of_girl = 18if age_of_girl &gt;30: print(&#x27;阿姨好&#x27;)else: print(&#x27;小姐好&#x27;) 案例3： 如果：女人的年龄&gt;&#x3D;18并且&lt;22岁并且身高&gt;170并且体重&lt;100并且是漂亮的，那么：表白，否则：叫阿姨** 12345678age_of_girl = 18height = 171weight = 99is_pretty = Trueif age_of_girl &gt;=18 and age_of_girl &lt; 22 and weight &lt; 100 and height &gt; 170: print(&#x27;表白&#x27;)else: print(&#x27;阿姨好&#x27;) 案例4： 如果：成绩&gt;&#x3D;90，那么：优秀 如果：成绩&gt;&#x3D;80且&lt;&#x3D;90那么：良好 如果：成绩&gt;&#x3D;70且&lt;&#x3D;80，那么：普通 其他情况：很差 123456789score = int(input(&#x27;请输入你的分数&gt;&gt;&gt;:&#x27;))if score &gt;= 90: print(&#x27;优秀&#x27;)elif score &gt;= 80: print(&#x27;良好&#x27;)elif score &gt;=70: print(&#x27;普通&#x27;)else: print(&#x27;很差&#x27;) 案例5： if嵌套 在表白的基础上继续 如果表白成功，那么，在一起 否则：打印。。。 123456789101112age_of_girl = 18height = 171weight = 99is_pretty = Truesuccess = Falseif age_of_girl &gt;=18 and age_of_girl &lt; 22 and weight &lt; 100 and height &gt; 170: if success: print(&#x27;表白&#x27;) else: print(&#x27;什么爱情不爱情的，爱个pi&#x27;)else: print(&#x27;阿姨好&#x27;) 练习练习1：登录功能 1234567name = input(&#x27;请输入用户名：&#x27;).strip()password = input(&#x27;请输入密码：&#x27;).strip()if name == &#x27;egon&#x27; and password == &#x27;123&#x27;: print(&#x27;登陆成功&#x27;)else: print(&#x27;用户名或密码错误&#x27;） 练习2：根据用户输入其权限 123456789name = input(&#x27;请输入用户名字&#x27;)if name == &#x27;cx&#x27;: print(&#x27;超级管理员&#x27;)elif name == &#x27;egon&#x27;: print(&#x27;普通管理员&#x27;)elif name == &#x27;json&#x27;: print(&#x27;业务管理员&#x27;)else: print(&#x27;普通用户&#x27;) 循环结构什么是循环结构1循环结构就是重复运行某段代码块 为什么要用循环结构12人某些时候需要重复做某件事情所以程序中必须有相应的机制来控制计算机具备人的这种循环做事的能力 如何使用循环结构while循环语法1python中有while和for两种循环机制，其中while循环称之为条件循环，语法如下 1234567while 条件: 代码1 代码2 代码3while运行的步骤：步骤1：如果条件为真，那么依次执行代码1、代码2、代码3步骤2：执行完毕后再次判断条件，如果条件为True则再次执行代码1、代码2、代码3，如果条件为False，则种植循环 while循环应用案例案例1： while循环的基本使用 用户认证程序 123456789101112# 用户认证程序的基本逻辑就是接收用户输入的用户名和密码然后与程序中存放的用户名和密码进行判断，判断成功则登陆成功，判断失败则输出，账号或密码错误username = &#x27;json&#x27;password = &#x27;123&#x27;count = 0while count &lt; 3: inpu_name = input(&#x27;请输入用户名：&#x27;) inpu_pwd = input(&#x27;请输入密码：&#x27;) if inpu_name == username and inpu_pwd == password: print(&#x27;登陆成功&#x27;) else: print(&quot;输入的用户名或密码错误！&quot;) count += 1 案例二：while+break的使用 使用了while循环后，代码确实精简多了，但问题是用户输入正确的用户名密码以后无法结束循环，那如何结束掉一个循环呢？这就需要用到break了！ 12345678910111213username = &quot;jason&quot;password = &quot;123&quot;# 记录错误验证的次数count = 0while count &lt; 3: inp_name = input(&quot;请输入用户名：&quot;) inp_pwd = input(&quot;请输入密码：&quot;) if inp_name == username and inp_pwd == password: print(&quot;登陆成功&quot;) break # 用于结束本层循环 else: print(&quot;输入的用户名或密码错误！&quot;) count += 1 案例三：while循环嵌套+break 如果while循环嵌套了很多层，要想退出每一层循环则需要在每一层循环都有一个break 1234567891011121314151617username = &quot;jason&quot;password = &quot;123&quot;count = 0while count &lt; 3: # 第一层循环 inp_name = input(&quot;请输入用户名：&quot;) inp_pwd = input(&quot;请输入密码：&quot;) if inp_name == username and inp_pwd == password: print(&quot;登陆成功&quot;) while True: # 第二层循环 cmd = input(&#x27;&gt;&gt;: &#x27;) if cmd == &#x27;quit&#x27;: break # 用于结束本层循环，即第二层循环 print(&#x27;run &lt;%s&gt;&#x27; % cmd) break # 用于结束本层循环，即第一层循环 else: print(&quot;输入的用户名或密码错误！&quot;) count += 1 案例四：while循环嵌套+tag的使用 针对嵌套多层的while循环，如果我们的目的很明确就是要在某一层直接退出所有层的循环，其实有一个窍门，就让所有while循环的条件都用同一个变量，该变量的初始值为True，一旦在某一层将该变量的值改成False，则所有层的循环都结束 123456789101112131415161718username = &quot;jason&quot;password = &quot;123&quot;count = 0tag = Truewhile tag: inp_name = input(&quot;请输入用户名：&quot;) inp_pwd = input(&quot;请输入密码：&quot;) if inp_name == username and inp_pwd == password: print(&quot;登陆成功&quot;) while tag: cmd = input(&#x27;&gt;&gt;: &#x27;) if cmd == &#x27;quit&#x27;: tag = False # tag变为False， 所有while循环的条件都变为False print(&#x27;run &lt;%s&gt;&#x27; % cmd) else: print(&quot;输入的用户名或密码错误！&quot;) count += 1 案例五：while+continue的使用 break代表结束本层循环，而continue则用于结束本次循环，直接进入下一次循环 1234567# 打印1到10之间，除7以外的所有数字number=11while number&gt;1: number -= 1 if number==7: continue # 结束掉本次循环，即本次循环continue之后的代码都不会运行了，而是直接进入下一次循环 print(number) 案例六：while+else的使用 在while循环的后面，我们可以跟else语句，当while 循环正常执行完并且中间没有被break 中止的话，就会执行else后面的语句，所以我们可以用else来验证，循环是否正常结束 12345678910111213141516count = 0while count &lt;= 5 : count += 1 print(&quot;Loop&quot;,count)else: print(&quot;循环正常执行完啦&quot;)print(&quot;-----out of while loop ------&quot;)输出Loop 1Loop 2Loop 3Loop 4Loop 5Loop 6循环正常执行完啦 #没有被break打断，所以执行了该行代码-----out of while loop ------ 如果执行过程中被break，就不会执行else的语句 12345678910111213count = 0while count &lt;= 5 : count += 1 if count == 3: break print(&quot;Loop&quot;,count)else: print(&quot;循环正常执行完啦&quot;)print(&quot;-----out of while loop ------&quot;)输出Loop 1Loop 2-----out of while loop ------ #由于循环被break打断了，所以不执行else后的输出语句 练习练习1 寻找1到100之间数字7最大的倍数（结果是98） 123456number=100while number&gt;0: if number%7==0: print(number) break number-=1 练习2 1234567891011age=18count=0while count&lt;3: count+=1 guess = int(input(&quot;&gt;&gt;:&quot;)) if guess &gt; age : print(&quot;猜的太大了，往小里试试...&quot;) elif guess &lt; age : print(&quot;猜的太小了，往大里试试...&quot;) else: print(&quot;恭喜你，猜对了...&quot;) for循环语法循环结构的第二种实现方式是for循环，for循环可以做的事情while循环都可以实现，之所以用for循环是因为在循环取值（即遍历值）时for循环比while循环的使用更为简洁 1234567891011121314151617for 变量名 in 可迭代对象: # 此时只需知道可迭代对象可以是字符串\\列表\\字典，我们之后会专门讲解可迭代对象 代码一 代码二 ...#例1for item in [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]: print(item)# 运行结果abc# 参照例1来介绍for循环的运行步骤# 步骤1：从列表[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]中读出第一个值赋值给item（item=‘a’），然后执行循环体代码# 步骤2：从列表[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]中读出第二个值赋值给item（item=‘b’），然后执行循环体代码# 步骤3: 重复以上过程直到列表中的值读尽 for循环应用案例案例一：打印数字0-5 123456789# 简单版：for循环的实现方式for count in range(6): # range(6)会产生从0-5这6个数 print(count)# 复杂版：while循环的实现方式count = 0while count &lt; 6: print(count) count += 1 案例二：遍历字典 12345# 简单版：for循环的实现方式for k in &#123;&#x27;name&#x27;:&#x27;jason&#x27;,&#x27;age&#x27;:18,&#x27;gender&#x27;:&#x27;male&#x27;&#125;: # for 循环默认取的是字典的key赋值给变量名k print(k)# 复杂版：while循环确实可以遍历字典，后续将会迭代器部分详细介绍 案例三：for循环嵌套 123456789#请用for循环嵌套的方式打印如下图形：***************for i in range(3): for j in range(5): print(&quot;*&quot;,end=&#x27;&#x27;) print() # print()表示换行 注意：break 与 continue也可以用于for循环，使用语法同while循环 练习练习一： 打印九九乘法表 1234for i in range(1,10): for j in range(1,i+1): print(&#x27;%s*%s=%s&#x27; %(i,j,i*j),end=&#x27; &#x27;) print() 练习二： 打印金字塔 123456789101112131415161718192021# 分析&#x27;&#x27;&#x27;#max_level=5 * # current_level=1，空格数=4，*号数=1 *** # current_level=2,空格数=3,*号数=3 ***** # current_level=3,空格数=2,*号数=5 ******* # current_level=4,空格数=1,*号数=7 ********* # current_level=5,空格数=0,*号数=9# 数学表达式空格数=max_level-current_level*号数=2*current_level-1&#x27;&#x27;&#x27;# 实现：max_level=5for current_level in range(1,max_level+1): for i in range(max_level-current_level): print(&#x27; &#x27;,end=&#x27;&#x27;) #在一行中连续打印多个空格 for j in range(2*current_level-1): print(&#x27;*&#x27;,end=&#x27;&#x27;) #在一行中连续打印多个空格 print()","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"6、与用户交互、运算符","slug":"06、python语法入门--与用户交互、运算符","date":"2018-05-13T06:04:05.000Z","updated":"2022-05-13T12:27:54.229Z","comments":true,"path":"2018/05/13/06、python语法入门--与用户交互、运算符/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/06%E3%80%81python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8--%E4%B8%8E%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"与用户交互123456789101112131415161718192021输入 input # python2与python3的区别 &#x27;&#x27;&#x27;python3&#x27;&#x27;&#x27; # 将获取到的用户输入赋值给变量名res res = input(&#x27;please input your username&gt;&gt;&gt;:&#x27;) print(res, type(res)) # id返回一串数字(可以看成是内存地址) type返回变量值的数据类型 &#x27;&#x27;&#x27;input获取到的用户输入都会存成字符串形式&#x27;&#x27;&#x27; &#x27;&#x27;&#x27;python2&#x27;&#x27;&#x27; input需要用户自己人为的指定输入的数据类型 &#x27;jason&#x27; [1,2,3,4] raw_input等价于python3里面的input输出 print 1.先写print print(&#x27;jason&#x27;) 2.先写待打印的内容 &#x27;jason&#x27;.print # tab键即可 格式化输出12345678910111213141516171819202122232425262728# my name is 用户输入的用户名 my age is 用户输入的年龄# 1.获取用户的用户名和密码# name = input(&#x27;username&gt;&gt;&gt;:&#x27;)# age = input(&#x27;age&gt;&gt;&gt;:&#x27;)# 2.打印规定的文本内容# print(&#x27;my name is&#x27;, name, &#x27;my age is&#x27;, age)# 格式化输出# 提前定义文本模板# tmp = &#x27;my name is %s my age is %s&#x27;&quot;&quot;&quot;%s是一个占位符 后续传值替换即可&quot;&quot;&quot;# name = input(&#x27;username&gt;&gt;&gt;:&#x27;)# age = input(&#x27;age&gt;&gt;&gt;:&#x27;)# print(tmp % (name, age)) # 按照先后顺序一一传值# print(&#x27;my name is %s my age is %s&#x27; % (&#x27;jason&#x27;)) # 少了不行# print(&#x27;my name is %s my age is %s&#x27; % (&#x27;jason&#x27;,123,12)) # 多了也不行&quot;&quot;&quot;%d也是一个占位符 只能给数字占位&quot;&quot;&quot;# print(&#x27;my name is %s my age is %s&#x27;%(&#x27;jason&#x27;,&#x27;123&#x27;) )# print(&#x27;my name is %s my age is %d&#x27;%(&#x27;jason&#x27;,123) )print(&#x27;%08d&#x27;%123)print(&#x27;%08d&#x27;%213213213213) 运算符1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131.赋值运算符 name = &#x27;jason&#x27; # 先看右边再看左边 2.算术运算符 + 加 - 减 * 乘 / 除 // 整除 % 取余 ** 幂指数 print(1 - 1) print(1 * 10) print(10 / 2) print(10 // 3) print(10 % 3) print(2 ** 4) # python语言对数字的精确的其实并不是很高 需要借助于&#x27;大佬&#x27;辅助 # 其他数据类型也可以使用局部的数学运算符 print(&#x27;hello&#x27; + &#x27;world&#x27;) # 字符串拼接 print(&#x27;hello&#x27;*2) # 字符串复制 3.增量赋值 x = 1 x = x + 1 # 等价于 x += 1 print(x) x -= 1 # x = x - 1 x *= 1 # x = x * 1 x /= 1 # x = x / 1 ...4.链式赋值 # x y z 10 # x = 10 # y = x # z = x # 链式赋值 x = y = z = 10 5.交叉赋值(面试题可能会出) x = 10 y = 999 # 将x与y对调指向 # x = y # y = x # print(x,y) # 方式1 中间变量 # z = x # x = y # y = z # print(x,y) # 交叉赋值 x, y = y, x print(x, y) 6.解压赋值 # name_list = [&#x27;jason&#x27;,&#x27;egon&#x27;,&#x27;tony&#x27;,&#x27;kevin&#x27;] # name1 = name_list[0] # name2 = name_list[1] # name3 = name_list[2] # name4 = name_list[3] # print(name1,name2,name3,name4) # 解压赋值 # name1, name2, name3, name4 = name_list # 按照位置一一对应赋值 # print(name1, name2, name3, name4) # name1, name2, name3 = name_list # 少了不行 # name1, name2, name3, name4, name5 = name_list # 多了不行 # 可以打破个数必须相等的情况 l = [11, 22, 33, 44, 55, 66, 77, 88, 99] a, b, *_, c = l print(a, b, _, c) a, b, *_ = l print(a, b, _) &quot;&quot;&quot; *_ 下划线表示接收到的数据无需使用 &quot;&quot;&quot;7.比较运算符 &gt; &lt; &gt;= &lt;= == != print(10 &gt; 2) print(2 == 2) print(3 != 4) # 补充 print(&#x27;hello&#x27; &gt; &#x27;world&#x27;) &quot;&quot;&quot; 字母内部对应着数字 A-Z 65-90 a-z 97-122 &quot;&quot;&quot; print([1,2,3] &gt; [0,1,2,3,4,5,6,7,8,9])8.逻辑运算符 与 and 连接多个条件 条件必须都成立 或 or 连接多个条件 一个成立就可以 非 not 取反 print(True and False and 8) print(True or False or 8 ) print(not True) # 布尔值为False: 0 None &#x27;&#x27; [] &#123;&#125; (重要) &quot;&quot;&quot; 三者混合使用是存在优先级的 但是我们在混合使用的时候不应该考虑优先级 通过加括号的形式来明确优先级 &quot;&quot;&quot;","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"5、垃圾回收机制","slug":"05、python语法入门--垃圾回收机制","date":"2018-05-13T06:04:04.000Z","updated":"2022-05-13T12:27:51.693Z","comments":true,"path":"2018/05/13/05、python语法入门--垃圾回收机制/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/05%E3%80%81python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"","text":"123456789101112131415161718192021222324252627# （1）垃圾回收机制GC# 引用计数# x = 10 # 值10引用计数为1# y = x # 值10引用计数为2## y = 1000 # 值10引用计数减少为1# del x # 值10引用计数减少为0# 分代回收-》解决引用计数效率问题（存活时间越长扫描频率越低）# 标记/清除-》解决引用计数有可能会发生内存泄漏（除了可以访问的标记，其余的应清除）# ps：如果我们想要回收python程序的内存空间，只能通过把变量值的引用计数减为0的方式实现# （2）小整数池: -5 256 pycharm里要大一些# x = 1000# y = 1000# x = &quot;egon&quot;# y = &quot;egon&quot;# print(id(l1))# print(id(l2))# 总：# 1、id相等，值一定相等# 2、值相等，id不一定相等","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"4、基本数据类型","slug":"04、python语法入门--基本数据类型","date":"2018-05-13T06:04:03.000Z","updated":"2022-05-13T12:27:49.263Z","comments":true,"path":"2018/05/13/04、python语法入门--基本数据类型/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/04%E3%80%81python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8--%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# python是一门解释型的、强类型的、动态语言# 一：数字类型# 1.1 整型int：记录人的年龄、等级、号码、个数# age = 18# print(type(age))# 1.2 浮点数float：记录人的薪资、身高、体重# salary = 3.7# print(type(salary))# x = 18# y = 3.7# print(x + y)# print(x &gt; y)# 二：字符串:记录描述性质的状态，比如名字、一段话、性别# x = &quot;两个黄鹂鸣翠柳&quot;# y = &#x27;两个黄鹂鸣翠柳&#x27;# m = &quot;&quot;&quot;两个黄鹂鸣翠柳&quot;&quot;&quot;# n = &#x27;&#x27;&#x27;两个黄鹂鸣翠柳&#x27;&#x27;&#x27;## print(x)# print(y)# print(m)# print(n)# msg = &quot;my name is &#x27;egon&#x27;&quot;# print(msg,type(msg))# gender = 1# gender = 0# age # 变量名# &quot;age&quot; # 变量值的一种，str# 了解：# print(&quot;abc&quot;+&quot;xxx&quot;)# print(&quot;abc&quot;*3)# print(&quot;*&quot;*50)# print(&#x27;hello&#x27;)# print(&quot;*&quot;*50)# 三 列表：按照位置存放多个值，比如记录一个人的爱好# hobbies = &quot;打篮球 阅读 看电影&quot;# 0 1 2# hobbies = [&quot;打篮球&quot;, &quot;阅读&quot;, &quot;看电影&quot;]# print(hobbies[0])# print(hobbies[1])# print(hobbies[2])# print(hobbies[3])# print(hobbies[-1])# print(hobbies[-2])# # 0 1 2 3# l1 = [1111,1.3333,&quot;aaa&quot;,[&#x27;bbb&#x27;,&#x27;ccc&#x27;]]# # print(type(l1))## print(l1[3][0])# 四：字典类型：在&#123;&#125;内，按照key:value的格式存放多个元素，其中value可以是任意类型，而key通常是str类型# info = [&quot;egon&quot;, 18, 1.8, 80, &quot;male&quot;]# info = &#123;# &quot;name&quot;: &quot;egon&quot;,# &quot;age&quot;: 18,# &quot;height&quot;: 1.8,# &quot;weight&quot;: 80,# &quot;gender&quot;: &quot;male&quot;# &#125;# print(info[&quot;name&quot;])# print(info[&quot;xxxx&quot;])# info = [&quot;egon&quot;,18,&quot;male&quot;]# dic = &#123;&quot;k1&quot;:11111,&quot;k2&quot;:1.3,&quot;k3&quot;:&quot;xxx&quot;,&#x27;k4&#x27;:[111,222,333],&quot;k5&quot;:&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#125;# print(dic[&#x27;k4&#x27;][1])# print(dic[&#x27;k5&#x27;][&quot;a&quot;])# 五 布尔：记录真假# print(type(True))# print(type(False))# x = True# y = Trueprint(10 &gt; 3)","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"3、注释、变量","slug":"03、python语法入门--注释、变量","date":"2018-05-13T06:04:02.000Z","updated":"2022-05-13T12:27:46.812Z","comments":true,"path":"2018/05/13/03、python语法入门--注释、变量/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/03%E3%80%81python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8--%E6%B3%A8%E9%87%8A%E3%80%81%E5%8F%98%E9%87%8F/","excerpt":"","text":"注释12345678910111213141516171819202122&quot;&quot;&quot;多行注释加在整个py文件的开头用来对该py文件进行一个整体性的说明通常一个py中只有一个多行注释&quot;&quot;&quot;# 这是一行贼溜的代码print(&quot;hello&quot;) # 这是一行贼溜的代码# ctrl+？：批量加减少注释# print(&#x27;hello1&#x27;)# print(&#x27;hello2&#x27;)# print(&#x27;hello3&#x27;)print(&#x27;end&#x27;)&quot;&quot;&quot;总结：注释的两种用途1、对代码进行注解说明，增强代码的可读性2、注释掉暂时不想运行的代码，调试&quot;&quot;&quot; 变量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&quot;&quot;&quot;1、什么是变量 量：事物的状态 变：事物的状态是可以变化的 变量就是一种机制/语法？ 可以把事物的状态存起来，并且以后可以取出来修改 变量其实是一种存取内存的机制2、为何要用变量 是为了让计算机能够像人一样记住事物的状态，并且以后可以改变3、如何用变量 原则：先定义，后引用 定义语法： 变量名 = 变量值 引用： 变量名&quot;&quot;&quot;# 一 先定义、后引用# print(age)# name = &quot;egon&quot;# age = 18# height = 1.8# level = 10## print(name)# 二 定义变量的三大组成部分# 2.1 变量名：访问变量值# 2.2 赋值符号：把变量值的内存地址绑定给变量名# 2.3 变量值：就是我们记录的事物的状态，即存储的数据# 三 变量名命名# 3.1 大前提：见名知意# 3.2 规范：# 1、字母、数字、下划线组成# 2、不能以数字开头# 3、不能与python关键字冲突# [&#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;exec&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;print&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]# level = 18# age = 18# print = 100# 3.3 命名风格# （1） 纯小写加下划线(变量名的命名推荐使用该中风格)# age_of_egon = 18# （2） 驼峰体# AgeOfEgon = 18# 3.4 拓展# print(1)# print(2)# print(3)# # print(# asdfasfd# print(&#x27;end&#x27;)# age = 18## age = age + 1## print(age)# 四：变量值# 4.1 变量值有两大特征#（1）id号：是变量值的身份证号，反映的内存地址# name = &quot;egon&quot;# age = 18# print(id(name))# print(id(age))#（2）type类型：# print(type(name))# print(type(age))# is ：判断id是否相等# ==：判断值是否相等# l1 = [1,2,3]# l2 = [1,2,3]# print(l1 == l2)# print(l1 is l2)","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"2、编程语言与Python","slug":"02、编程语言与pyhon","date":"2018-05-13T06:04:01.000Z","updated":"2022-05-13T12:50:24.981Z","comments":true,"path":"2018/05/13/02、编程语言与pyhon/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/02%E3%80%81%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8Epyhon/","excerpt":"","text":"编程语言分类机器语言：直接用计算机能理解的二进制指令去编写程序，是直接在控制计算机硬件 ​ 优点：运行效率高 ​ 缺点：开发效率低 ​ 1.开发一个简单的小功能都要哟个到非常多条数的二进制指令 ​ 2.二进制指令非常难记忆 汇编语言：用英文标签取代二进制指令去编写程序，也直接控制计算机硬件 ​ 只解决了机器语言难记忆的问题 高级语言：用人类能理解的表达方式去编写程序 ​ 编译型：c、go ​ 源代码（人话）———-编译器———-计算机能理解的二进制指令 ​ 解释型：python、shell ​ 源代码（人话）———-编译器———-计算机能理解的二进制指令 12345第一次运行python程序，python解释器会生成字节码文件第二次运行python程序的时候，python解释器运行的是字节码文件解释型语言编写程序每次运行都离不开解释器编译型语言编写程序如果编译成功，在第二次运行的不需要编译器 python语言的三大特性1.语法简单，上手容易 2.封装程度高 3.有丰富的第三方库 编写python的两大地方1.交互式环境 python3 D:\\ a.py 2.写入文件（主流：永久保存代码） ide集成开发环境 ​ 超级编辑器：pycharm 运行python的三个阶段1.先运行python解释器 2.python解释器将a.py的内容从硬盘读入内存 3.python解释器识别刚刚读入内存的内容，解释执行 ps：我们的python程序调用的都是解释器的功能 遵守PEP8规范","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]},{"title":"1、计算机核心基础","slug":"01、计算机核心基础","date":"2018-05-13T06:04:00.000Z","updated":"2022-05-13T12:27:31.812Z","comments":true,"path":"2018/05/13/01、计算机核心基础/","link":"","permalink":"https://chenxiao0629.github.io/2018/05/13/01%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/","excerpt":"","text":"编程语言介绍引入：python是一门编程语言 编程语言的本质就是一门语言 语言是一种事物与另外一种事物沟通的工具 所以说编程语言也是一种事物与另一种事物沟通的工具 人———–编程语言—————计算机 人为何要与计算机沟通？在IT领域计算机是人类的奴隶 人与计算机沟通的目的就是为了奴役计算机 什么是编程？（翻译官）两个环节1.把做事的步骤给想清楚了（2&#x2F;3时间） 2.用计算机能听懂的语言也就是编程语言把做事的步骤给翻译下来（1&#x2F;3时间） 12345678910举例：银行行长------------------------业务员 接收用户输入的用户名 接收用户输入的密码 判断 输入的用户名 等于 正确的用户名 并且 输入的密码 等于 正确的密码 告诉用户登录成功 否则 告诉用户登录失败银行行长------------------------计算机 为何要编程为了让计算机帮我们做事 什么是程序&#x2F;软件程序就是一序列代码文件 计算机基础计算机的硬件组成与运行原理大前提：计算机的核心硬件组成是为了模仿人的某一器官或功能 1.控制器：是计算机的指挥系统，负责控制所有其他硬件的运行 人脑 2.运算器：负责数学运算和逻辑运算 人脑 ​ 控制器+运算器-》cpu（4核&lt;4核8线程&lt;8核） 人脑 3.存储器： ​ 内存：存的是电信号，断电数据丢失 人的记忆功能 ​ 特点：存取速度都快，但是只能临时存放数据 ​ 外存（磁盘）存的是磁信号，断电数据依然存在 笔记 ​ 特点：存放数据都慢，但是可以永久保存数据 4.输入设备 ​ 键盘、鼠标 5.输出设备 ​ 显示器、音响、打印机 三大核心硬件cpu： X86 X32 ARM 内存 -》主存（RAM） ROM:非易失 CMOS：易失，存时间日期等 硬盘：机械磁盘（平均延迟时间为转半圈时间、平均寻道时间一般5ms（工艺水平决定））、固态硬盘 运行程序安装的程序是存放在硬盘中的 程序的运行要经历的步骤（2个）1.加载&#x2F;启动：需要将程序的代码从硬盘读入内存中 （固态硬盘提速） 2.运行：cpu从内存中读取指令运行 （加内存条提速） 计算机组成原理操作系统 计算机网络 数据结构 123456787200转/60s120转/s 转一圈：0.008s-》8ms 平均延迟时间：转半圈-》4ms 平均寻道时间：5ms机械磁盘找到数据需要经历的时间=平均延迟时间+平均寻道时间所以机械磁盘慢是慢在找数据上，至于找到数据之后往内存读，这个速度是很快的 ​ ​ 有些商家的500GB&#x3D;500 *1000 * 1000 * 1000B 虚拟内存：内存的1.5-2倍，一般不超过8GB 计算机三层体系结构应用程序 —-》图形界面（桌面、python.exe) 操作系统 —-》文件 计算机硬件 —-》硬盘 桌面程序是一种图形化界面管理其他应用程序的软件 商用计算机服务器 操作系统操作系统的安装于启动刚启动：BIOS找真正的操作系统，找到后慢慢退出 ​ cpu ​ ROM（BIOS: basic input output system）—–电路刻死的 ​ CMOS 启动完成： ​ cpu ​ RAM: Windows系统 ​ 本地硬盘 平台平台 &#x3D; 计算机硬件 + 操作系统 跨平台性：开发的软件可以在任何平台正常运行","categories":[],"tags":[{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]}],"categories":[],"tags":[{"name":"3、Linux架构","slug":"3、Linux架构","permalink":"https://chenxiao0629.github.io/tags/3%E3%80%81Linux%E6%9E%B6%E6%9E%84/"},{"name":"9、django-vue-admin项目","slug":"9、django-vue-admin项目","permalink":"https://chenxiao0629.github.io/tags/9%E3%80%81django-vue-admin%E9%A1%B9%E7%9B%AE/"},{"name":"8、vue笔记","slug":"8、vue笔记","permalink":"https://chenxiao0629.github.io/tags/8%E3%80%81vue%E7%AC%94%E8%AE%B0/"},{"name":"10、爬虫","slug":"10、爬虫","permalink":"https://chenxiao0629.github.io/tags/10%E3%80%81%E7%88%AC%E8%99%AB/"},{"name":"7、drf笔记","slug":"7、drf笔记","permalink":"https://chenxiao0629.github.io/tags/7%E3%80%81drf%E7%AC%94%E8%AE%B0/"},{"name":"6、Django笔记","slug":"6、Django笔记","permalink":"https://chenxiao0629.github.io/tags/6%E3%80%81Django%E7%AC%94%E8%AE%B0/"},{"name":"5、数据库之MySQL","slug":"5、数据库之MySQL","permalink":"https://chenxiao0629.github.io/tags/5%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8BMySQL/"},{"name":"2、Linux基础","slug":"2、Linux基础","permalink":"https://chenxiao0629.github.io/tags/2%E3%80%81Linux%E5%9F%BA%E7%A1%80/"},{"name":"4、前端基础","slug":"4、前端基础","permalink":"https://chenxiao0629.github.io/tags/4%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"1、Python基础","slug":"1、Python基础","permalink":"https://chenxiao0629.github.io/tags/1%E3%80%81Python%E5%9F%BA%E7%A1%80/"}]}